// grep - Search for patterns in files
// Usage: grep [OPTIONS] <pattern> [file...]
//
// Options:
//   -i          Case-insensitive search
//   -n          Show line numbers
//   -v          Invert match (show non-matching lines)
//   -c          Count matching lines only
//   -l          List filenames only
//   -H          Always show filename
//   -h          Never show filename
//
// Examples:
//   grep error /var/log/kernel.log
//   grep -i "hello" /usr/bin/ls
//   grep -n TODO /usr/bin/ls

// Color helper functions (Rhai requires functions at top level)
fn get_red() { "\x1b[1;31m" }
fn get_green() { "\x1b[1;32m" }
fn get_cyan() { "\x1b[1;36m" }
fn get_magenta() { "\x1b[1;35m" }
fn get_reset() { "\x1b[0m" }

// Check if line contains pattern
fn line_matches(line, pat, ignore_case) {
    let search_line = line;
    let search_pat = pat;
    
    if ignore_case {
        search_line = line.to_lower();
        search_pat = pat.to_lower();
    }
    
    search_line.contains(search_pat)
}

// Highlight matches in a line
fn highlight_match(line, pat, ignore_case) {
    let RED = "\x1b[1;31m";
    let RESET = "\x1b[0m";
    let result = "";
    let search_line = if ignore_case { line.to_lower() } else { line };
    let search_pat = if ignore_case { pat.to_lower() } else { pat };
    
    let pos = 0;
    while pos < line.len() {
        let remaining = search_line.sub_string(pos);
        let idx = remaining.index_of(search_pat);
        
        if idx < 0 {
            result += line.sub_string(pos);
            break;
        }
        
        // Add text before match
        if idx > 0 {
            result += line.sub_string(pos, idx);
        }
        
        // Add highlighted match
        result += RED + line.sub_string(pos + idx, pat.len()) + RESET;
        
        pos += idx + pat.len();
    }
    
    result
}

// Search a single file
fn search_file(filepath, pattern, case_insensitive, show_line_numbers, 
               invert_match, count_only, list_files_only, show_name) {
    let MAGENTA = "\x1b[1;35m";
    let GREEN = "\x1b[1;32m";
    let RESET = "\x1b[0m";
    let RED = "\x1b[1;31m";
    
    if !file_exists(filepath) {
        print(RED + "grep: " + filepath + ": No such file" + RESET);
        return 0;
    }
    
    let content = read_file(filepath);
    if content == "" {
        return 0;
    }
    
    let file_lines = content.split("\n");
    let match_count = 0;
    
    for line_num in range(0, file_lines.len()) {
        let line = file_lines[line_num];
        let is_match = line_matches(line, pattern, case_insensitive);
        
        // Apply invert if needed
        if invert_match {
            is_match = !is_match;
        }
        
        if is_match {
            match_count += 1;
            
            if list_files_only {
                // Just print filename once and return
                print(MAGENTA + filepath + RESET);
                return 1;
            }
            
            if !count_only {
                let output = "";
                
                // Filename
                if show_name {
                    output += MAGENTA + filepath + RESET + ":";
                }
                
                // Line number
                if show_line_numbers {
                    output += GREEN + (line_num + 1).to_string() + RESET + ":";
                }
                
                // Line content with highlighting
                if !invert_match {
                    output += highlight_match(line, pattern, case_insensitive);
                } else {
                    output += line;
                }
                
                print(output);
            }
        }
    }
    
    if count_only {
        if show_name {
            print(MAGENTA + filepath + RESET + ":" + match_count.to_string());
        } else {
            print(match_count);
        }
    }
    
    match_count
}

// Options
let case_insensitive = false;
let show_line_numbers = false;
let invert_match = false;
let count_only = false;
let list_files_only = false;
let always_show_filename = false;
let never_show_filename = false;

// Arguments
let pattern = "";
let files = [];

// Parse arguments
let i = 0;
while i < ARGS.len() {
    let arg = ARGS[i];
    
    if arg.starts_with("-") && arg.len() > 1 && !arg.starts_with("--") {
        // Parse option flags
        for ch in arg.chars() {
            if ch == 'i' { case_insensitive = true; }
            if ch == 'n' { show_line_numbers = true; }
            if ch == 'v' { invert_match = true; }
            if ch == 'c' { count_only = true; }
            if ch == 'l' { list_files_only = true; }
            if ch == 'H' { always_show_filename = true; }
            if ch == 'h' { never_show_filename = true; }
        }
    } else if pattern == "" {
        pattern = arg;
    } else {
        files.push(arg);
    }
    
    i += 1;
}

// Validate arguments
if pattern == "" {
    print("Usage: grep [OPTIONS] <pattern> [file...]");
    print("");
    print("Search for PATTERN in each FILE.");
    print("");
    print("Options:");
    print("  -i    Case-insensitive search");
    print("  -n    Show line numbers");
    print("  -v    Invert match (show non-matching lines)");
    print("  -c    Count matching lines only");
    print("  -l    List filenames with matches only");
    print("  -H    Always show filename");
    print("  -h    Never show filename");
    print("");
    print("Examples:");
    print("  grep error /var/log/kernel.log");
    print("  grep -in TODO /usr/bin/ls");
} else {
    // Get list of files to search
    let search_files = [];
    
    if files.len() == 0 {
        // No files specified - search files in current directory
        let all_files = ls();
        let cwd_val = cwd();
        
        for f in all_files {
            let name = f.name;
            // Check if file is in current directory (not a subdirectory)
            if cwd_val == "/" {
                if name.starts_with("/") && !name.sub_string(1).contains("/") {
                    search_files.push(name);
                }
            } else {
                if name.starts_with(cwd_val + "/") {
                    let relative = name.sub_string(cwd_val.len() + 1);
                    if !relative.contains("/") {
                        search_files.push(name);
                    }
                }
            }
        }
    } else {
        // Resolve provided paths
        for path in files {
            let full_path = path;
            if !path.starts_with("/") {
                let cwd_val = cwd();
                if cwd_val == "/" {
                    full_path = "/" + path;
                } else {
                    full_path = cwd_val + "/" + path;
                }
            }
            search_files.push(full_path);
        }
    }
    
    // Main search
    let total_matches = 0;
    let show_filename = always_show_filename || (search_files.len() > 1 && !never_show_filename);
    
    for filepath in search_files {
        total_matches += search_file(filepath, pattern, case_insensitive, 
                                     show_line_numbers, invert_match, count_only, 
                                     list_files_only, show_filename);
    }
}
