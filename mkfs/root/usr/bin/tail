// tail - Output the last part of files
// Usage: tail [OPTIONS] [FILE...]
//
// Options:
//   -n, --lines=NUM    Output the last NUM lines (default: 10)
//   -c, --bytes=NUM    Output the last NUM bytes
//   -f, --follow       Output appended data as the file grows
//   -q, --quiet        Never output headers giving file names
//   -v, --verbose      Always output headers giving file names
//   --help             Display this help and exit
//
// Examples:
//   tail /var/log/kernel.log        Show last 10 lines
//   tail -n 20 /var/log/kernel.log  Show last 20 lines
//   tail -f /var/log/kernel.log     Follow file (Ctrl+C to stop)
//   tail -c 100 file.txt            Show last 100 bytes

// Helper functions (must be at top level in Rhai)
fn get_bold() { "\x1b[1m" }
fn get_cyan() { "\x1b[1;36m" }
fn get_yellow() { "\x1b[1;33m" }
fn get_red() { "\x1b[1;31m" }
fn get_dim() { "\x1b[2m" }
fn get_reset() { "\x1b[0m" }

// Get last N lines from content
fn get_last_lines(content, num_lines) {
    if content == "" {
        return [];
    }
    
    let lines = content.split("\n");
    let total = lines.len();
    
    // Handle trailing newline
    if total > 0 && lines[total - 1] == "" {
        total -= 1;
    }
    
    let start = if total > num_lines { total - num_lines } else { 0 };
    let result = [];
    
    for i in range(start, total) {
        result.push(lines[i]);
    }
    
    result
}

// Get last N bytes from content
fn get_last_bytes(content, num_bytes) {
    let len = content.len();
    if len <= num_bytes {
        return content;
    }
    content.sub_string(len - num_bytes)
}

// Print file header
fn print_header(filename, is_first) {
    let BOLD = "\x1b[1m";
    let RESET = "\x1b[0m";
    
    if !is_first {
        print("");
    }
    print(BOLD + "==> " + filename + " <==" + RESET);
}

// Tail a single file
fn tail_file(filepath, num_lines, num_bytes, show_header, is_first) {
    let RED = "\x1b[1;31m";
    let RESET = "\x1b[0m";
    
    if !file_exists(filepath) {
        print(RED + "tail: cannot open '" + filepath + "' for reading: No such file" + RESET);
        return false;
    }
    
    let content = read_file(filepath);
    
    if show_header {
        print_header(filepath, is_first);
    }
    
    if num_bytes > 0 {
        // Byte mode
        let result = get_last_bytes(content, num_bytes);
        // Print without trailing newline if content doesn't have one
        if result.ends_with("\n") {
            print(result.sub_string(0, result.len() - 1));
        } else {
            print(result);
        }
    } else {
        // Line mode (default)
        let lines = get_last_lines(content, num_lines);
        for line in lines {
            print(line);
        }
    }
    
    true
}

// Follow a file (like tail -f)
// Due to the cooperative shell model, this does a quick follow check
// and then exits. Run repeatedly for continuous monitoring.
fn follow_file(filepath, num_lines, wait_seconds) {
    let RED = "\x1b[1;31m";
    let YELLOW = "\x1b[1;33m";
    let GREEN = "\x1b[1;32m";
    let DIM = "\x1b[2m";
    let CYAN = "\x1b[1;36m";
    let RESET = "\x1b[0m";
    
    if !file_exists(filepath) {
        print(RED + "tail: cannot open '" + filepath + "' for reading: No such file" + RESET);
        return;
    }
    
    // Show initial content
    let content = read_file(filepath);
    let lines = get_last_lines(content, num_lines);
    for line in lines {
        print(line);
    }
    
    let initial_size = content.len();
    
    // Wait and check for new content
    if wait_seconds > 0 {
        print(DIM + "--- Watching for " + wait_seconds.to_string() + "s... ---" + RESET);
        
        // Check multiple times during the wait period
        let checks = wait_seconds * 2;  // Check every 500ms
        let last_size = initial_size;
        let new_lines_found = 0;
        
        for i in range(0, checks) {
            sleep(500);  // 500ms intervals
            
            if !file_exists(filepath) {
                print(YELLOW + "tail: '" + filepath + "' has been removed" + RESET);
                return;
            }
            
            let new_content = read_file(filepath);
            let new_size = new_content.len();
            
            if new_size > last_size {
                // File grew - print new content
                let new_part = new_content.sub_string(last_size);
                let new_file_lines = new_part.split("\n");
                for j in range(0, new_file_lines.len()) {
                    let line = new_file_lines[j];
                    if j < new_file_lines.len() - 1 || line != "" {
                        print(GREEN + "+ " + RESET + line);
                        new_lines_found += 1;
                    }
                }
                last_size = new_size;
            } else if new_size < last_size {
                print(YELLOW + "tail: file truncated" + RESET);
                last_size = new_size;
            }
        }
        
        if new_lines_found == 0 {
            print(DIM + "--- No new content after " + wait_seconds.to_string() + "s ---" + RESET);
        } else {
            print(DIM + "--- " + new_lines_found.to_string() + " new line(s) ---" + RESET);
        }
    }
    
    print(CYAN + "Tip: Run 'tail -f " + filepath + "' again to continue monitoring" + RESET);
}

// Show help
fn show_help() {
    let BOLD = "\x1b[1m";
    let CYAN = "\x1b[1;36m";
    let YELLOW = "\x1b[1;33m";
    let RESET = "\x1b[0m";
    
    print(BOLD + "tail" + RESET + " - Output the last part of files");
    print("");
    print(BOLD + "USAGE:" + RESET);
    print("    tail [OPTIONS] [FILE...]");
    print("");
    print(BOLD + "OPTIONS:" + RESET);
    print("    " + CYAN + "-n" + RESET + ", " + CYAN + "--lines" + RESET + "=NUM    Output the last NUM lines (default: 10)");
    print("    " + CYAN + "-c" + RESET + ", " + CYAN + "--bytes" + RESET + "=NUM    Output the last NUM bytes");
    print("    " + CYAN + "-f" + RESET + ", " + CYAN + "--follow" + RESET + "[=SEC]   Watch for new content (default: 10 seconds)");
    print("    " + CYAN + "-q" + RESET + ", " + CYAN + "--quiet" + RESET + "         Never output headers giving file names");
    print("    " + CYAN + "-v" + RESET + ", " + CYAN + "--verbose" + RESET + "       Always output headers giving file names");
    print("    " + CYAN + "--help" + RESET + "             Display this help and exit");
    print("");
    print(BOLD + "EXAMPLES:" + RESET);
    print("    tail /var/log/kernel.log         Show last 10 lines");
    print("    tail -n 20 /var/log/kernel.log   Show last 20 lines");  
    print("    tail -f /var/log/kernel.log      Watch file for 10 seconds");
    print("    tail -f30 /var/log/kernel.log    Watch file for 30 seconds");
    print("    tail -c 100 file.txt             Show last 100 bytes");
    print("");
    print(YELLOW + "NOTE:" + RESET + " The -f flag watches for the specified duration, then exits.");
    print("      Run the command again to continue watching.");
}

// Parse arguments
let num_lines = 10;
let num_bytes = 0;
let follow = false;
let follow_time = 10;  // Default 10 seconds for -f
let quiet = false;
let verbose = false;
let files = [];
let show_help_flag = false;

let i = 0;
while i < ARGS.len() {
    let arg = ARGS[i];
    
    if arg == "--help" {
        show_help_flag = true;
    } else if arg == "-f" || arg == "--follow" {
        follow = true;
    } else if arg.starts_with("-f") && arg.len() > 2 {
        // -fNUM format (e.g., -f30 for 30 seconds)
        follow = true;
        let time_str = arg.sub_string(2);
        let parsed = parse_int(time_str);
        if parsed > 0 {
            follow_time = parsed;
        }
    } else if arg.starts_with("--follow=") {
        follow = true;
        let time_str = arg.sub_string(9);
        let parsed = parse_int(time_str);
        if parsed > 0 {
            follow_time = parsed;
        }
    } else if arg == "-q" || arg == "--quiet" {
        quiet = true;
    } else if arg == "-v" || arg == "--verbose" {
        verbose = true;
    } else if arg == "-n" || arg == "--lines" {
        // Next arg is the number
        if i + 1 < ARGS.len() {
            i += 1;
            num_lines = parse_int(ARGS[i]);
            if num_lines <= 0 {
                num_lines = 10;
            }
        }
    } else if arg.starts_with("-n") {
        // -nNUM format
        let num_str = arg.sub_string(2);
        num_lines = parse_int(num_str);
        if num_lines <= 0 {
            num_lines = 10;
        }
    } else if arg.starts_with("--lines=") {
        let num_str = arg.sub_string(8);
        num_lines = parse_int(num_str);
        if num_lines <= 0 {
            num_lines = 10;
        }
    } else if arg == "-c" || arg == "--bytes" {
        // Next arg is the number
        if i + 1 < ARGS.len() {
            i += 1;
            num_bytes = parse_int(ARGS[i]);
            if num_bytes <= 0 {
                num_bytes = 0;
            }
        }
    } else if arg.starts_with("-c") {
        // -cNUM format
        let num_str = arg.sub_string(2);
        num_bytes = parse_int(num_str);
        if num_bytes <= 0 {
            num_bytes = 0;
        }
    } else if arg.starts_with("--bytes=") {
        let num_str = arg.sub_string(8);
        num_bytes = parse_int(num_str);
        if num_bytes <= 0 {
            num_bytes = 0;
        }
    } else if arg.starts_with("-") {
        // Unknown option - might be combined flags like -fq
        for ch in arg.chars() {
            if ch == 'f' { follow = true; }
            if ch == 'q' { quiet = true; }
            if ch == 'v' { verbose = true; }
        }
    } else {
        // It's a file
        files.push(arg);
    }
    
    i += 1;
}

// Main logic
if show_help_flag {
    show_help();
} else if files.len() == 0 {
    // No files specified - show usage
    print("Usage: tail [OPTIONS] [FILE...]");
    print("Try 'tail --help' for more information.");
} else {
    // Resolve file paths
    let resolved_files = [];
    for file in files {
        let path = file;
        if !path.starts_with("/") {
            let cwd_val = cwd();
            if cwd_val == "/" {
                path = "/" + file;
            } else {
                path = cwd_val + "/" + file;
            }
        }
        resolved_files.push(path);
    }
    
    // Determine if we should show headers
    let show_headers = if quiet {
        false
    } else if verbose {
        true
    } else {
        resolved_files.len() > 1
    };
    
    if follow {
        // Follow mode - only works with single file
        if resolved_files.len() > 1 {
            print(get_yellow() + "Warning: --follow only works with a single file" + get_reset());
        }
        follow_file(resolved_files[0], num_lines, follow_time);
    } else {
        // Normal mode - show last lines/bytes
        let is_first = true;
        for filepath in resolved_files {
            tail_file(filepath, num_lines, num_bytes, show_headers, is_first);
            is_first = false;
        }
    }
}

