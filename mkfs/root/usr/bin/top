// top - Real-time process monitor
// Usage: top [OPTIONS]
//
// Options:
//   -n <count>   Number of iterations (default: 1)
//   -d <ms>      Delay between updates in milliseconds (default: 1000)
//   -b           Batch mode (no ANSI escape codes)

import * as sys from "os:sys"
import * as mem from "os:mem"

// Helper functions must be at top level in Rhai

fn get_esc() { "\x1b" }
fn get_clear() { "\x1b[2J" }
fn get_home() { "\x1b[H" }
fn get_clear_line() { "\x1b[K" }
fn get_bold() { "\x1b[1m" }
fn get_reset() { "\x1b[0m" }
fn get_reverse() { "\x1b[7m" }
fn get_red() { "\x1b[31m" }
fn get_green() { "\x1b[32m" }
fn get_yellow() { "\x1b[33m" }
fn get_cyan() { "\x1b[36m" }
fn get_white() { "\x1b[97m" }

fn format_uptime(ms) {
    let secs = ms / 1000;
    let mins = secs / 60;
    let hours = mins / 60;
    let days = hours / 24;
    
    if days > 0 {
        return days.to_string() + "d " + (hours % 24).to_string() + "h";
    } else if hours > 0 {
        return hours.to_string() + "h " + (mins % 60).to_string() + "m";
    } else if mins > 0 {
        return mins.to_string() + "m " + (secs % 60).to_string() + "s";
    } else {
        return secs.to_string() + "s";
    }
}

fn format_bytes(bytes) {
    if bytes >= 1024 * 1024 {
        return (bytes / (1024 * 1024)).to_string() + " MB";
    } else if bytes >= 1024 {
        return (bytes / 1024).to_string() + " KB";
    } else {
        return bytes.to_string() + " B";
    }
}

fn draw_header(batch) {
    let uptime = time_ms();
    let version = kernel_version();
    let harts = harts_online();
    
    if batch {
        print("═══════════════════════════════════════════════════════════════════");
        print(version + " - " + format_uptime(uptime) + " up, " + harts.to_string() + " hart(s)");
    } else {
        write(get_home());
        write(get_bold() + get_cyan());
        print("═══════════════════════════════════════════════════════════════════" + get_clear_line());
        write(get_reset());
        write(get_bold() + get_white() + " " + version + get_reset());
        write(" - " + format_uptime(uptime) + " up, ");
        write(get_green() + harts.to_string() + get_reset() + " hart(s)");
        print(get_clear_line());
    }
}

fn draw_memory(batch) {
    let stats = heap_stats();
    let used = stats.used;
    let free = stats.free;
    let total = used + free;
    let pct = if total > 0 { (used * 100) / total } else { 0 };
    
    // Memory bar
    let bar_width = 30;
    let filled = (pct * bar_width) / 100;
    
    if batch {
        print("");
        let bar = "[";
        for j in range(0, bar_width) {
            if j < filled {
                bar += "#";
            } else {
                bar += "-";
            }
        }
        bar += "]";
        print("Mem: " + bar + " " + pct.to_string() + "% (" + format_bytes(used) + " / " + format_bytes(total) + ")");
    } else {
        print(get_clear_line());
        write("Mem: " + get_cyan() + "[");
        for j in range(0, bar_width) {
            if j < filled {
                if pct > 80 {
                    write(get_red() + "█");
                } else if pct > 60 {
                    write(get_yellow() + "█");
                } else {
                    write(get_green() + "█");
                }
            } else {
                write(get_reset() + "░");
            }
        }
        write(get_cyan() + "]" + get_reset());
        write(" " + pct.to_string() + "% ");
        write("(" + format_bytes(used) + " / " + format_bytes(total) + ")");
        print(get_clear_line());
    }
}

fn draw_processes(batch) {
    let tasks = get_tasks();
    
    if batch {
        print("");
        print("Tasks: " + tasks.len().to_string() + " total");
        print("");
        print("  PID  STATE  PRI     CPU    UPTIME  NAME");
        print("─────────────────────────────────────────────────────────────────");
    } else {
        print(get_clear_line());
        write("Tasks: " + get_bold() + tasks.len().to_string() + get_reset() + " total");
        
        // Count by state
        let running = 0;
        let sleeping = 0;
        let zombie = 0;
        for task in tasks {
            if task.state == "R+" { running += 1; }
            else if task.state == "S" { sleeping += 1; }
            else if task.state == "Z" { zombie += 1; }
        }
        
        write(", " + get_green() + running.to_string() + get_reset() + " running");
        write(", " + get_yellow() + sleeping.to_string() + get_reset() + " sleeping");
        if zombie > 0 {
            write(", " + get_red() + zombie.to_string() + get_reset() + " zombie");
        }
        print(get_clear_line());
        
        print(get_clear_line());
        write(get_bold() + get_reverse());
        print("  PID  STATE  PRI     CPU    UPTIME  NAME                        " + get_clear_line());
        write(get_reset());
    }
    
    // Sort tasks by CPU time (descending)
    tasks.sort(|a, b| {
        if a.cpu_time > b.cpu_time { -1 }
        else if a.cpu_time < b.cpu_time { 1 }
        else { 0 }
    });
    
    // Display tasks
    for task in tasks {
        let pid_str = pad_left(task.pid.to_string(), 5, " ");
        let state_str = pad_right(task.state, 6, " ");
        let pri_str = pad_right(task.priority, 6, " ");
        let cpu_str = pad_left(task.cpu_time.to_string() + "ms", 8, " ");
        let uptime_str = pad_left(format_uptime(task.uptime), 8, " ");
        let name = task.name;
        
        if batch {
            print(pid_str + "  " + state_str + " " + pri_str + " " + cpu_str + " " + uptime_str + "  " + name);
        } else {
            // Color based on state
            let color = if task.state == "R+" { 
                get_green() 
            } else if task.state == "S" { 
                get_yellow() 
            } else if task.state == "Z" { 
                get_red() 
            } else { 
                get_reset() 
            };
            
            write(color);
            write(pid_str + "  " + state_str + " " + pri_str + " " + cpu_str + " " + uptime_str + "  " + name);
            write(get_reset());
            print(get_clear_line());
        }
    }
}

fn draw_footer(batch) {
    if batch {
        print("");
        print("─────────────────────────────────────────────────────────────────");
    } else {
        print(get_clear_line());
        write(get_cyan() + "─────────────────────────────────────────────────────────────────" + get_reset());
        print(get_clear_line());
        write(get_bold() + "Press Ctrl+C to exit" + get_reset());
        print(get_clear_line());
    }
}

fn draw_screen(batch) {
    if !batch {
        write(get_clear());
    }
    
    draw_header(batch);
    draw_memory(batch);
    draw_processes(batch);
    draw_footer(batch);
}

// Parse arguments
let iterations = 1;
let delay_ms = 1000;
let batch_mode = false;

let i = 0;
while i < ARGS.len() {
    let arg = ARGS[i];
    
    if arg == "-n" && i + 1 < ARGS.len() {
        i += 1;
        iterations = parse_int(ARGS[i]);
    } else if arg == "-d" && i + 1 < ARGS.len() {
        i += 1;
        delay_ms = parse_int(ARGS[i]);
    } else if arg == "-b" {
        batch_mode = true;
    } else if arg == "-h" || arg == "--help" {
        print("Usage: top [OPTIONS]");
        print("");
        print("Options:");
        print("  -n <count>   Number of iterations (default: 1)");
        print("  -d <ms>      Delay between updates (default: 1000)");
        print("  -b           Batch mode (no ANSI codes)");
        return;
    }
    
    i += 1;
}

// Main loop
for iter in range(0, iterations) {
    draw_screen(batch_mode);
    
    if iter < iterations - 1 {
        sleep(delay_ms);
    }
}
