// rm - Remove files or directories
// Usage: rm [OPTIONS] <file...>
//
// Options:
//   -r, -R    Remove directories recursively
//   -f        Force removal (ignore nonexistent files)
//   -v        Verbose output

// Color helpers
fn get_green() { "\x1b[1;32m" }
fn get_red() { "\x1b[1;31m" }
fn get_yellow() { "\x1b[1;33m" }
fn get_reset() { "\x1b[0m" }

// Remove a single file (helper function at top level)
fn do_remove_file(path, is_recursive, is_force, is_verbose) {
    let GREEN = "\x1b[1;32m";
    let RED = "\x1b[1;31m";
    let YELLOW = "\x1b[1;33m";
    let RESET = "\x1b[0m";
    
    // Check if it's a directory
    if is_dir(path) {
        if !is_recursive {
            print(RED + "rm: cannot remove '" + path + "': Is a directory" + RESET);
            print("  (Use -r to remove directories)");
            return false;
        }
        
        // Get all files under this directory
        let all_files = ls();
        let dir_prefix = if path.ends_with("/") { path } else { path + "/" };
        let children = [];
        
        for f in all_files {
            if f.name.starts_with(dir_prefix) {
                children.push(f.name);
            }
        }
        
        // Sort by path length (deepest first)
        children.sort(|a, b| {
            if a.len() > b.len() { -1 }
            else if a.len() < b.len() { 1 }
            else { 0 }
        });
        
        // Remove children first - note: rm() is a kernel function
        for child in children {
            // Use the kernel's rm function
            rm(child);
            if is_verbose {
                print(GREEN + "removed '" + child + "'" + RESET);
            }
        }
        
        // Remove directory itself
        if rmdir(path) {
            if is_verbose {
                print(GREEN + "removed directory '" + path + "'" + RESET);
            }
            return true;
        } else {
            if !is_force {
                print(RED + "rm: cannot remove '" + path + "'" + RESET);
            }
            return false;
        }
    } else {
        // Regular file
        if !file_exists(path) {
            if !is_force {
                print(RED + "rm: cannot remove '" + path + "': No such file" + RESET);
            }
            return false;
        }
        
        // Use the kernel's rm function
        if rm(path) {
            if is_verbose {
                print(GREEN + "removed '" + path + "'" + RESET);
            }
            return true;
        } else {
            if !is_force {
                print(RED + "rm: cannot remove '" + path + "'" + RESET);
            }
            return false;
        }
    }
}

// Parse options
let recursive = false;
let force = false;
let verbose = false;
let files = [];

for arg in ARGS {
    if arg.starts_with("-") && arg.len() > 1 {
        for ch in arg.chars() {
            if ch == 'r' || ch == 'R' { recursive = true; }
            if ch == 'f' { force = true; }
            if ch == 'v' { verbose = true; }
        }
    } else {
        files.push(arg);
    }
}

if files.len() == 0 {
    print("Usage: rm [OPTIONS] <file...>");
    print("");
    print("Options:");
    print("  -r, -R    Remove directories recursively");
    print("  -f        Force (ignore nonexistent files)");
    print("  -v        Verbose output");
    print("");
    print("Examples:");
    print("  rm file.txt");
    print("  rm -rf directory/");
} else {
    for file in files {
        // Resolve path
        let path = file;
        if !path.starts_with("/") {
            let cwd_val = cwd();
            if cwd_val == "/" {
                path = "/" + file;
            } else {
                path = cwd_val + "/" + file;
            }
        }
        
        do_remove_file(path, recursive, force, verbose);
    }
}
