This file is a merged representation of a subset of the codebase, containing specifically included files, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of a subset of the repository's contents that is considered the most important context.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Only files matching these patterns are included: riscv-vm/**/*, relay/**/*, mkfs/**/*, kernel/**/*
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
kernel/
  .cargo/
    config.toml
  src/
    allocator.rs
    dns.rs
    fs.rs
    http.rs
    init.rs
    klog.rs
    lock.rs
    main.rs
    net.rs
    scheduler.rs
    scripting.rs
    task.rs
    tls.rs
    tls12.rs
    uart.rs
    virtio_blk.rs
    virtio_net.rs
  .gitignore
  build.rs
  Cargo.toml
  CHANGELOG.md
  link.x
  memory.x
  project.json
  README.md
mkfs/
  root/
    etc/
      init.d/
        klogd
        startup
        sysmond
    home/
      README.md
    usr/
      bin/
        cat
        cowsay
        dmesg
        echo
        help
        ip
        kill
        ls
        memstats
        netstat
        ps
        service
        sysinfo
        uptime
        wget
        write
  src/
    main.rs
  .gitignore
  Cargo.toml
relay/
  src/
    hub.rs
    main.rs
    peer.rs
    protocol.rs
    proxy.rs
  .dockerignore
  Cargo.toml
  CHANGELOG.md
  project.json
  README.md
riscv-vm/
  native/
    .gitignore
    .npmignore
    index.d.ts
    index.js
    index.mjs
  src/
    bus.rs
    clint.rs
    console.rs
    cpu.rs
    csr.rs
    decoder.rs
    dram.rs
    emulator.rs
    lib.rs
    main.rs
    mmu.rs
    napi_bindings.rs
    net_async.rs
    net_external.rs
    net_webtransport.rs
    net.rs
    plic.rs
    shared_mem.rs
    uart.rs
    virtio.rs
    worker.rs
  tsup/
    index.ts
    tsup.cli.ts
    tsup.core.cjs.ts
    tsup.core.esm.ts
    tsup.node-worker.ts
    tsup.worker.ts
  .yarnrc.yml
  build.rs
  build.sh
  Cargo.toml
  CHANGELOG.md
  cli.ts
  index.ts
  node-worker.ts
  package.json
  project.json
  README.md
  tsconfig.json
  worker-utils.ts
  worker.ts
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="kernel/src/allocator.rs">
use linked_list_allocator::LockedHeap;

unsafe extern "C" {
    static mut _sheap: u8;
    static mut _eheap: u8;
}

#[global_allocator]
static ALLOCATOR: LockedHeap = LockedHeap::empty();

/// Initialize the heap allocator.
/// Must be called before any heap allocations occur.
pub fn init() {
    unsafe {
        let heap_start = &raw mut _sheap as *mut u8;
        let heap_end = &raw const _eheap as usize;
        let heap_size = heap_end - (heap_start as usize);
        ALLOCATOR.lock().init(heap_start, heap_size);
    }
}

/// Returns (used, free) bytes in the heap, if the allocator supports introspection.
pub fn heap_stats() -> (usize, usize) {
    let allocator = ALLOCATOR.lock();
    let used = allocator.used();
    let free = allocator.free();
    (used, free)
}

/// Returns the total heap size.
pub fn heap_size() -> usize {
    let heap_start = &raw const _sheap as usize;
    let heap_end = &raw const _eheap as usize;
    heap_end - heap_start
}
</file>

<file path="kernel/src/dns.rs">
//! DNS client implementation for hostname resolution.
//!
//! This module provides DNS query building and response parsing
//! to resolve hostnames to IPv4 addresses.

use alloc::vec::Vec;
use smoltcp::wire::Ipv4Address;

/// DNS query type for A records (IPv4 address)
const DNS_TYPE_A: u16 = 1;
/// DNS class for Internet
const DNS_CLASS_IN: u16 = 1;

/// DNS header flags
const DNS_FLAG_RD: u16 = 0x0100; // Recursion Desired
const DNS_FLAG_QR: u16 = 0x8000; // Query/Response (1 = response)

/// DNS response codes
const DNS_RCODE_MASK: u16 = 0x000F;
#[allow(dead_code)]
const DNS_RCODE_OK: u16 = 0;
const DNS_RCODE_NXDOMAIN: u16 = 3;

/// Transaction ID counter
static mut DNS_TRANSACTION_ID: u16 = 0x1234;

/// Get next transaction ID
fn next_transaction_id() -> u16 {
    unsafe {
        DNS_TRANSACTION_ID = DNS_TRANSACTION_ID.wrapping_add(1);
        DNS_TRANSACTION_ID
    }
}

/// Build a DNS query packet for an A record lookup
/// 
/// Returns (transaction_id, query_packet)
pub fn build_query(hostname: &[u8]) -> (u16, Vec<u8>) {
    let txid = next_transaction_id();
    
    // Estimate packet size: header (12) + name (hostname.len() + 2 for length bytes + 1 for null) + qtype (2) + qclass (2)
    let mut packet = Vec::with_capacity(12 + hostname.len() + 5 + 4);
    
    // DNS Header (12 bytes)
    // Transaction ID
    packet.extend_from_slice(&txid.to_be_bytes());
    // Flags: standard query with recursion desired
    packet.extend_from_slice(&DNS_FLAG_RD.to_be_bytes());
    // Question count: 1
    packet.extend_from_slice(&1u16.to_be_bytes());
    // Answer count: 0
    packet.extend_from_slice(&0u16.to_be_bytes());
    // Authority count: 0
    packet.extend_from_slice(&0u16.to_be_bytes());
    // Additional count: 0
    packet.extend_from_slice(&0u16.to_be_bytes());
    
    // Question section
    // QNAME: domain name encoded as labels
    encode_domain_name(hostname, &mut packet);
    
    // QTYPE: A record (1)
    packet.extend_from_slice(&DNS_TYPE_A.to_be_bytes());
    // QCLASS: IN (1)
    packet.extend_from_slice(&DNS_CLASS_IN.to_be_bytes());
    
    (txid, packet)
}

/// Encode a domain name in DNS format (label length prefix format)
/// e.g., "www.google.com" -> [3]www[6]google[3]com[0]
fn encode_domain_name(hostname: &[u8], packet: &mut Vec<u8>) {
    let mut label_start = 0;
    
    for i in 0..=hostname.len() {
        if i == hostname.len() || hostname[i] == b'.' {
            let label_len = i - label_start;
            if label_len > 0 && label_len <= 63 {
                packet.push(label_len as u8);
                packet.extend_from_slice(&hostname[label_start..i]);
            }
            label_start = i + 1;
        }
    }
    
    // Null terminator
    packet.push(0);
}

/// DNS response parsing result
#[derive(Debug)]
pub enum DnsResult {
    /// Successfully resolved to one or more IPv4 addresses
    Resolved(Vec<Ipv4Address>),
    /// Domain does not exist (NXDOMAIN)
    NotFound,
    /// Server error or malformed response
    Error(&'static str),
    /// Response for wrong transaction ID
    WrongId,
}

/// Parse a DNS response packet
pub fn parse_response(packet: &[u8], expected_txid: u16) -> DnsResult {
    // Minimum DNS header size
    if packet.len() < 12 {
        return DnsResult::Error("Packet too short");
    }
    
    // Check transaction ID
    let txid = u16::from_be_bytes([packet[0], packet[1]]);
    if txid != expected_txid {
        return DnsResult::WrongId;
    }
    
    // Check flags
    let flags = u16::from_be_bytes([packet[2], packet[3]]);
    
    // Verify this is a response
    if flags & DNS_FLAG_QR == 0 {
        return DnsResult::Error("Not a response");
    }
    
    // Check response code
    let rcode = flags & DNS_RCODE_MASK;
    if rcode == DNS_RCODE_NXDOMAIN {
        return DnsResult::NotFound;
    }
    if rcode != 0 {
        return DnsResult::Error("DNS server error");
    }
    
    // Get counts
    let qdcount = u16::from_be_bytes([packet[4], packet[5]]) as usize;
    let ancount = u16::from_be_bytes([packet[6], packet[7]]) as usize;
    
    if ancount == 0 {
        return DnsResult::NotFound;
    }
    
    // Skip the header
    let mut pos = 12;
    
    // Skip question section
    for _ in 0..qdcount {
        // Skip QNAME
        pos = match skip_name(packet, pos) {
            Ok(p) => p,
            Err(e) => return e,
        };
        // Skip QTYPE and QCLASS (4 bytes)
        pos += 4;
        if pos > packet.len() {
            return DnsResult::Error("Truncated question");
        }
    }
    
    // Parse answer section
    let mut addresses = Vec::new();
    
    for _ in 0..ancount {
        if pos >= packet.len() {
            break;
        }
        
        // Skip NAME (may be a pointer)
        pos = match skip_name(packet, pos) {
            Ok(p) => p,
            Err(e) => return e,
        };
        
        // Need at least 10 bytes for TYPE, CLASS, TTL, RDLENGTH
        if pos + 10 > packet.len() {
            return DnsResult::Error("Truncated answer");
        }
        
        let rtype = u16::from_be_bytes([packet[pos], packet[pos + 1]]);
        let rclass = u16::from_be_bytes([packet[pos + 2], packet[pos + 3]]);
        // TTL is at pos+4..pos+8 (we skip it)
        let rdlength = u16::from_be_bytes([packet[pos + 8], packet[pos + 9]]) as usize;
        pos += 10;
        
        if pos + rdlength > packet.len() {
            return DnsResult::Error("Truncated RDATA");
        }
        
        // Check if this is an A record (type 1, class IN)
        if rtype == DNS_TYPE_A && rclass == DNS_CLASS_IN && rdlength == 4 {
            let addr = Ipv4Address::new(
                packet[pos],
                packet[pos + 1],
                packet[pos + 2],
                packet[pos + 3],
            );
            addresses.push(addr);
        }
        
        pos += rdlength;
    }
    
    if addresses.is_empty() {
        DnsResult::NotFound
    } else {
        DnsResult::Resolved(addresses)
    }
}

/// Skip a DNS name (handles compression pointers)
/// Returns the position after the name, or Error
fn skip_name(packet: &[u8], mut pos: usize) -> Result<usize, DnsResult> {
    loop {
        if pos >= packet.len() {
            return Err(DnsResult::Error("Name extends past packet"));
        }
        
        let len = packet[pos];
        
        if len == 0 {
            // End of name (null terminator)
            return Ok(pos + 1);
        }
        
        if len & 0xC0 == 0xC0 {
            // Compression pointer (2 bytes) - just skip it
            return Ok(pos + 2);
        }
        
        // Regular label: skip length byte + label content
        pos += 1 + (len as usize);
        
        // Safety check
        if pos > packet.len() {
            return Err(DnsResult::Error("Label extends past packet"));
        }
    }
}

/// High-level DNS resolution function
/// 
/// This performs a DNS lookup using the provided NetState.
/// Returns the first resolved IPv4 address or None on failure.
pub fn resolve(
    net: &mut crate::net::NetState,
    hostname: &[u8],
    dns_server: Ipv4Address,
    timeout_ms: i64,
    get_time_ms: fn() -> i64,
) -> Option<Ipv4Address> {
    use crate::uart;
    
    // Build query
    let (txid, query) = build_query(hostname);
    
    // Send query
    let start_time = get_time_ms();
    if net.udp_send(dns_server, crate::net::DNS_PORT, &query, start_time).is_err() {
        uart::write_line("Failed to send DNS query");
        return None;
    }
    
    // Wait for response with timeout
    let mut buf = [0u8; 512];
    
    loop {
        let now = get_time_ms();
        if now - start_time > timeout_ms {
            uart::write_line("DNS query timed out");
            return None;
        }
        
        // Poll network
        net.poll(now);
        
        // Try to receive response
        if let Some((_src_ip, _src_port, len)) = net.udp_recv(&mut buf, now) {
            match parse_response(&buf[..len], txid) {
                DnsResult::Resolved(addrs) => {
                    return addrs.into_iter().next();
                }
                DnsResult::NotFound => {
                    uart::write_line("DNS: domain not found");
                    return None;
                }
                DnsResult::Error(e) => {
                    uart::write_str("DNS error: ");
                    uart::write_line(e);
                    return None;
                }
                DnsResult::WrongId => {
                    // Ignore responses with wrong transaction ID
                    continue;
                }
            }
        }
        
        // Small delay to avoid busy-waiting
        for _ in 0..10000 {
            core::hint::spin_loop();
        }
    }
}
</file>

<file path="kernel/src/uart.rs">
use core::fmt::{self, Write};

const UART_BASE: usize = 0x1000_0000;

pub struct Console;

impl Console {
    pub const fn new() -> Self {
        Self
    }

    #[inline(always)]
    fn data_reg() -> *mut u8 {
        UART_BASE as *mut u8
    }

    pub fn write_byte(&mut self, byte: u8) {
        unsafe {
            core::ptr::write_volatile(Self::data_reg(), byte);
        }
    }

    pub fn read_byte(&self) -> u8 {
        unsafe { core::ptr::read_volatile(Self::data_reg() as *const u8) }
    }
}

impl Write for Console {
    fn write_str(&mut self, s: &str) -> fmt::Result {
        for byte in s.bytes() {
            self.write_byte(byte);
        }
        Ok(())
    }
}

/// Write a raw string to the UART without using `core::fmt`.
pub fn write_str(s: &str) {
    let mut console = Console::new();
    let _ = console.write_str(s);
}

/// Write a raw string followed by `\n`.
pub fn write_line(s: &str) {
    write_str(s);
    write_str("\n");
}

/// Write a raw byte slice to the UART.
pub fn write_bytes(bytes: &[u8]) {
    let mut console = Console::new();
    for &b in bytes {
        console.write_byte(b);
    }
}

/// Write an unsigned integer in decimal.
pub fn write_u64(mut n: u64) {
    let mut console = Console::new();

    if n == 0 {
        console.write_byte(b'0');
        return;
    }

    let mut buf = [0u8; 20]; // enough for u64
    let mut i = 0;

    while n > 0 && i < buf.len() {
        let digit = (n % 10) as u8;
        buf[i] = b'0' + digit;
        n /= 10;
        i += 1;
    }

    while i > 0 {
        i -= 1;
        console.write_byte(buf[i]);
    }
}

/// Write an unsigned integer in hexadecimal.
pub fn write_hex(mut n: u64) {
    let mut console = Console::new();
    let hex_digits = b"0123456789abcdef";

    if n == 0 {
        console.write_byte(b'0');
        return;
    }

    let mut buf = [0u8; 16]; // enough for u64 hex
    let mut i = 0;

    while n > 0 && i < buf.len() {
        buf[i] = hex_digits[(n & 0xf) as usize];
        n >>= 4;
        i += 1;
    }

    while i > 0 {
        i -= 1;
        console.write_byte(buf[i]);
    }
}

/// Write a single byte in hexadecimal (2 characters).
pub fn write_hex_byte(b: u8) {
    let mut console = Console::new();
    let hex_digits = b"0123456789abcdef";
    console.write_byte(hex_digits[(b >> 4) as usize]);
    console.write_byte(hex_digits[(b & 0xf) as usize]);
}

#[macro_export]
macro_rules! print {
    ($($arg:tt)*) => ({
        $crate::uart::print_fmt(core::format_args!($($arg)*));
    });
}

#[macro_export]
macro_rules! println {
    () => ($crate::print!("\n"));
    ($fmt:expr $(, $($arg:tt)*)?) => ({
        $crate::uart::print_fmt(core::format_args!(concat!($fmt, "\n") $(, $($arg)*)?));
    });
}
</file>

<file path="kernel/build.rs">
use std::env;
use std::fs;
use std::path::PathBuf;

fn main() {
    println!("cargo:rerun-if-changed=memory.x");

    let out_dir = PathBuf::from(env::var("OUT_DIR").expect("OUT_DIR not set"));
    let target_script = out_dir.join("memory.x");
    fs::copy("memory.x", &target_script).expect("failed to copy memory.x");
    let link_script = out_dir.join("link.x");
    fs::copy("link.x", &link_script).expect("failed to copy link.x");
    println!("cargo:rustc-link-search={}", out_dir.display());
    println!("cargo:rustc-link-arg=-T{}", target_script.display());
    println!("cargo:rustc-link-arg=-T{}", link_script.display());
    println!("cargo:rerun-if-changed=build.rs");
}
</file>

<file path="kernel/memory.x">
MEMORY
{
    /* 
     * RAM starts at 0x80000000.
     * We allocate 512MB to match the VM's DRAM size.
     */
    RAM : ORIGIN = 0x80000000, LENGTH = 512M
}

REGION_ALIAS("REGION_TEXT", RAM);
REGION_ALIAS("REGION_RODATA", RAM);
REGION_ALIAS("REGION_DATA", RAM);
REGION_ALIAS("REGION_BSS", RAM);
REGION_ALIAS("REGION_HEAP", RAM);
REGION_ALIAS("REGION_STACK", RAM);
</file>

<file path="kernel/project.json">
{
  "name": "kernel",
  "targets": {
    "build": {
      "executor": "nx:run-commands",
      "options": {
        "command": "cargo build --release",
        "cwd": "kernel"
      },
      "outputs": [
        "{workspaceRoot}/target/riscv64gc-unknown-none-elf/release/kernel"
      ]
    },
    "test": {
      "executor": "nx:run-commands",
      "options": {
        "command": "cargo test",
        "cwd": "kernel"
      }
    },
    "lint": {
      "executor": "nx:run-commands",
      "options": {
        "command": "cargo clippy",
        "cwd": "kernel"
      }
    },
    "nx-release-publish": {
      "executor": "nx:run-commands",
      "options": {
        "command": "echo 'Skipping Cargo publish for kernel'",
        "parallel": false
      }
    }
  }
}
</file>

<file path="relay/project.json">
{
  "name": "relay",
  "targets": {
    "build": {
      "executor": "nx:run-commands",
      "options": {
        "command": "cargo build --release",
        "cwd": "relay"
      },
      "outputs": [
        "{workspaceRoot}/target/release/relay"
      ]
    },
    "test": {
      "executor": "nx:run-commands",
      "options": {
        "command": "cargo test",
        "cwd": "relay"
      }
    },
    "lint": {
      "executor": "nx:run-commands",
      "options": {
        "command": "cargo clippy",
        "cwd": "relay"
      }
    },
    "nx-release-publish": {
      "executor": "nx:run-commands",
      "options": {
        "command": "echo 'Skipping Cargo publish for relay'",
        "parallel": false
      }
    }
  }
}
</file>

<file path="relay/README.md">
# WebTransport Relay for RISC-V VM

This is a high-performance relay server built with [WebTransport](https://w3c.github.io/webtransport/) and Rust. It enables browser-based RISC-V VMs to communicate with each other and access the external internet via a User-Space NAT gateway.

## Deployment on Docker / Linux

This relay is designed to run in standard Docker containers **without** requiring `NET_ADMIN` capabilities or privileged mode. It uses a user-space NAT implementation for UDP and ICMP.

### Features

- **WebTransport/QUIC:** Uses modern HTTP/3-based transport for low-latency, secure connections over UDP port 4433.
- **Virtual Switch:** Broadcasts Ethernet frames between all connected clients (VMs), effectively placing them on the same virtual LAN.
- **User-Space NAT Gateway:**
    - **Gateway IP:** `10.0.2.2` (responds to ARP and Ping)
    - **External Access:** Allows VMs to ping external hosts (e.g., `8.8.8.8`) and perform UDP queries (e.g., DNS) by proxying traffic through the container's network stack.
    - **No Privileges Needed:** Uses standard UDP sockets and the `ping` command installed in the container.

## Usage

### Running Locally

1. **Install Rust:** Ensure you have the latest stable Rust toolchain installed.
2. **Run the Server:**

```bash
cd relay
cargo run --release
```

The server will start listening on port `4433` (UDP).

On startup, it will print a **Certificate Hash**. You will need this hash to allow the browser to trust the self-signed certificate.

```text
Certificate Hash (use this in client): e7...3f
Listening on https://0.0.0.0:4433
```

### Running with Docker

Build and run the container. Note that no special capabilities are required.

```bash
docker build -t riscv-relay .
docker run -d -p 4433:4433/udp --name relay riscv-relay
```

To verify it's working, check the logs for the certificate hash:

```bash
docker logs relay
```

## Connecting from the Browser

Modern browsers require a secure context (HTTPS or localhost) to use WebTransport. Since we use a self-signed certificate, you must provide the server's certificate hash to the `WebTransport` constructor.

### JavaScript Example

Here is how to connect your web application to the relay:

```javascript
// The hash printed by the relay server on startup
const RELAY_CERT_HASH = "YOUR_CERTIFICATE_HASH_HERE"; 

// Convert hex string to Uint8Array
const certHashBytes = new Uint8Array(
  RELAY_CERT_HASH.match(/.{1,2}/g).map((byte) => parseInt(byte, 16))
);

async function connectToRelay() {
  const url = "https://127.0.0.1:4433";

  const transport = new WebTransport(url, {
    serverCertificateHashes: [
      {
        algorithm: "sha-256",
        value: certHashBytes,
      },
    ],
  });

  try {
    await transport.ready;
    console.log("Connected to relay!");

    // 1. Reader for incoming packets (Ethernet frames)
    const reader = transport.datagrams.readable.getReader();
    
    // 2. Writer for outgoing packets
    const writer = transport.datagrams.writable.getWriter();

    // Example: Receive loop
    while (true) {
      const { value, done } = await reader.read();
      if (done) break;
      console.log("Received packet:", value); // value is a Uint8Array
    }

  } catch (e) {
    console.error("Connection failed:", e);
  }
}

connectToRelay();
```

### How it Works

1. **Connection:** The browser initiates a WebTransport session over QUIC.
2. **Verification:** The browser verifies the server's self-signed certificate against the provided hash.
3. **Data Exchange:** 
   - The VM encapsulates Ethernet frames into WebTransport datagrams.
   - The Relay receives these datagrams.
4. **Routing:**
   - **Broadcast:** If the packet is internal (e.g., ARP, or destined for another VM), the relay broadcasts it to all other connected clients.
   - **NAT:** If the packet is destined for the internet (e.g., Google DNS `8.8.8.8`), the relay performs NAT, sends it out via the host's UDP socket, and forwards the response back to the specific client.

## Configuration

You can configure the bind address and port via command-line arguments:

```bash
cargo run --release -- --bind 0.0.0.0 --port 4433
```

## Development

To check for compilation errors:

```bash
cargo check
```

To build a release binary:

```bash
cargo build --release
```
</file>

<file path="riscv-vm/src/csr.rs">
use serde::{Deserialize, Serialize};

#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]
pub enum Mode {
    User,
    Supervisor,
    Machine,
}

impl Mode {
    /// Encode privilege mode into the MPP/SPP field encoding.
    pub fn to_mpp(self) -> u64 {
        match self {
            Mode::User => 0b00,
            Mode::Supervisor => 0b01,
            Mode::Machine => 0b11,
        }
    }

    /// Decode MPP/SPP field into a privilege mode.
    pub fn from_mpp(bits: u64) -> Mode {
        match bits & 0b11 {
            0b00 => Mode::User,
            0b01 => Mode::Supervisor,
            // 0b10 is reserved; treat as Machine for WARL coercion.
            _ => Mode::Machine,
        }
    }
}

// Common CSR addresses used by the privileged architecture.
pub const CSR_SATP: u16 = 0x180;

pub const CSR_MSTATUS: u16 = 0x300;
pub const CSR_MISA: u16 = 0x301;
pub const CSR_MEDELEG: u16 = 0x302;
pub const CSR_MIDELEG: u16 = 0x303;
pub const CSR_MIE: u16 = 0x304;
pub const CSR_MTVEC: u16 = 0x305;

pub const CSR_MEPC: u16 = 0x341;
pub const CSR_MCAUSE: u16 = 0x342;
pub const CSR_MTVAL: u16 = 0x343;
pub const CSR_MIP: u16 = 0x344;

// Supervisor CSRs
pub const CSR_SSTATUS: u16 = 0x100;
pub const CSR_SIE: u16 = 0x104;
pub const CSR_STVEC: u16 = 0x105;
pub const CSR_SSCRATCH: u16 = 0x140;
pub const CSR_SEPC: u16 = 0x141;
pub const CSR_SCAUSE: u16 = 0x142;
pub const CSR_STVAL: u16 = 0x143;
pub const CSR_SIP: u16 = 0x144;

// Additional CSRs used by xv6 and Sstc
pub const CSR_TIME: u16 = 0xC01;      // time (read-only)
pub const CSR_MENVCFG: u16 = 0x30A;   // menvcfg (for Sstc enable bit 63)
pub const CSR_STIMECMP: u16 = 0x14D;  // stimecmp (Sstc)
pub const CSR_MCOUNTEREN: u16 = 0x306;

// Machine Information Registers (read-only)
pub const CSR_MVENDORID: u16 = 0xF11;  // Vendor ID
pub const CSR_MARCHID: u16 = 0xF12;    // Architecture ID
pub const CSR_MIMPID: u16 = 0xF13;     // Implementation ID
pub const CSR_MHARTID: u16 = 0xF14;    // Hardware thread ID
</file>

<file path="riscv-vm/tsup/tsup.cli.ts">
import createConfig from './';

export default createConfig({
  format: ['cjs'],
  entry: ['cli.ts'],
  external: ['yargs'],
  platform: 'node',
});
</file>

<file path="riscv-vm/.yarnrc.yml">
nodeLinker: node-modules
</file>

<file path="kernel/src/klog.rs">
//! Kernel logging infrastructure
//!
//! Provides a ring buffer for kernel messages that can be:
//! - Written to by any subsystem via klog!() macro
//! - Flushed to /var/log/kernel.log by the klogd daemon
//! - Viewed via dmesg command

use alloc::collections::VecDeque;
use alloc::string::String;
use alloc::format;
use alloc::vec::Vec;
use core::sync::atomic::{AtomicBool, AtomicUsize, Ordering};

use crate::Spinlock;

/// Maximum messages in the ring buffer
const LOG_BUFFER_SIZE: usize = 128;

/// Maximum length of a single log message
const MAX_MESSAGE_LEN: usize = 256;

/// Log levels (similar to Linux kernel log levels)
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord)]
#[repr(u8)]
pub enum LogLevel {
    /// System is unusable
    Emergency = 0,
    /// Action must be taken immediately
    Alert = 1,
    /// Critical conditions
    Critical = 2,
    /// Error conditions
    Error = 3,
    /// Warning conditions
    Warning = 4,
    /// Normal but significant condition
    Notice = 5,
    /// Informational
    Info = 6,
    /// Debug-level messages
    Debug = 7,
    /// Trace-level messages (very verbose)
    Trace = 8,
}

impl LogLevel {
    pub fn as_str(&self) -> &'static str {
        match self {
            LogLevel::Emergency => "EMERG",
            LogLevel::Alert => "ALERT",
            LogLevel::Critical => "CRIT",
            LogLevel::Error => "ERROR",
            LogLevel::Warning => "WARN",
            LogLevel::Notice => "NOTICE",
            LogLevel::Info => "INFO",
            LogLevel::Debug => "DEBUG",
            LogLevel::Trace => "TRACE",
        }
    }
    
    pub fn color(&self) -> &'static str {
        match self {
            LogLevel::Emergency | LogLevel::Alert | LogLevel::Critical => "\x1b[1;31m",
            LogLevel::Error => "\x1b[31m",
            LogLevel::Warning => "\x1b[33m",
            LogLevel::Notice => "\x1b[36m",
            LogLevel::Info => "\x1b[0m",
            LogLevel::Debug => "\x1b[90m",
            LogLevel::Trace => "\x1b[90m",
        }
    }
}

/// A single log entry
#[derive(Clone)]
pub struct LogEntry {
    /// Timestamp (ms since boot)
    pub timestamp: u64,
    /// Log level
    pub level: LogLevel,
    /// Subsystem name (e.g., "sched", "fs", "net")
    pub subsystem: String,
    /// The log message
    pub message: String,
    /// Hart that logged this
    pub hart_id: usize,
}

impl LogEntry {
    /// Format as a string for display
    pub fn format(&self) -> String {
        format!(
            "[{:>10}.{:03}] {} [{}] {}: {}",
            self.timestamp / 1000,
            self.timestamp % 1000,
            self.level.as_str(),
            self.hart_id,
            self.subsystem,
            self.message
        )
    }
    
    /// Format with colors for terminal
    pub fn format_colored(&self) -> String {
        format!(
            "\x1b[90m[{:>10}.{:03}]\x1b[0m {}{}\x1b[0m \x1b[36m[{}]\x1b[0m \x1b[33m{}:\x1b[0m {}",
            self.timestamp / 1000,
            self.timestamp % 1000,
            self.level.color(),
            self.level.as_str(),
            self.hart_id,
            self.subsystem,
            self.message
        )
    }
}

/// Ring buffer for kernel log messages
pub struct LogBuffer {
    /// Log entries
    entries: Spinlock<VecDeque<LogEntry>>,
    /// Sequence number for ordering
    sequence: AtomicUsize,
    /// Current log level filter (messages below this are suppressed)
    level_filter: AtomicUsize,
    /// Whether to also print to console
    console_enabled: AtomicBool,
    /// Whether logging is enabled
    enabled: AtomicBool,
}

impl LogBuffer {
    pub const fn new() -> Self {
        Self {
            entries: Spinlock::new(VecDeque::new()),
            sequence: AtomicUsize::new(0),
            level_filter: AtomicUsize::new(LogLevel::Info as usize),
            console_enabled: AtomicBool::new(true),
            enabled: AtomicBool::new(true),
        }
    }
    
    /// Create a new log buffer with console output disabled
    /// Useful during boot to avoid UART contention
    pub const fn new_console_disabled() -> Self {
        Self {
            entries: Spinlock::new(VecDeque::new()),
            sequence: AtomicUsize::new(0),
            level_filter: AtomicUsize::new(LogLevel::Debug as usize),
            console_enabled: AtomicBool::new(false),
            enabled: AtomicBool::new(true),
        }
    }
    
    /// Log a message
    pub fn log(&self, level: LogLevel, subsystem: &str, message: &str) {
        if !self.enabled.load(Ordering::Relaxed) {
            return;
        }
        
        // Check level filter
        if (level as usize) > self.level_filter.load(Ordering::Relaxed) {
            return;
        }
        
        let timestamp = crate::get_time_ms() as u64;
        let hart_id = crate::get_hart_id();
        
        // Truncate message if too long
        let message = if message.len() > MAX_MESSAGE_LEN {
            let mut s = String::from(&message[..MAX_MESSAGE_LEN - 3]);
            s.push_str("...");
            s
        } else {
            String::from(message)
        };
        
        let entry = LogEntry {
            timestamp,
            level,
            subsystem: String::from(subsystem),
            message,
            hart_id,
        };
        
        // Print to console if enabled
        if self.console_enabled.load(Ordering::Relaxed) && level <= LogLevel::Info {
            crate::uart::write_line(&entry.format_colored());
        }
        
        // Add to buffer
        let mut buffer = self.entries.lock();
        if buffer.len() >= LOG_BUFFER_SIZE {
            buffer.pop_front(); // Drop oldest
        }
        buffer.push_back(entry);
        
        self.sequence.fetch_add(1, Ordering::Relaxed);
    }
    
    /// Drain all entries for writing to log file
    pub fn drain(&self) -> Vec<LogEntry> {
        let mut buffer = self.entries.lock();
        buffer.drain(..).collect()
    }
    
    /// Get recent entries without removing them
    pub fn recent(&self, count: usize) -> Vec<LogEntry> {
        let buffer = self.entries.lock();
        buffer.iter().rev().take(count).cloned().collect()
    }
    
    /// Get all entries without removing them
    pub fn all(&self) -> Vec<LogEntry> {
        self.entries.lock().iter().cloned().collect()
    }
    
    /// Set the log level filter
    pub fn set_level(&self, level: LogLevel) {
        self.level_filter.store(level as usize, Ordering::Release);
    }
    
    /// Enable/disable console output
    pub fn set_console(&self, enabled: bool) {
        self.console_enabled.store(enabled, Ordering::Release);
    }
    
    /// Get current entry count
    pub fn len(&self) -> usize {
        self.entries.lock().len()
    }
    
    /// Check if buffer is empty
    pub fn is_empty(&self) -> bool {
        self.entries.lock().is_empty()
    }
    
    /// Get sequence number (total messages logged)
    pub fn sequence(&self) -> usize {
        self.sequence.load(Ordering::Relaxed)
    }
}

/// Global kernel log buffer
/// Note: Console output is disabled by default to avoid UART contention during boot
pub static KLOG: LogBuffer = LogBuffer::new_console_disabled();

// ═══════════════════════════════════════════════════════════════════════════════
// PUBLIC LOGGING FUNCTIONS
// ═══════════════════════════════════════════════════════════════════════════════

/// Log an emergency message
pub fn klog_emergency(subsystem: &str, message: &str) {
    KLOG.log(LogLevel::Emergency, subsystem, message);
}

/// Log an alert message
pub fn klog_alert(subsystem: &str, message: &str) {
    KLOG.log(LogLevel::Alert, subsystem, message);
}

/// Log a critical message
pub fn klog_critical(subsystem: &str, message: &str) {
    KLOG.log(LogLevel::Critical, subsystem, message);
}

/// Log an error message
pub fn klog_error(subsystem: &str, message: &str) {
    KLOG.log(LogLevel::Error, subsystem, message);
}

/// Log a warning message
pub fn klog_warning(subsystem: &str, message: &str) {
    KLOG.log(LogLevel::Warning, subsystem, message);
}

/// Log a notice message
pub fn klog_notice(subsystem: &str, message: &str) {
    KLOG.log(LogLevel::Notice, subsystem, message);
}

/// Log an info message
pub fn klog_info(subsystem: &str, message: &str) {
    KLOG.log(LogLevel::Info, subsystem, message);
}

/// Log a debug message
pub fn klog_debug(subsystem: &str, message: &str) {
    KLOG.log(LogLevel::Debug, subsystem, message);
}

/// Log a trace message
pub fn klog_trace(subsystem: &str, message: &str) {
    KLOG.log(LogLevel::Trace, subsystem, message);
}

/// Set the minimum log level to display
pub fn set_log_level(level: LogLevel) {
    KLOG.set_level(level);
}

/// Enable or disable console output
pub fn set_console_output(enabled: bool) {
    KLOG.set_console(enabled);
}
</file>

<file path="kernel/src/task.rs">
//! Task/Process abstraction for the kernel
//!
//! Provides Linux-like task management with:
//! - Task Control Block (TCB) similar to Linux's task_struct
//! - Task states (Ready, Running, Sleeping, Zombie)
//! - Priority levels for scheduling
//! - CPU time tracking

use alloc::string::String;
use core::sync::atomic::{AtomicU64, AtomicUsize, Ordering};

/// Process identifier type
pub type Pid = u32;

/// Task states (similar to Linux process states)
#[derive(Clone, Copy, PartialEq, Eq, Debug)]
#[repr(u8)]
pub enum TaskState {
    /// Task is runnable, waiting for CPU
    Ready = 0,
    /// Task is currently executing on a hart
    Running = 1,
    /// Task is blocked (sleeping, waiting for I/O)
    Sleeping = 2,
    /// Task has been stopped (can be resumed)
    Stopped = 3,
    /// Task has finished, awaiting cleanup
    Zombie = 4,
}

impl TaskState {
    pub fn from_usize(val: usize) -> Self {
        match val {
            0 => TaskState::Ready,
            1 => TaskState::Running,
            2 => TaskState::Sleeping,
            3 => TaskState::Stopped,
            _ => TaskState::Zombie,
        }
    }
    
    pub fn as_str(&self) -> &'static str {
        match self {
            TaskState::Ready => "R",
            TaskState::Running => "R+",
            TaskState::Sleeping => "S",
            TaskState::Stopped => "T",
            TaskState::Zombie => "Z",
        }
    }
}

/// Task priority levels for scheduling
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Debug)]
#[repr(u8)]
pub enum Priority {
    /// Lowest priority - runs when nothing else to do
    Idle = 0,
    /// Background tasks
    Low = 1,
    /// Default priority for user tasks
    Normal = 2,
    /// System services
    High = 3,
    /// Critical system tasks
    Realtime = 4,
}

impl Priority {
    pub fn as_str(&self) -> &'static str {
        match self {
            Priority::Idle => "idle",
            Priority::Low => "low",
            Priority::Normal => "normal",
            Priority::High => "high",
            Priority::Realtime => "rt",
        }
    }
}

/// Task entry point function type
/// The function receives a reference to its own task and any user data
pub type TaskEntry = fn();

/// Task Control Block - represents a schedulable unit of execution
pub struct Task {
    /// Unique process identifier
    pub pid: Pid,
    /// Human-readable task name
    pub name: String,
    /// Current task state (atomic for cross-hart visibility)
    state: AtomicUsize,
    /// Task priority
    pub priority: Priority,
    /// Hart affinity (None = can run on any hart)
    pub hart_affinity: Option<usize>,
    /// Hart currently running this task (if Running)
    pub current_hart: AtomicUsize,
    /// Task entry point
    pub entry: TaskEntry,
    /// Creation timestamp (ms since boot)
    pub created_at: u64,
    /// Total CPU time consumed (ms)
    pub cpu_time: AtomicU64,
    /// Exit code (valid when Zombie)
    pub exit_code: AtomicUsize,
    /// Whether this is a daemon (long-running service)
    pub is_daemon: bool,
    /// Whether task should restart on exit
    pub restart_on_exit: bool,
}

impl Task {
    /// Create a new task
    pub fn new(pid: Pid, name: &str, entry: TaskEntry, priority: Priority) -> Self {
        Self {
            pid,
            name: String::from(name),
            state: AtomicUsize::new(TaskState::Ready as usize),
            priority,
            hart_affinity: None,
            current_hart: AtomicUsize::new(usize::MAX),
            entry,
            created_at: crate::get_time_ms() as u64,
            cpu_time: AtomicU64::new(0),
            exit_code: AtomicUsize::new(0),
            is_daemon: false,
            restart_on_exit: false,
        }
    }
    
    /// Create a daemon task (long-running service)
    pub fn new_daemon(pid: Pid, name: &str, entry: TaskEntry, priority: Priority) -> Self {
        let mut task = Self::new(pid, name, entry, priority);
        task.is_daemon = true;
        task.restart_on_exit = true;
        task
    }
    
    /// Get current task state
    pub fn get_state(&self) -> TaskState {
        TaskState::from_usize(self.state.load(Ordering::Acquire))
    }
    
    /// Set task state
    pub fn set_state(&self, state: TaskState) {
        self.state.store(state as usize, Ordering::Release);
    }
    
    /// Check if task is runnable
    pub fn is_runnable(&self) -> bool {
        matches!(self.get_state(), TaskState::Ready)
    }
    
    /// Mark task as running on specified hart
    pub fn mark_running(&self, hart_id: usize) {
        self.current_hart.store(hart_id, Ordering::Release);
        self.set_state(TaskState::Running);
    }
    
    /// Mark task as finished with exit code
    pub fn mark_finished(&self, exit_code: usize) {
        self.exit_code.store(exit_code, Ordering::Release);
        self.current_hart.store(usize::MAX, Ordering::Release);
        self.set_state(TaskState::Zombie);
    }
    
    /// Add CPU time
    pub fn add_cpu_time(&self, ms: u64) {
        self.cpu_time.fetch_add(ms, Ordering::Relaxed);
    }
    
    /// Get total CPU time consumed
    pub fn get_cpu_time(&self) -> u64 {
        self.cpu_time.load(Ordering::Relaxed)
    }
    
    /// Get current hart (if running)
    pub fn get_current_hart(&self) -> Option<usize> {
        let hart = self.current_hart.load(Ordering::Acquire);
        if hart == usize::MAX {
            None
        } else {
            Some(hart)
        }
    }
}

/// Task information for reporting (does not hold references)
#[derive(Clone)]
pub struct TaskInfo {
    pub pid: Pid,
    pub name: String,
    pub state: TaskState,
    pub priority: Priority,
    pub hart: Option<usize>,
    pub cpu_time: u64,
    pub uptime: u64,
}

impl Task {
    /// Get a snapshot of task info for reporting
    pub fn info(&self, current_time: u64) -> TaskInfo {
        TaskInfo {
            pid: self.pid,
            name: self.name.clone(),
            state: self.get_state(),
            priority: self.priority,
            hart: self.get_current_hart(),
            cpu_time: self.get_cpu_time(),
            uptime: current_time.saturating_sub(self.created_at),
        }
    }
}
</file>

<file path="kernel/src/tls12.rs">
//! TLS 1.2 client implementation for HTTPS connections.
//!
//! This module provides TLS 1.2 support using:
//! - ECDHE_RSA_WITH_AES_128_GCM_SHA256 cipher suite
//! - X25519 or P-256 for key exchange
//! - AES-128-GCM for encryption
//! - SHA-256 for PRF and MAC
//!
//! Certificate verification is disabled (NoVerify mode) for simplicity.

use alloc::vec::Vec;
use alloc::vec;
use aes_gcm::{Aes128Gcm, KeyInit, Nonce, aead::AeadInPlace};
use sha2::{Sha256, Digest};
use hmac::{Hmac, Mac};
use embedded_io::{Read, Write};
use rand_core::RngCore;

// P-256 (secp256r1) support
use p256::ecdh::EphemeralSecret as P256Secret;
use p256::PublicKey as P256PublicKey;
use p256::EncodedPoint;
use p256::elliptic_curve::sec1::FromEncodedPoint;

use crate::tls::{SimpleRng, TlsError, BlockingTcpSocket};

// ═══════════════════════════════════════════════════════════════════════════════
// CONSTANTS
// ═══════════════════════════════════════════════════════════════════════════════

/// TLS 1.2 version bytes
const TLS_VERSION_1_2: [u8; 2] = [0x03, 0x03];

/// TLS record types
const CONTENT_TYPE_CHANGE_CIPHER_SPEC: u8 = 20;
const CONTENT_TYPE_ALERT: u8 = 21;
const CONTENT_TYPE_HANDSHAKE: u8 = 22;
const CONTENT_TYPE_APPLICATION_DATA: u8 = 23;

/// Handshake message types
const HANDSHAKE_CLIENT_HELLO: u8 = 1;
const HANDSHAKE_SERVER_HELLO: u8 = 2;
const HANDSHAKE_CERTIFICATE: u8 = 11;
const HANDSHAKE_SERVER_KEY_EXCHANGE: u8 = 12;
const HANDSHAKE_SERVER_HELLO_DONE: u8 = 14;
const HANDSHAKE_CLIENT_KEY_EXCHANGE: u8 = 16;
const HANDSHAKE_FINISHED: u8 = 20;

/// Cipher suite: TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256
const CIPHER_SUITE_ECDHE_RSA_AES128_GCM_SHA256: [u8; 2] = [0xc0, 0x2f];

/// Extension types
const EXT_SERVER_NAME: u16 = 0;
const EXT_EC_POINT_FORMATS: u16 = 11;
const EXT_SUPPORTED_GROUPS: u16 = 10;
const EXT_SIGNATURE_ALGORITHMS: u16 = 13;

/// Named curves
const NAMED_CURVE_SECP256R1: u16 = 23;
const NAMED_CURVE_X25519: u16 = 29;

/// GCM nonce size
const GCM_NONCE_SIZE: usize = 12;
/// GCM tag size
const GCM_TAG_SIZE: usize = 16;
/// GCM explicit nonce size (the part sent with each record)
const GCM_EXPLICIT_NONCE_SIZE: usize = 8;

// ═══════════════════════════════════════════════════════════════════════════════
// TLS 1.2 CONNECTION STATE
// ═══════════════════════════════════════════════════════════════════════════════

/// TLS 1.2 connection state
pub struct Tls12Connection<'a> {
    socket: BlockingTcpSocket<'a>,
    /// Selected curve
    curve: u16,
    /// Our ECDHE private key (X25519)
    x25519_secret: Option<x25519_dalek::EphemeralSecret>,
    /// Our ECDHE private key (P-256)
    p256_secret: Option<P256Secret>,
    /// Our ECDHE public key (format depends on selected curve)
    client_pubkey_x25519: Vec<u8>,
    /// Our ECDHE public key for P-256 (uncompressed format: 0x04 + X + Y)
    client_pubkey_p256: Vec<u8>,
    /// Server's ECDHE public key
    server_pubkey: Option<Vec<u8>>,
    /// Server random (32 bytes)
    server_random: [u8; 32],
    /// Client random (32 bytes)
    client_random: [u8; 32],
    /// Master secret (48 bytes)
    master_secret: [u8; 48],
    /// Client write key
    client_write_key: [u8; 16],
    /// Server write key
    server_write_key: [u8; 16],
    /// Client write IV (implicit nonce)
    client_write_iv: [u8; 4],
    /// Server write IV (implicit nonce)
    server_write_iv: [u8; 4],
    /// Client sequence number for GCM nonce
    client_seq: u64,
    /// Server sequence number for GCM nonce
    server_seq: u64,
    /// Handshake messages for Finished verification
    handshake_hash: Sha256,
    /// Whether encryption is active
    encrypted: bool,
    /// RNG for generating random values
    rng: SimpleRng,
}

impl<'a> Tls12Connection<'a> {
    /// Create a new TLS 1.2 connection
    pub fn new(socket: BlockingTcpSocket<'a>) -> Self {
        let mut rng = SimpleRng::new();
        
        // Generate client random
        let mut client_random = [0u8; 32];
        rng.fill_bytes(&mut client_random);
        
        Self {
            socket,
            curve: 0,
            x25519_secret: None,
            p256_secret: None,
            client_pubkey_x25519: Vec::new(),
            client_pubkey_p256: Vec::new(),
            server_pubkey: None,
            server_random: [0u8; 32],
            client_random,
            master_secret: [0u8; 48],
            client_write_key: [0u8; 16],
            server_write_key: [0u8; 16],
            client_write_iv: [0u8; 4],
            server_write_iv: [0u8; 4],
            client_seq: 0,
            server_seq: 0,
            handshake_hash: Sha256::new(),
            encrypted: false,
            rng,
        }
    }
    
    /// Perform TLS 1.2 handshake
    pub fn handshake(&mut self, hostname: &str) -> Result<(), TlsError> {
        crate::uart::write_line("TLS 1.2: Starting handshake");
        
        // Generate X25519 keypair
        let x25519_secret = x25519_dalek::EphemeralSecret::random_from_rng(&mut self.rng);
        let x25519_public = x25519_dalek::PublicKey::from(&x25519_secret);
        self.x25519_secret = Some(x25519_secret);
        self.client_pubkey_x25519 = x25519_public.as_bytes().to_vec();
        
        // Generate P-256 keypair
        let p256_secret = P256Secret::random(&mut self.rng);
        let p256_public = p256_secret.public_key();
        // Encode as uncompressed point: 0x04 + X (32 bytes) + Y (32 bytes) = 65 bytes
        let encoded = EncodedPoint::from(&p256_public);
        self.client_pubkey_p256 = encoded.as_bytes().to_vec();
        self.p256_secret = Some(p256_secret);
        
        // Step 1: Send ClientHello
        self.send_client_hello(hostname)?;
        
        // Step 2: Receive ServerHello
        self.recv_server_hello()?;
        
        // Step 3: Receive Certificate
        self.recv_certificate()?;
        
        // Step 4: Receive ServerKeyExchange
        self.recv_server_key_exchange()?;
        
        // Step 5: Receive ServerHelloDone
        self.recv_server_hello_done()?;
        
        // Step 6: Send ClientKeyExchange (uses client_pubkey)
        self.send_client_key_exchange()?;
        
        // Step 7: Compute master secret and keys (consumes secret)
        self.compute_keys()?;
        
        // Step 8: Send ChangeCipherSpec
        self.send_change_cipher_spec()?;
        
        // Enable encryption for client->server
        self.encrypted = true;
        
        // Step 9: Send Finished
        self.send_finished()?;
        
        // Step 10: Receive ChangeCipherSpec
        self.recv_change_cipher_spec()?;
        
        // Step 11: Receive Finished
        self.recv_finished()?;
        
        crate::uart::write_line("TLS 1.2: Handshake complete");
        Ok(())
    }
    
    /// Send ClientHello
    fn send_client_hello(&mut self, hostname: &str) -> Result<(), TlsError> {
        let mut hello = Vec::with_capacity(512);
        
        // Client version (TLS 1.2)
        hello.extend_from_slice(&TLS_VERSION_1_2);
        
        // Client random
        hello.extend_from_slice(&self.client_random);
        
        // Session ID (empty)
        hello.push(0);
        
        // Cipher suites
        hello.push(0); // Length high byte
        hello.push(2); // Length low byte (1 cipher suite = 2 bytes)
        hello.extend_from_slice(&CIPHER_SUITE_ECDHE_RSA_AES128_GCM_SHA256);
        
        // Compression methods (null only)
        hello.push(1); // Length
        hello.push(0); // null compression
        
        // Extensions
        let mut extensions = Vec::new();
        
        // Server Name Indication (SNI)
        if !hostname.is_empty() {
            let mut sni = Vec::new();
            // SNI list length
            let sni_list_len = (hostname.len() + 3) as u16;
            sni.extend_from_slice(&sni_list_len.to_be_bytes());
            // Host name type (0)
            sni.push(0);
            // Host name length
            sni.extend_from_slice(&(hostname.len() as u16).to_be_bytes());
            // Host name
            sni.extend_from_slice(hostname.as_bytes());
            
            extensions.extend_from_slice(&EXT_SERVER_NAME.to_be_bytes());
            extensions.extend_from_slice(&(sni.len() as u16).to_be_bytes());
            extensions.extend_from_slice(&sni);
        }
        
        // Supported Groups (curves) - advertise both P-256 and X25519
        // P-256 first for better server compatibility (many servers only support P-256)
        extensions.extend_from_slice(&EXT_SUPPORTED_GROUPS.to_be_bytes());
        extensions.extend_from_slice(&6u16.to_be_bytes()); // Extension length (2 + 2 + 2)
        extensions.extend_from_slice(&4u16.to_be_bytes()); // List length (2 curves * 2 bytes)
        extensions.extend_from_slice(&NAMED_CURVE_SECP256R1.to_be_bytes()); // P-256 first
        extensions.extend_from_slice(&NAMED_CURVE_X25519.to_be_bytes());    // X25519 second
        
        // EC Point Formats
        extensions.extend_from_slice(&EXT_EC_POINT_FORMATS.to_be_bytes());
        extensions.extend_from_slice(&2u16.to_be_bytes()); // Extension length
        extensions.push(1); // List length
        extensions.push(0); // Uncompressed point format
        
        // Signature Algorithms
        extensions.extend_from_slice(&EXT_SIGNATURE_ALGORITHMS.to_be_bytes());
        extensions.extend_from_slice(&4u16.to_be_bytes()); // Extension length
        extensions.extend_from_slice(&2u16.to_be_bytes()); // List length
        extensions.push(0x04); // SHA256
        extensions.push(0x01); // RSA
        
        // Add extensions length
        hello.extend_from_slice(&(extensions.len() as u16).to_be_bytes());
        hello.extend_from_slice(&extensions);
        
        // Build handshake message
        let handshake = self.build_handshake_message(HANDSHAKE_CLIENT_HELLO, &hello);
        
        // Update handshake hash
        self.handshake_hash.update(&handshake);
        
        // Send as TLS record
        self.send_record(CONTENT_TYPE_HANDSHAKE, &handshake)?;
        
        crate::uart::write_line("TLS 1.2: Sent ClientHello");
        Ok(())
    }
    
    /// Receive and parse ServerHello
    fn recv_server_hello(&mut self) -> Result<(), TlsError> {
        let record = self.recv_record()?;
        
        if record.content_type != CONTENT_TYPE_HANDSHAKE {
            crate::uart::write_line("TLS 1.2: Expected handshake, got something else");
            return Err(TlsError::TlsProtocolError);
        }
        
        // Update handshake hash
        self.handshake_hash.update(&record.data);
        
        // Parse handshake header
        if record.data.len() < 4 {
            crate::uart::write_line("TLS 1.2: Record too short for handshake header");
            return Err(TlsError::InvalidData);
        }
        
        let msg_type = record.data[0];
        if msg_type != HANDSHAKE_SERVER_HELLO {
            crate::uart::write_str("TLS 1.2: Expected ServerHello (2), got ");
            let mut buf = [0u8; 10];
            let n = crate::tls::format_u16(msg_type as u16, &mut buf);
            crate::uart::write_line(core::str::from_utf8(&buf[..n]).unwrap_or("?"));
            return Err(TlsError::TlsProtocolError);
        }
        
        let msg_len = u32::from_be_bytes([0, record.data[1], record.data[2], record.data[3]]) as usize;
        if record.data.len() < 4 + msg_len {
            crate::uart::write_line("TLS 1.2: Record too short for message");
            return Err(TlsError::InvalidData);
        }
        
        let msg = &record.data[4..4 + msg_len];
        
        // Parse ServerHello
        if msg.len() < 35 {
            crate::uart::write_line("TLS 1.2: ServerHello too short");
            return Err(TlsError::InvalidData);
        }
        
        let mut pos = 2;
        
        // Server random
        self.server_random.copy_from_slice(&msg[pos..pos + 32]);
        pos += 32;
        
        // Session ID
        let session_id_len = msg[pos] as usize;
        pos += 1 + session_id_len;
        
        // Cipher suite
        if pos + 2 > msg.len() {
            crate::uart::write_line("TLS 1.2: No cipher suite in ServerHello");
            return Err(TlsError::InvalidData);
        }
        let cipher = [msg[pos], msg[pos + 1]];
        
        if cipher != CIPHER_SUITE_ECDHE_RSA_AES128_GCM_SHA256 {
            crate::uart::write_line("TLS 1.2: Server selected unsupported cipher suite");
            return Err(TlsError::TlsProtocolError);
        }
        
        crate::uart::write_line("TLS 1.2: Received ServerHello");
        Ok(())
    }
    
    /// Receive Certificate (we don't validate it)
    fn recv_certificate(&mut self) -> Result<(), TlsError> {
        let record = self.recv_record()?;
        
        if record.content_type != CONTENT_TYPE_HANDSHAKE {
            return Err(TlsError::TlsProtocolError);
        }
        
        self.handshake_hash.update(&record.data);
        
        if record.data.is_empty() || record.data[0] != HANDSHAKE_CERTIFICATE {
            return Err(TlsError::TlsProtocolError);
        }
        
        crate::uart::write_line("TLS 1.2: Received Certificate (not validated)");
        Ok(())
    }
    
    /// Receive ServerKeyExchange (ECDHE parameters)
    fn recv_server_key_exchange(&mut self) -> Result<(), TlsError> {
        let record = self.recv_record()?;
        
        if record.content_type != CONTENT_TYPE_HANDSHAKE {
            crate::uart::write_line("TLS 1.2: Expected handshake for ServerKeyExchange");
            return Err(TlsError::TlsProtocolError);
        }
        
        self.handshake_hash.update(&record.data);
        
        if record.data.is_empty() {
            crate::uart::write_line("TLS 1.2: Empty ServerKeyExchange");
            return Err(TlsError::TlsProtocolError);
        }
        
        let msg_type = record.data[0];
        if msg_type != HANDSHAKE_SERVER_KEY_EXCHANGE {
            crate::uart::write_str("TLS 1.2: Expected ServerKeyExchange (12), got ");
            let mut buf = [0u8; 10];
            let n = crate::tls::format_u16(msg_type as u16, &mut buf);
            crate::uart::write_line(core::str::from_utf8(&buf[..n]).unwrap_or("?"));
            return Err(TlsError::TlsProtocolError);
        }
        
        // Parse ECDHE parameters
        // Format: curve_type (1) + named_curve (2) + pubkey_len (1) + pubkey (n) + signature
        let msg_len = u32::from_be_bytes([0, record.data[1], record.data[2], record.data[3]]) as usize;
        
        if record.data.len() < 4 + msg_len {
            crate::uart::write_line("TLS 1.2: ServerKeyExchange truncated");
            return Err(TlsError::InvalidData);
        }
        
        let msg = &record.data[4..4 + msg_len];
        
        if msg.len() < 5 {
            crate::uart::write_line("TLS 1.2: ServerKeyExchange too short");
            return Err(TlsError::InvalidData);
        }
        
        // curve_type should be 3 (named_curve)
        if msg[0] != 3 {
            crate::uart::write_str("TLS 1.2: Unsupported curve type ");
            let mut buf = [0u8; 10];
            let n = crate::tls::format_u16(msg[0] as u16, &mut buf);
            crate::uart::write_line(core::str::from_utf8(&buf[..n]).unwrap_or("?"));
            return Err(TlsError::TlsProtocolError);
        }
        
        // named_curve
        let curve = u16::from_be_bytes([msg[1], msg[2]]);
        self.curve = curve;
        
        // Accept both P-256 (secp256r1) and X25519
        if curve != NAMED_CURVE_X25519 && curve != NAMED_CURVE_SECP256R1 {
            crate::uart::write_str("TLS 1.2: Unsupported curve: ");
            let mut buf = [0u8; 10];
            let n = crate::tls::format_u16(curve, &mut buf);
            crate::uart::write_line(core::str::from_utf8(&buf[..n]).unwrap_or("?"));
            return Err(TlsError::TlsProtocolError);
        }
        
        // Log which curve server selected
        crate::uart::write_str("TLS 1.2: Server selected curve ");
        if curve == NAMED_CURVE_X25519 {
            crate::uart::write_line("X25519");
        } else {
            crate::uart::write_line("P-256 (secp256r1)");
        }
        
        // Public key
        let pubkey_len = msg[3] as usize;
        crate::uart::write_str("TLS 1.2: Server ECDHE pubkey len=");
        let mut buf = [0u8; 10];
        let n = crate::tls::format_u16(pubkey_len as u16, &mut buf);
        crate::uart::write_line(core::str::from_utf8(&buf[..n]).unwrap_or("?"));
        
        if msg.len() < 4 + pubkey_len {
            crate::uart::write_line("TLS 1.2: ServerKeyExchange pubkey truncated");
            return Err(TlsError::InvalidData);
        }
        
        self.server_pubkey = Some(msg[4..4 + pubkey_len].to_vec());
        
        crate::uart::write_line("TLS 1.2: Received ServerKeyExchange");
        Ok(())
    }
    
    /// Receive ServerHelloDone
    fn recv_server_hello_done(&mut self) -> Result<(), TlsError> {
        let record = self.recv_record()?;
        
        if record.content_type != CONTENT_TYPE_HANDSHAKE {
            return Err(TlsError::TlsProtocolError);
        }
        
        self.handshake_hash.update(&record.data);
        
        if record.data.is_empty() || record.data[0] != HANDSHAKE_SERVER_HELLO_DONE {
            return Err(TlsError::TlsProtocolError);
        }
        
        crate::uart::write_line("TLS 1.2: Received ServerHelloDone");
        Ok(())
    }
    
    /// Compute master secret and derive keys
    fn compute_keys(&mut self) -> Result<(), TlsError> {
        // Perform ECDH to get pre-master secret
        let server_pubkey_bytes = self.server_pubkey.as_ref().ok_or_else(|| {
            crate::uart::write_line("TLS 1.2: No server public key");
            TlsError::InvalidData
        })?;
        
        let pre_master_secret = if self.curve == NAMED_CURVE_X25519 {
            // X25519 ECDH
            if server_pubkey_bytes.len() != 32 {
                crate::uart::write_line("TLS 1.2: Invalid X25519 key length");
                return Err(TlsError::InvalidData);
            }
            
            let mut server_key_bytes = [0u8; 32];
            server_key_bytes.copy_from_slice(server_pubkey_bytes);
            let server_public = x25519_dalek::PublicKey::from(server_key_bytes);
            
            let secret = self.x25519_secret.take().ok_or(TlsError::InvalidData)?;
            let shared = secret.diffie_hellman(&server_public);
            shared.to_bytes().to_vec()
        } else if self.curve == NAMED_CURVE_SECP256R1 {
            // P-256 (secp256r1) ECDH
            // Server public key is in uncompressed format: 0x04 + X (32) + Y (32) = 65 bytes
            if server_pubkey_bytes.len() != 65 {
                crate::uart::write_str("TLS 1.2: Invalid P-256 key length: ");
                let mut buf = [0u8; 10];
                let n = crate::tls::format_u16(server_pubkey_bytes.len() as u16, &mut buf);
                crate::uart::write_line(core::str::from_utf8(&buf[..n]).unwrap_or("?"));
                return Err(TlsError::InvalidData);
            }
            
            // Parse the server's public key from uncompressed format
            let server_point = EncodedPoint::from_bytes(server_pubkey_bytes)
                .map_err(|_| {
                    crate::uart::write_line("TLS 1.2: Invalid P-256 point encoding");
                    TlsError::InvalidData
                })?;
            
            let server_public = P256PublicKey::from_encoded_point(&server_point);
            let server_public = if server_public.is_some().into() {
                server_public.unwrap()
            } else {
                crate::uart::write_line("TLS 1.2: Invalid P-256 public key (not on curve)");
                return Err(TlsError::InvalidData);
            };
            
            // Get our P-256 secret and perform ECDH
            let secret = self.p256_secret.take().ok_or_else(|| {
                crate::uart::write_line("TLS 1.2: No P-256 secret key");
                TlsError::InvalidData
            })?;
            
            let shared = secret.diffie_hellman(&server_public);
            // The shared secret is the raw X coordinate (32 bytes)
            shared.raw_secret_bytes().to_vec()
        } else {
            crate::uart::write_line("TLS 1.2: Unsupported curve in compute_keys");
            return Err(TlsError::TlsProtocolError);
        };
        
        // Compute master secret using PRF
        // master_secret = PRF(pre_master_secret, "master secret", client_random + server_random)
        let mut seed = Vec::with_capacity(64);
        seed.extend_from_slice(&self.client_random);
        seed.extend_from_slice(&self.server_random);
        
        prf_sha256(
            &pre_master_secret,
            b"master secret",
            &seed,
            &mut self.master_secret,
        );
        
        // Compute key block
        // key_block = PRF(master_secret, "key expansion", server_random + client_random)
        seed.clear();
        seed.extend_from_slice(&self.server_random);
        seed.extend_from_slice(&self.client_random);
        
        // For AES_128_GCM_SHA256:
        // client_write_key (16) + server_write_key (16) + client_write_IV (4) + server_write_IV (4)
        let mut key_block = [0u8; 40];
        prf_sha256(
            &self.master_secret,
            b"key expansion",
            &seed,
            &mut key_block,
        );
        
        self.client_write_key.copy_from_slice(&key_block[0..16]);
        self.server_write_key.copy_from_slice(&key_block[16..32]);
        self.client_write_iv.copy_from_slice(&key_block[32..36]);
        self.server_write_iv.copy_from_slice(&key_block[36..40]);
        
        // Log which curve was used
        if self.curve == NAMED_CURVE_X25519 {
            crate::uart::write_line("TLS 1.2: Keys computed (X25519)");
        } else {
            crate::uart::write_line("TLS 1.2: Keys computed (P-256)");
        }
        Ok(())
    }
    
    /// Send ClientKeyExchange
    fn send_client_key_exchange(&mut self) -> Result<(), TlsError> {
        // Use the appropriate public key based on selected curve
        let pubkey_bytes = if self.curve == NAMED_CURVE_X25519 {
            &self.client_pubkey_x25519
        } else if self.curve == NAMED_CURVE_SECP256R1 {
            &self.client_pubkey_p256
        } else {
            crate::uart::write_line("TLS 1.2: No curve selected for ClientKeyExchange");
            return Err(TlsError::InternalError);
        };
        
        if pubkey_bytes.is_empty() {
            crate::uart::write_line("TLS 1.2: Client public key is empty");
            return Err(TlsError::InternalError);
        }
        
        // Build message: pubkey_len (1) + pubkey
        let mut msg = Vec::with_capacity(pubkey_bytes.len() + 1);
        msg.push(pubkey_bytes.len() as u8);
        msg.extend_from_slice(pubkey_bytes);
        
        let handshake = self.build_handshake_message(HANDSHAKE_CLIENT_KEY_EXCHANGE, &msg);
        self.handshake_hash.update(&handshake);
        self.send_record(CONTENT_TYPE_HANDSHAKE, &handshake)?;
        
        crate::uart::write_line("TLS 1.2: Sent ClientKeyExchange");
        Ok(())
    }
    
    /// Send ChangeCipherSpec
    fn send_change_cipher_spec(&mut self) -> Result<(), TlsError> {
        self.send_record(CONTENT_TYPE_CHANGE_CIPHER_SPEC, &[1])?;
        crate::uart::write_line("TLS 1.2: Sent ChangeCipherSpec");
        Ok(())
    }
    
    /// Send Finished
    fn send_finished(&mut self) -> Result<(), TlsError> {
        // Compute verify_data = PRF(master_secret, "client finished", Hash(handshake_messages))
        let handshake_hash = self.handshake_hash.clone().finalize();
        
        let mut verify_data = [0u8; 12];
        prf_sha256(
            &self.master_secret,
            b"client finished",
            &handshake_hash,
            &mut verify_data,
        );
        
        let handshake = self.build_handshake_message(HANDSHAKE_FINISHED, &verify_data);
        
        // Update hash BEFORE encryption (but the encrypted version isn't hashed)
        self.handshake_hash.update(&handshake);
        
        // Encrypt and send
        self.send_encrypted_record(CONTENT_TYPE_HANDSHAKE, &handshake)?;
        
        crate::uart::write_line("TLS 1.2: Sent Finished");
        Ok(())
    }
    
    /// Receive ChangeCipherSpec
    fn recv_change_cipher_spec(&mut self) -> Result<(), TlsError> {
        let record = self.recv_record()?;
        
        if record.content_type != CONTENT_TYPE_CHANGE_CIPHER_SPEC {
            return Err(TlsError::TlsProtocolError);
        }
        
        crate::uart::write_line("TLS 1.2: Received ChangeCipherSpec");
        Ok(())
    }
    
    /// Receive Finished
    fn recv_finished(&mut self) -> Result<(), TlsError> {
        // Receive encrypted record
        let record = self.recv_encrypted_record()?;
        
        if record.content_type != CONTENT_TYPE_HANDSHAKE {
            return Err(TlsError::TlsProtocolError);
        }
        
        if record.data.is_empty() || record.data[0] != HANDSHAKE_FINISHED {
            return Err(TlsError::TlsProtocolError);
        }
        
        crate::uart::write_line("TLS 1.2: Received Finished");
        Ok(())
    }
    
    /// Write data over TLS
    pub fn write(&mut self, data: &[u8]) -> Result<usize, TlsError> {
        self.send_encrypted_record(CONTENT_TYPE_APPLICATION_DATA, data)?;
        Ok(data.len())
    }
    
    /// Read data over TLS
    pub fn read(&mut self, buf: &mut [u8]) -> Result<usize, TlsError> {
        let record = self.recv_encrypted_record()?;
        
        if record.content_type == CONTENT_TYPE_ALERT {
            return Err(TlsError::ConnectionClosed);
        }
        
        if record.content_type != CONTENT_TYPE_APPLICATION_DATA {
            return Err(TlsError::TlsProtocolError);
        }
        
        let len = record.data.len().min(buf.len());
        buf[..len].copy_from_slice(&record.data[..len]);
        Ok(len)
    }
    
    /// Close the TLS connection
    pub fn close(&mut self) -> Result<(), TlsError> {
        // Send close_notify alert
        let alert = [1, 0]; // warning, close_notify
        let _ = self.send_encrypted_record(CONTENT_TYPE_ALERT, &alert);
        self.socket.close();
        Ok(())
    }
    
    // ═══════════════════════════════════════════════════════════════════════
    // HELPER METHODS
    // ═══════════════════════════════════════════════════════════════════════
    
    /// Build a handshake message with header
    fn build_handshake_message(&self, msg_type: u8, data: &[u8]) -> Vec<u8> {
        let mut msg = Vec::with_capacity(data.len() + 4);
        msg.push(msg_type);
        let len = data.len() as u32;
        msg.push((len >> 16) as u8);
        msg.push((len >> 8) as u8);
        msg.push(len as u8);
        msg.extend_from_slice(data);
        msg
    }
    
    /// Send a TLS record (unencrypted)
    fn send_record(&mut self, content_type: u8, data: &[u8]) -> Result<(), TlsError> {
        let mut record = Vec::with_capacity(data.len() + 5);
        record.push(content_type);
        record.extend_from_slice(&TLS_VERSION_1_2);
        record.extend_from_slice(&(data.len() as u16).to_be_bytes());
        record.extend_from_slice(data);
        
        self.socket.write(&record).map_err(|_| TlsError::Io)?;
        self.socket.flush().map_err(|_| TlsError::Io)?;
        Ok(())
    }
    
    /// Send an encrypted TLS record
    fn send_encrypted_record(&mut self, content_type: u8, plaintext: &[u8]) -> Result<(), TlsError> {
        // Build nonce: implicit IV (4 bytes) + explicit nonce (8 bytes)
        let mut nonce = [0u8; GCM_NONCE_SIZE];
        nonce[..4].copy_from_slice(&self.client_write_iv);
        nonce[4..].copy_from_slice(&self.client_seq.to_be_bytes());
        
        // Build additional data: seq_num (8) + content_type (1) + version (2) + length (2)
        let mut aad = [0u8; 13];
        aad[..8].copy_from_slice(&self.client_seq.to_be_bytes());
        aad[8] = content_type;
        aad[9..11].copy_from_slice(&TLS_VERSION_1_2);
        aad[11..13].copy_from_slice(&(plaintext.len() as u16).to_be_bytes());
        
        // Encrypt
        let cipher = Aes128Gcm::new_from_slice(&self.client_write_key)
            .map_err(|_| TlsError::TlsProtocolError)?;
        
        let mut ciphertext = plaintext.to_vec();
        let nonce_obj = Nonce::from_slice(&nonce);
        
        cipher.encrypt_in_place(nonce_obj, &aad, &mut ciphertext)
            .map_err(|_| TlsError::TlsProtocolError)?;
        
        // Build record: explicit_nonce (8) + ciphertext + tag (already appended by encrypt_in_place)
        let record_len = GCM_EXPLICIT_NONCE_SIZE + ciphertext.len();
        let mut record = Vec::with_capacity(record_len + 5);
        record.push(content_type);
        record.extend_from_slice(&TLS_VERSION_1_2);
        record.extend_from_slice(&(record_len as u16).to_be_bytes());
        record.extend_from_slice(&self.client_seq.to_be_bytes()); // explicit nonce
        record.extend_from_slice(&ciphertext);
        
        self.client_seq += 1;
        
        self.socket.write(&record).map_err(|_| TlsError::Io)?;
        self.socket.flush().map_err(|_| TlsError::Io)?;
        Ok(())
    }
    
    /// Receive a TLS record (unencrypted)
    fn recv_record(&mut self) -> Result<TlsRecord, TlsError> {
        // Read header (5 bytes)
        let mut header = [0u8; 5];
        self.read_exact(&mut header)?;
        
        let content_type = header[0];
        let version = [header[1], header[2]];
        let length = u16::from_be_bytes([header[3], header[4]]) as usize;
        
        crate::uart::write_str("TLS 1.2: Reading record - type=");
        let mut buf = [0u8; 10];
        let n = crate::tls::format_u16(content_type as u16, &mut buf);
        crate::uart::write_str(core::str::from_utf8(&buf[..n]).unwrap_or("?"));
        crate::uart::write_str(", ver=");
        let n = crate::tls::format_u16(version[0] as u16, &mut buf);
        crate::uart::write_str(core::str::from_utf8(&buf[..n]).unwrap_or("?"));
        crate::uart::write_str(".");
        let n = crate::tls::format_u16(version[1] as u16, &mut buf);
        crate::uart::write_str(core::str::from_utf8(&buf[..n]).unwrap_or("?"));
        crate::uart::write_str(", len=");
        let n = crate::tls::format_u16(length as u16, &mut buf);
        crate::uart::write_line(core::str::from_utf8(&buf[..n]).unwrap_or("?"));
        
        if length > 16384 + 2048 {
            crate::uart::write_line("TLS 1.2: Record too large");
            return Err(TlsError::InvalidData);
        }
        
        // Read data
        let mut data = vec![0u8; length];
        self.read_exact(&mut data)?;
        
        // Check for alert
        if content_type == CONTENT_TYPE_ALERT && data.len() >= 2 {
            let level = data[0];
            let desc = data[1];
            crate::uart::write_str("TLS 1.2: Alert received (level=");
            let n = crate::tls::format_u16(level as u16, &mut buf);
            crate::uart::write_str(core::str::from_utf8(&buf[..n]).unwrap_or("?"));
            crate::uart::write_str(", desc=");
            let n = crate::tls::format_u16(desc as u16, &mut buf);
            crate::uart::write_str(core::str::from_utf8(&buf[..n]).unwrap_or("?"));
            crate::uart::write_line(")");
            return Err(TlsError::TlsProtocolError);
        }
        
        Ok(TlsRecord { content_type, data })
    }
    
    /// Receive an encrypted TLS record
    fn recv_encrypted_record(&mut self) -> Result<TlsRecord, TlsError> {
        // Read header
        let mut header = [0u8; 5];
        self.read_exact(&mut header)?;
        
        let content_type = header[0];
        let length = u16::from_be_bytes([header[3], header[4]]) as usize;
        
        if length < GCM_EXPLICIT_NONCE_SIZE + GCM_TAG_SIZE {
            return Err(TlsError::InvalidData);
        }
        
        // Read data
        let mut data = vec![0u8; length];
        self.read_exact(&mut data)?;
        
        // Extract explicit nonce
        let explicit_nonce: [u8; 8] = data[..8].try_into().unwrap();
        let mut ciphertext = data[8..].to_vec();
        
        // Build full nonce
        let mut nonce = [0u8; GCM_NONCE_SIZE];
        nonce[..4].copy_from_slice(&self.server_write_iv);
        nonce[4..].copy_from_slice(&explicit_nonce);
        
        // Build AAD
        let plaintext_len = ciphertext.len() - GCM_TAG_SIZE;
        let mut aad = [0u8; 13];
        aad[..8].copy_from_slice(&self.server_seq.to_be_bytes());
        aad[8] = content_type;
        aad[9..11].copy_from_slice(&TLS_VERSION_1_2);
        aad[11..13].copy_from_slice(&(plaintext_len as u16).to_be_bytes());
        
        // Decrypt
        let cipher = Aes128Gcm::new_from_slice(&self.server_write_key)
            .map_err(|_| TlsError::TlsProtocolError)?;
        
        let nonce_obj = Nonce::from_slice(&nonce);
        cipher.decrypt_in_place(nonce_obj, &aad, &mut ciphertext)
            .map_err(|_| TlsError::TlsProtocolError)?;
        
        self.server_seq += 1;
        
        // Remove tag from result
        ciphertext.truncate(plaintext_len);
        let plaintext = ciphertext;
        
        Ok(TlsRecord { content_type, data: plaintext })
    }
    
    /// Read exactly n bytes
    fn read_exact(&mut self, buf: &mut [u8]) -> Result<(), TlsError> {
        let mut pos = 0;
        while pos < buf.len() {
            let n = self.socket.read(&mut buf[pos..])?;
            if n == 0 {
                return Err(TlsError::ConnectionClosed);
            }
            pos += n;
        }
        Ok(())
    }
}

/// A received TLS record
struct TlsRecord {
    content_type: u8,
    data: Vec<u8>,
}

// ═══════════════════════════════════════════════════════════════════════════════
// TLS 1.2 PRF (Pseudo-Random Function)
// ═══════════════════════════════════════════════════════════════════════════════

/// TLS 1.2 PRF using SHA-256
fn prf_sha256(secret: &[u8], label: &[u8], seed: &[u8], output: &mut [u8]) {
    let mut combined_seed = Vec::with_capacity(label.len() + seed.len());
    combined_seed.extend_from_slice(label);
    combined_seed.extend_from_slice(seed);
    
    p_hash::<Sha256>(secret, &combined_seed, output);
}

/// P_hash function for TLS PRF
fn p_hash<D: Digest + Clone>(secret: &[u8], seed: &[u8], output: &mut [u8]) {
    type HmacSha256 = Hmac<Sha256>;
    
    let mut a = {
        let mut mac = <HmacSha256 as Mac>::new_from_slice(secret).unwrap();
        mac.update(seed);
        mac.finalize().into_bytes().to_vec()
    };
    
    let mut pos = 0;
    while pos < output.len() {
        let mut mac = <HmacSha256 as Mac>::new_from_slice(secret).unwrap();
        mac.update(&a);
        mac.update(seed);
        let result = mac.finalize().into_bytes();
        
        let to_copy = (output.len() - pos).min(result.len());
        output[pos..pos + to_copy].copy_from_slice(&result[..to_copy]);
        pos += to_copy;
        
        // A(i+1) = HMAC(secret, A(i))
        let mut mac = <HmacSha256 as Mac>::new_from_slice(secret).unwrap();
        mac.update(&a);
        a = mac.finalize().into_bytes().to_vec();
    }
}

// ═══════════════════════════════════════════════════════════════════════════════
// PUBLIC API
// ═══════════════════════════════════════════════════════════════════════════════

/// Perform an HTTPS request using TLS 1.2
pub fn https_request_tls12(
    net: &mut crate::net::NetState,
    ip: smoltcp::wire::Ipv4Address,
    port: u16,
    hostname: &str,
    request_bytes: &[u8],
    timeout_ms: i64,
    get_time: fn() -> i64,
) -> Result<Vec<u8>, TlsError> {
    // Create blocking TCP socket and connect
    let mut socket = BlockingTcpSocket::new(net, timeout_ms, get_time);
    socket.connect(ip, port)?;
    
    // Create TLS 1.2 connection
    let mut tls = Tls12Connection::new(socket);
    
    // Perform handshake
    tls.handshake(hostname)?;
    
    // Send request
    tls.write(request_bytes)?;
    
    // Receive response
    let mut response = Vec::with_capacity(8192);
    let mut buf = [0u8; 1024];
    
    loop {
        match tls.read(&mut buf) {
            Ok(0) => break,
            Ok(n) => {
                response.extend_from_slice(&buf[..n]);
                // Check if response is complete
                if is_http_response_complete(&response) {
                    break;
                }
            }
            Err(TlsError::ConnectionClosed) => break,
            Err(e) => {
                let _ = tls.close();
                return Err(e);
            }
        }
    }
    
    let _ = tls.close();
    Ok(response)
}

/// Check if HTTP response is complete
fn is_http_response_complete(data: &[u8]) -> bool {
    // Find header end
    for i in 0..data.len().saturating_sub(3) {
        if data[i] == b'\r' && data[i + 1] == b'\n' 
           && data[i + 2] == b'\r' && data[i + 3] == b'\n' {
            let body_start = i + 4;
            
            // Check Content-Length
            if let Ok(headers) = core::str::from_utf8(&data[..i]) {
                for line in headers.lines() {
                    if line.to_lowercase().starts_with("content-length:") {
                        if let Some(len_str) = line.split(':').nth(1) {
                            if let Ok(content_len) = len_str.trim().parse::<usize>() {
                                return data.len() >= body_start + content_len;
                            }
                        }
                    }
                }
            }
            
            // No Content-Length, assume complete if we have headers
            return data.len() > body_start;
        }
    }
    false
}
</file>

<file path="kernel/src/virtio_blk.rs">
use core::ptr::{read_volatile, write_volatile};
use crate::virtio_net::{VIRTIO_BASE, VIRTIO_STRIDE}; // Reuse constants

const VIRTIO_BLK_DEVICE_ID: u32 = 2;

#[repr(C)]
struct VirtioBlkReqHeader {
    req_type: u32,
    reserved: u32,
    sector: u64,
}

pub struct VirtioBlock {
    base: usize,
    queue: crate::virtio_net::VirtQueue,
    capacity: u64,
}

// Static storage for block queue
#[repr(C, align(4096))]
struct BlkQueueMem { data: [u8; 4096 * 2] }
static mut BLK_QUEUE_MEM: BlkQueueMem = BlkQueueMem { data: [0; 4096 * 2] };

impl VirtioBlock {
    pub fn probe() -> Option<Self> {
        for i in 0..8 {
            let addr = VIRTIO_BASE + i * VIRTIO_STRIDE;
            let magic = unsafe { read_volatile((addr + 0x00) as *const u32) };
            let device_id = unsafe { read_volatile((addr + 0x08) as *const u32) };

            if magic == 0x7472_6976 && device_id == VIRTIO_BLK_DEVICE_ID {
                return Some(unsafe { Self::new(addr) });
            }
        }
        None
    }

    unsafe fn new(base: usize) -> Self {
        let mut dev = VirtioBlock {
            base,
            queue: crate::virtio_net::VirtQueue::new(BLK_QUEUE_MEM.data.as_mut_ptr(), 0),
            capacity: 0,
        };
        dev.init();
        dev
    }

    unsafe fn init(&mut self) {
        self.write32(0x070, 0); // Reset
        self.write32(0x070, 1 | 2); // ACK | DRIVER
        
        let cap_low = self.read32(0x100);
        let cap_high = self.read32(0x104);
        self.capacity = (cap_low as u64) | ((cap_high as u64) << 32);

        self.write32(0x028, 4096); 
        self.write32(0x030, 0); 
        self.write32(0x038, 16); 
        let pfn = (BLK_QUEUE_MEM.data.as_ptr() as u64) / 4096;
        self.write32(0x040, pfn as u32);
        self.write32(0x070, 1 | 2 | 4 | 8); // DRIVER_OK
    }

    fn op_sector(&mut self, sector: u64, buf: &mut [u8], is_write: bool) -> Result<(), &'static str> {
        if buf.len() != 512 { return Err("Buffer must be 512 bytes"); }
        
        let head_idx = self.queue.alloc_desc().ok_or("No desc")?;
        let data_idx = self.queue.alloc_desc().ok_or("No desc")?;
        let status_idx = self.queue.alloc_desc().ok_or("No desc")?;

        static mut REQ_HDR: VirtioBlkReqHeader = VirtioBlkReqHeader{ req_type: 0, reserved: 0, sector: 0 };
        static mut REQ_STATUS: u8 = 0;

        unsafe {
            REQ_HDR = VirtioBlkReqHeader {
                req_type: if is_write { 1 } else { 0 },
                reserved: 0,
                sector,
            };

            // 1. Header (Read-only by device)
            self.queue.desc[head_idx as usize].addr = &raw const REQ_HDR as u64;
            self.queue.desc[head_idx as usize].len = 16;
            self.queue.desc[head_idx as usize].flags = 1; // NEXT
            self.queue.desc[head_idx as usize].next = data_idx;

            // 2. Data
            self.queue.desc[data_idx as usize].addr = buf.as_ptr() as u64;
            self.queue.desc[data_idx as usize].len = 512;
            self.queue.desc[data_idx as usize].flags = 1 | (if is_write { 0 } else { 2 }); // NEXT | (WRITE if reading)
            self.queue.desc[data_idx as usize].next = status_idx;

            // 3. Status (Write-only by device)
            self.queue.desc[status_idx as usize].addr = &raw mut REQ_STATUS as u64;
            self.queue.desc[status_idx as usize].len = 1;
            self.queue.desc[status_idx as usize].flags = 2; // WRITE

            self.queue.push_avail(head_idx);
            self.write32(0x050, 0); 

            // Poll
            while !self.queue.has_used() { core::hint::spin_loop(); }
            self.queue.pop_used();

            self.queue.free_desc(head_idx);
            self.queue.free_desc(data_idx);
            self.queue.free_desc(status_idx);

            if REQ_STATUS == 0 { Ok(()) } else { Err("IO Error") }
        }
    }

    pub fn read_sector(&mut self, sector: u64, buf: &mut [u8]) -> Result<(), &'static str> {
        self.op_sector(sector, buf, false)
    }

    pub fn write_sector(&mut self, sector: u64, buf: &[u8]) -> Result<(), &'static str> {
        // Cast const slice to mut slice because op_sector signature expects mut, 
        // but for write op the device won't actually modify it.
        let ptr = buf.as_ptr() as *mut u8;
        let mut_slice = unsafe { core::slice::from_raw_parts_mut(ptr, 512) };
        self.op_sector(sector, mut_slice, true)
    }

    fn read32(&self, offset: usize) -> u32 {
        unsafe { read_volatile((self.base + offset) as *const u32) }
    }
    fn write32(&self, offset: usize, val: u32) {
        unsafe { write_volatile((self.base + offset) as *mut u32, val) }
    }
    pub fn capacity(&self) -> u64 { self.capacity }
}
</file>

<file path="kernel/.gitignore">
*.tar
*.img
</file>

<file path="mkfs/root/usr/bin/cowsay">
// cowsay - Make a cow say something!
// Usage: cowsay [message...]

let message = if len(ARGS) > 0 {
    join(ARGS, " ")
} else {
    "Moo!"
};

let msg_len = len(message);
let border = "----";
let i = 0;
while i < msg_len {
    border = border + "-";
    i = i + 1;
}

print(" " + border);
print("< " + message + " >");
print(" " + border);
print("        \\   ^__^");
print("         \\  (oo)\\_______");
print("            (__)\\       )\\/\\");
print("                ||----w |");
print("                ||     ||");
</file>

<file path="mkfs/root/usr/bin/dmesg">
// dmesg - Display kernel log messages
// Usage: dmesg [-n count]
//
// Shows kernel log messages from the ring buffer

import * as sys from "os:sys"
import * as fs from "os:fs"

// Parse arguments
let count = 20; // Default to last 20 messages
if ARGS.len() >= 2 && ARGS[0] == "-n" {
    count = parse_int(ARGS[1]);
    if count <= 0 {
        count = 20;
    }
}

print("\x1b[1;36m=== Kernel Log (last " + count + " messages) ===\x1b[0m");
print("");

// Get kernel log entries
let entries = get_klog(count);

if entries.len() == 0 {
    print("\x1b[90m(no log messages)\x1b[0m");
} else {
    for entry in entries {
        print(entry);
    }
}

print("");

// Also show if there's a persistent log file
if fs.exists("/var/log/kernel.log") {
    let log_size = 0;
    let files = fs.ls();
    for f in files {
        if f.name == "/var/log/kernel.log" {
            log_size = f.size;
        }
    }
    print("\x1b[90mPersistent log: /var/log/kernel.log (" + log_size + " bytes)\x1b[0m");
}
</file>

<file path="mkfs/root/usr/bin/echo">
// Usage: echo [text...]

if ARGS.len() > 0 {
    print(join(ARGS, " "));
} else {
    print("");
}
</file>

<file path="mkfs/root/usr/bin/kill">
// kill - Terminate a process
// Usage: kill <pid>
//
// Sends termination signal to the specified process

if ARGS.len() < 1 {
    print("Usage: kill <pid>");
    print("");
    print("Terminate a process by its PID.");
    print("Use 'ps' to list running processes.");
} else {
    let pid = parse_int(ARGS[0]);
    if pid <= 0 {
        print("\x1b[1;31mError:\x1b[0m Invalid PID: " + ARGS[0]);
    } else if pid == 1 {
        print("\x1b[1;31mError:\x1b[0m Cannot kill init (PID 1)");
    } else {
        let result = kill_task(pid);
        if result {
            print("\x1b[1;32m✓\x1b[0m Killed process " + pid);
        } else {
            print("\x1b[1;31mError:\x1b[0m Process " + pid + " not found");
        }
    }
}
</file>

<file path="mkfs/root/usr/bin/ps">
// ps - List running processes
// Usage: ps
//
// Shows all tasks/processes managed by the kernel scheduler

import * as sys from "os:sys"

print("\x1b[1;36m  PID  STATE  PRI     CPU    UPTIME  NAME\x1b[0m");
print("\x1b[90m─────────────────────────────────────────────────────\x1b[0m");

// Get process list from kernel
let tasks = get_tasks();

if tasks.len() == 0 {
    print("\x1b[90m  (no processes)\x1b[0m");
} else {
    for task in tasks {
        let pid_str = pad_left(task.pid.to_string(), 5, " ");
        let state_str = pad_right(task.state, 6, " ");
        let pri_str = pad_right(task.priority, 6, " ");
        let cpu_str = pad_left(task.cpu_time.to_string() + "ms", 8, " ");
        let uptime_str = pad_left((task.uptime / 1000).to_string() + "s", 8, " ");
        
        // Color based on state
        let color = if task.state == "R+" { 
            "\x1b[1;32m" 
        } else if task.state == "S" { 
            "\x1b[33m" 
        } else if task.state == "Z" { 
            "\x1b[31m" 
        } else { 
            "\x1b[0m" 
        };
        
        print(color + pid_str + "  " + state_str + " " + pri_str + " " + cpu_str + " " + uptime_str + "  " + task.name + "\x1b[0m");
    }
}

print("");
print("\x1b[90mStates: R=Ready R+=Running S=Sleeping Z=Zombie\x1b[0m");
</file>

<file path="mkfs/root/usr/bin/uptime">
// uptime - Show system uptime
// Usage: uptime

import * as sys from "os:sys"

let ms = sys.time();
let total_sec = ms / 1000;

let hours = total_sec / 3600;
let minutes = (total_sec % 3600) / 60;
let seconds = total_sec % 60;

if hours > 0 {
    print("Uptime: " + hours.to_string() + "h " + minutes.to_string() + "m " + seconds.to_string() + "s");
} else if minutes > 0 {
    print("Uptime: " + minutes.to_string() + "m " + seconds.to_string() + "s");
} else {
    print("Uptime: " + seconds.to_string() + "s");
}
</file>

<file path="mkfs/.gitignore">
*.img
</file>

<file path="mkfs/Cargo.toml">
[package]
name = "mkfs"
version = "0.0.0"
edition = "2021"

[dependencies]
clap = { version = "4.4", features = ["derive"] }
</file>

<file path="relay/src/hub.rs">
//! Central hub logic for the P2P WebTransport relay.
//!
//! The hub manages:
//! - Peer connections and registration
//! - Ethernet frame routing between peers
//! - ARP handling for the virtual gateway
//! - Forwarding external traffic to the proxy

use std::collections::HashMap;
use std::sync::Arc;
use tokio::sync::{broadcast, mpsc, RwLock};

use crate::peer::{PeerId, PeerManager};
use crate::protocol::{
    encode_data_frame, format_ip, format_mac, ControlMessage, DNS_SERVER, GATEWAY_IP, GATEWAY_MAC,
    MSG_TYPE_CONTROL, MSG_TYPE_DATA, NETWORK_MASK,
};
use crate::proxy::ExternalProxy;

/// Message sent to a peer connection task
#[derive(Debug, Clone)]
pub enum PeerMessage {
    /// Send a datagram to the peer
    Send(Vec<u8>),
    /// Disconnect the peer
    Disconnect,
}

/// The central hub that manages all peer connections and routing
pub struct Hub {
    /// Peer manager (shared state)
    peers: Arc<RwLock<PeerManager>>,
    /// Per-peer sender channels
    peer_senders: Arc<RwLock<HashMap<PeerId, mpsc::Sender<PeerMessage>>>>,
    /// External traffic proxy
    proxy: Arc<ExternalProxy>,
    /// Broadcast channel for frames (used for broadcasting)
    broadcast_tx: broadcast::Sender<(PeerId, Vec<u8>)>,
}

impl Hub {
    pub fn new() -> Self {
        let (broadcast_tx, _) = broadcast::channel(1024);
        Self {
            peers: Arc::new(RwLock::new(PeerManager::new())),
            peer_senders: Arc::new(RwLock::new(HashMap::new())),
            proxy: Arc::new(ExternalProxy::new()),
            broadcast_tx,
        }
    }

    /// Get a clone of the peers manager
    pub fn peers(&self) -> Arc<RwLock<PeerManager>> {
        self.peers.clone()
    }

    /// Get a clone of the proxy
    pub fn proxy(&self) -> Arc<ExternalProxy> {
        self.proxy.clone()
    }

    /// Subscribe to the broadcast channel
    pub fn subscribe(&self) -> broadcast::Receiver<(PeerId, Vec<u8>)> {
        self.broadcast_tx.subscribe()
    }

    /// Register a new peer connection
    pub async fn register_peer(
        &self,
        mac: [u8; 6],
        sender: mpsc::Sender<PeerMessage>,
    ) -> Option<(PeerId, [u8; 4])> {
        let mut peers = self.peers.write().await;
        let result = peers.register(mac)?;
        let (peer_id, ip) = result;

        let mut senders = self.peer_senders.write().await;
        senders.insert(peer_id, sender);

        // Send the assignment message
        let msg = ControlMessage::Assigned {
            ip,
            gateway: GATEWAY_IP,
            netmask: NETWORK_MASK,
            dns: DNS_SERVER,
        };

        if let Some(sender) = senders.get(&peer_id) {
            let _ = sender.send(PeerMessage::Send(msg.encode())).await;
        }

        Some((peer_id, ip))
    }

    /// Unregister a peer
    pub async fn unregister_peer(&self, peer_id: PeerId) {
        let mut peers = self.peers.write().await;
        peers.unregister(peer_id);

        let mut senders = self.peer_senders.write().await;
        senders.remove(&peer_id);
    }

    /// Update last-seen timestamp for a peer
    pub async fn touch_peer(&self, peer_id: PeerId) {
        let mut peers = self.peers.write().await;
        peers.touch(peer_id);
    }

    /// Route an incoming frame from a peer
    pub async fn route_frame(&self, from_peer: PeerId, data: Vec<u8>) {
        if data.is_empty() {
            return;
        }

        match data[0] {
            MSG_TYPE_CONTROL => {
                self.handle_control_message(from_peer, &data).await;
            }
            MSG_TYPE_DATA => {
                self.route_data_frame(from_peer, &data[1..]).await;
            }
            _ => {
                tracing::warn!("Unknown message type: {}", data[0]);
            }
        }
    }

    /// Handle a control message
    async fn handle_control_message(&self, from_peer: PeerId, data: &[u8]) {
        match ControlMessage::decode(data) {
            Ok(ControlMessage::Heartbeat) => {
                self.touch_peer(from_peer).await;
                // Send heartbeat ack
                let ack = ControlMessage::HeartbeatAck;
                self.send_to_peer(from_peer, ack.encode()).await;
            }
            Ok(ControlMessage::Disconnect) => {
                tracing::info!("Peer {} requested disconnect", from_peer);
                self.unregister_peer(from_peer).await;
            }
            Ok(msg) => {
                tracing::debug!("Received control message from peer {}: {:?}", from_peer, msg);
            }
            Err(e) => {
                tracing::warn!("Failed to decode control message: {}", e);
            }
        }
    }

    /// Route an Ethernet data frame
    async fn route_data_frame(&self, from_peer: PeerId, ethernet_frame: &[u8]) {
        if ethernet_frame.len() < 14 {
            return; // Too short for Ethernet header
        }

        let dst_mac: [u8; 6] = ethernet_frame[0..6].try_into().unwrap();
        let _src_mac: [u8; 6] = ethernet_frame[6..12].try_into().unwrap();
        let ethertype = u16::from_be_bytes([ethernet_frame[12], ethernet_frame[13]]);

        // Check for broadcast MAC
        let is_broadcast = dst_mac == [0xff, 0xff, 0xff, 0xff, 0xff, 0xff];

        // Handle ARP for gateway
        if ethertype == 0x0806 && self.is_arp_request_for_gateway(ethernet_frame) {
            let reply = self.generate_arp_reply(ethernet_frame);
            self.send_to_peer(from_peer, encode_data_frame(&reply)).await;
            return;
        }

        // Handle IPv4
        if ethertype == 0x0800 && ethernet_frame.len() >= 34 {
            let dst_ip: [u8; 4] = ethernet_frame[30..34].try_into().unwrap();

            // Check if destination is gateway (ping to gateway)
            if dst_ip == GATEWAY_IP {
                if let Some(reply) = self.handle_gateway_packet(ethernet_frame).await {
                    self.send_to_peer(from_peer, encode_data_frame(&reply)).await;
                }
                return;
            }

            // Check if destination is external
            let peers = self.peers.read().await;
            if !peers.is_internal_ip(&dst_ip) {
                drop(peers);
                // Route to external proxy
                if let Some(reply) = self.proxy.handle_external_packet(ethernet_frame).await {
                    self.send_to_peer(from_peer, encode_data_frame(&reply)).await;
                }
                return;
            }

            // Route to internal peer
            if let Some(target_peer) = peers.peer_id_by_ip(&dst_ip) {
                drop(peers);
                if target_peer != from_peer {
                    self.send_to_peer(target_peer, encode_data_frame(ethernet_frame))
                        .await;
                }
                return;
            }
        }

        // Broadcast handling
        if is_broadcast {
            let _ = self
                .broadcast_tx
                .send((from_peer, encode_data_frame(ethernet_frame)));
        } else if dst_mac == GATEWAY_MAC {
            // Addressed to gateway but not handled above - drop
            tracing::trace!("Dropping frame addressed to gateway MAC");
        } else {
            // Try to find peer by MAC
            let peers = self.peers.read().await;
            if let Some(peer) = peers.find_by_mac(&dst_mac) {
                let target_id = peer.id;
                drop(peers);
                self.send_to_peer(target_id, encode_data_frame(ethernet_frame))
                    .await;
            }
        }
    }

    /// Send a message to a specific peer
    pub async fn send_to_peer(&self, peer_id: PeerId, data: Vec<u8>) {
        let senders = self.peer_senders.read().await;
        if let Some(sender) = senders.get(&peer_id) {
            let _ = sender.send(PeerMessage::Send(data)).await;
        }
    }

    /// Check if this is an ARP request for the gateway
    fn is_arp_request_for_gateway(&self, frame: &[u8]) -> bool {
        if frame.len() < 42 {
            return false;
        }
        // ARP operation = request (1)
        if frame[20] != 0x00 || frame[21] != 0x01 {
            return false;
        }
        // Target protocol address = gateway IP
        frame[38..42] == GATEWAY_IP
    }

    /// Generate an ARP reply for the gateway
    fn generate_arp_reply(&self, request: &[u8]) -> Vec<u8> {
        let mut reply = vec![0u8; 42];

        // Ethernet header
        reply[0..6].copy_from_slice(&request[6..12]); // dst = requester's MAC
        reply[6..12].copy_from_slice(&GATEWAY_MAC); // src = gateway MAC
        reply[12..14].copy_from_slice(&[0x08, 0x06]); // ethertype = ARP

        // ARP header
        reply[14..16].copy_from_slice(&[0x00, 0x01]); // hardware type = ethernet
        reply[16..18].copy_from_slice(&[0x08, 0x00]); // protocol type = IPv4
        reply[18] = 6; // hardware addr len
        reply[19] = 4; // protocol addr len
        reply[20..22].copy_from_slice(&[0x00, 0x02]); // operation = reply
        reply[22..28].copy_from_slice(&GATEWAY_MAC); // sender hardware addr
        reply[28..32].copy_from_slice(&GATEWAY_IP); // sender protocol addr
        reply[32..38].copy_from_slice(&request[22..28]); // target hardware addr
        reply[38..42].copy_from_slice(&request[28..32]); // target protocol addr

        reply
    }

    /// Handle a packet addressed to the gateway (e.g., ICMP ping)
    async fn handle_gateway_packet(&self, frame: &[u8]) -> Option<Vec<u8>> {
        if frame.len() < 34 {
            return None;
        }

        let protocol = frame[23];

        // ICMP echo request to gateway
        if protocol == 1 && frame.len() >= 42 && frame[34] == 8 {
            return Some(self.generate_icmp_reply(frame));
        }

        None
    }

    /// Generate an ICMP echo reply
    fn generate_icmp_reply(&self, request: &[u8]) -> Vec<u8> {
        let mut reply = request.to_vec();

        // Swap MAC addresses
        reply[0..6].copy_from_slice(&request[6..12]);
        reply[6..12].copy_from_slice(&GATEWAY_MAC);

        // Swap IP addresses
        let src_ip: [u8; 4] = request[26..30].try_into().unwrap();
        let dst_ip: [u8; 4] = request[30..34].try_into().unwrap();
        reply[26..30].copy_from_slice(&dst_ip);
        reply[30..34].copy_from_slice(&src_ip);

        // Recalculate IP checksum
        reply[24] = 0;
        reply[25] = 0;
        let ip_checksum = compute_checksum(&reply[14..34]);
        reply[24] = (ip_checksum >> 8) as u8;
        reply[25] = (ip_checksum & 0xff) as u8;

        // Change ICMP type to echo reply (0)
        reply[34] = 0;

        // Recalculate ICMP checksum
        reply[36] = 0;
        reply[37] = 0;
        let icmp_checksum = compute_checksum(&reply[34..]);
        reply[36] = (icmp_checksum >> 8) as u8;
        reply[37] = (icmp_checksum & 0xff) as u8;

        reply
    }

    /// Cleanup expired peers
    pub async fn cleanup_expired_peers(&self) {
        let mut peers = self.peers.write().await;
        let expired = peers.cleanup_expired();
        drop(peers);

        let mut senders = self.peer_senders.write().await;
        for id in expired {
            senders.remove(&id);
        }
    }

    /// Log hub statistics
    pub async fn log_stats(&self) {
        let peers = self.peers.read().await;
        let count = peers.peer_count();
        if count > 0 {
            tracing::info!("Hub stats: {} connected peers", count);
            for peer in peers.all_peers() {
                tracing::debug!(
                    "  Peer {}: MAC={}, IP={}",
                    peer.id,
                    format_mac(&peer.mac),
                    format_ip(&peer.ip)
                );
            }
        }
    }
}

impl Default for Hub {
    fn default() -> Self {
        Self::new()
    }
}

/// Compute Internet checksum
fn compute_checksum(data: &[u8]) -> u16 {
    let mut sum: u32 = 0;
    let mut i = 0;
    while i + 1 < data.len() {
        sum += u16::from_be_bytes([data[i], data[i + 1]]) as u32;
        i += 2;
    }
    if i < data.len() {
        sum += (data[i] as u32) << 8;
    }
    while sum > 0xFFFF {
        sum = (sum & 0xFFFF) + (sum >> 16);
    }
    !(sum as u16)
}
</file>

<file path="relay/src/protocol.rs">
//! Protocol definitions for the P2P WebTransport relay network.
//!
//! Frames are prefixed with a message type byte:
//! - 0x00 = Control message (JSON-encoded)
//! - 0x01 = Ethernet data frame
//!
//! Control messages handle peer registration, IP assignment, and heartbeat.

use serde::{Deserialize, Serialize};

/// Message type prefix bytes
pub const MSG_TYPE_CONTROL: u8 = 0x00;
pub const MSG_TYPE_DATA: u8 = 0x01;

/// Network configuration constants
pub const GATEWAY_IP: [u8; 4] = [10, 0, 2, 2];
pub const GATEWAY_MAC: [u8; 6] = [0x52, 0x54, 0x00, 0x12, 0x34, 0x56];
pub const NETWORK_MASK: [u8; 4] = [255, 255, 255, 0];
pub const DNS_SERVER: [u8; 4] = [8, 8, 8, 8];

/// IP pool range for peer assignment
pub const IP_POOL_START: u8 = 10; // 10.0.2.10
pub const IP_POOL_END: u8 = 254;  // 10.0.2.254

/// Control messages exchanged between peers and the relay hub.
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(tag = "type")]
pub enum ControlMessage {
    /// Peer requests registration with its MAC address
    Register {
        mac: [u8; 6],
    },
    
    /// Hub assigns IP configuration to peer
    Assigned {
        ip: [u8; 4],
        gateway: [u8; 4],
        netmask: [u8; 4],
        dns: [u8; 4],
    },
    
    /// Heartbeat to keep connection alive
    Heartbeat,
    
    /// Heartbeat acknowledgment
    HeartbeatAck,
    
    /// Peer disconnecting gracefully
    Disconnect,
    
    /// Error message from hub
    Error {
        message: String,
    },
    
    /// List of connected peers (optional, for discovery)
    PeerList {
        peers: Vec<PeerInfo>,
    },
}

/// Information about a connected peer
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PeerInfo {
    pub ip: [u8; 4],
    pub mac: [u8; 6],
}

impl ControlMessage {
    /// Encode a control message as a framed datagram (type prefix + JSON)
    pub fn encode(&self) -> Vec<u8> {
        let json = serde_json::to_vec(self).expect("Failed to serialize control message");
        let mut frame = Vec::with_capacity(1 + json.len());
        frame.push(MSG_TYPE_CONTROL);
        frame.extend(json);
        frame
    }
    
    /// Decode a control message from a framed datagram
    pub fn decode(data: &[u8]) -> Result<Self, String> {
        if data.is_empty() {
            return Err("Empty message".to_string());
        }
        if data[0] != MSG_TYPE_CONTROL {
            return Err(format!("Not a control message (type={})", data[0]));
        }
        serde_json::from_slice(&data[1..])
            .map_err(|e| format!("Failed to parse control message: {}", e))
    }
}

/// Encode an Ethernet frame as a data datagram
pub fn encode_data_frame(ethernet_frame: &[u8]) -> Vec<u8> {
    let mut frame = Vec::with_capacity(1 + ethernet_frame.len());
    frame.push(MSG_TYPE_DATA);
    frame.extend(ethernet_frame);
    frame
}

/// Helper to format MAC address for display
pub fn format_mac(mac: &[u8; 6]) -> String {
    format!(
        "{:02x}:{:02x}:{:02x}:{:02x}:{:02x}:{:02x}",
        mac[0], mac[1], mac[2], mac[3], mac[4], mac[5]
    )
}

/// Helper to format IP address for display
pub fn format_ip(ip: &[u8; 4]) -> String {
    format!("{}.{}.{}.{}", ip[0], ip[1], ip[2], ip[3])
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_control_message_roundtrip() {
        let msg = ControlMessage::Register {
            mac: [0x52, 0x54, 0x00, 0xab, 0xcd, 0xef],
        };
        let encoded = msg.encode();
        let decoded = ControlMessage::decode(&encoded).unwrap();
        
        match decoded {
            ControlMessage::Register { mac } => {
                assert_eq!(mac, [0x52, 0x54, 0x00, 0xab, 0xcd, 0xef]);
            }
            _ => panic!("Wrong message type"),
        }
    }

}
</file>

<file path="relay/src/proxy.rs">
//! External traffic proxy for the relay hub.
//!
//! Handles:
//! - TCP proxy (HTTP, HTTPS connections)
//! - UDP proxy (DNS queries, etc.)
//! - ICMP proxy (ping requests)

use std::collections::HashMap;
use std::net::{Ipv4Addr, SocketAddr, SocketAddrV4};
use std::sync::Arc;
use std::time::{Duration, Instant};
use tokio::io::{AsyncReadExt, AsyncWriteExt};
use tokio::net::{TcpStream, UdpSocket};
use tokio::sync::{mpsc, Mutex};

use crate::protocol::GATEWAY_MAC;

/// Session for tracking NAT'ed UDP connections
#[derive(Debug, Clone)]
struct UdpSession {
    /// Original source MAC
    src_mac: [u8; 6],
    /// Original source IP
    src_ip: [u8; 4],
    /// Original source port
    src_port: u16,
    /// External destination IP
    dst_ip: [u8; 4],
    /// External destination port
    dst_port: u16,
    /// Creation time
    created: Instant,
}

/// TCP connection state
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
enum TcpState {
    SynSent,
    Established,
    FinWait,
    Closed,
}

/// Session for tracking NAT'ed TCP connections
struct TcpSession {
    /// Original source MAC
    src_mac: [u8; 6],
    /// Original source IP
    src_ip: [u8; 4],
    /// Original source port
    src_port: u16,
    /// External destination IP
    dst_ip: [u8; 4],
    /// External destination port
    dst_port: u16,
    /// Connection state
    state: TcpState,
    /// Last sequence number seen from VM
    vm_seq: u32,
    /// Last ack number seen from VM
    vm_ack: u32,
    /// Last sequence number from server
    server_seq: u32,
    /// Last ack number from server
    server_ack: u32,
    /// Channel to send data to the TCP forwarding task
    tx: mpsc::Sender<Vec<u8>>,
    /// Last activity time
    last_activity: Instant,
}

/// TCP connection key
#[derive(Debug, Clone, Copy, Hash, PartialEq, Eq)]
struct TcpKey {
    src_ip: [u8; 4],
    src_port: u16,
    dst_ip: [u8; 4],
    dst_port: u16,
}

/// External traffic proxy
pub struct ExternalProxy {
    /// UDP socket for external traffic
    udp_socket: Mutex<Option<Arc<UdpSocket>>>,
    /// Active UDP sessions (keyed by local port or dst:port combo)
    udp_sessions: Mutex<HashMap<(Ipv4Addr, u16, u16), UdpSession>>,
    /// Active TCP sessions
    tcp_sessions: Mutex<HashMap<TcpKey, TcpSession>>,
    /// Channel to receive responses from TCP connections
    tcp_response_tx: mpsc::Sender<Vec<u8>>,
    tcp_response_rx: Mutex<mpsc::Receiver<Vec<u8>>>,
    /// Session timeout
    session_timeout: Duration,
}

impl ExternalProxy {
    pub fn new() -> Self {
        let (tx, rx) = mpsc::channel(256);
        Self {
            udp_socket: Mutex::new(None),
            udp_sessions: Mutex::new(HashMap::new()),
            tcp_sessions: Mutex::new(HashMap::new()),
            tcp_response_tx: tx,
            tcp_response_rx: Mutex::new(rx),
            session_timeout: Duration::from_secs(120),
        }
    }

    /// Initialize the proxy (bind UDP socket)
    pub async fn init(&self) -> anyhow::Result<()> {
        let socket = UdpSocket::bind("0.0.0.0:0").await?;
        tracing::info!("External proxy UDP socket bound to {}", socket.local_addr()?);
        *self.udp_socket.lock().await = Some(Arc::new(socket));
        Ok(())
    }

    /// Get the UDP socket for receiving
    pub async fn udp_socket(&self) -> Option<Arc<UdpSocket>> {
        self.udp_socket.lock().await.clone()
    }

    /// Poll for TCP responses (non-blocking)
    pub async fn poll_tcp_response(&self) -> Option<Vec<u8>> {
        let mut rx = self.tcp_response_rx.lock().await;
        rx.try_recv().ok()
    }

    /// Handle an external-bound packet from a peer
    pub async fn handle_external_packet(&self, frame: &[u8]) -> Option<Vec<u8>> {
        if frame.len() < 34 {
            return None;
        }

        let protocol = frame[23];

        match protocol {
            1 => self.handle_icmp(frame).await,   // ICMP
            6 => self.handle_tcp(frame).await,    // TCP
            17 => self.handle_udp(frame).await,   // UDP
            _ => {
                tracing::trace!("Unsupported protocol: {}", protocol);
                None
            }
        }
    }

    /// Handle outbound ICMP (ping) request
    async fn handle_icmp(&self, frame: &[u8]) -> Option<Vec<u8>> {
        if frame.len() < 42 {
            return None;
        }

        // Check if this is an echo request (type 8)
        if frame[34] != 8 {
            return None;
        }

        let src_mac: [u8; 6] = frame[6..12].try_into().ok()?;
        let src_ip: [u8; 4] = frame[26..30].try_into().ok()?;
        let dst_ip: [u8; 4] = frame[30..34].try_into().ok()?;
        let ident = u16::from_be_bytes([frame[38], frame[39]]);
        let seq = u16::from_be_bytes([frame[40], frame[41]]);

        let dst_addr = Ipv4Addr::from(dst_ip);
        tracing::debug!(
            "ICMP proxy: ping {} (ident={}, seq={})",
            dst_addr,
            ident,
            seq
        );

        // Execute ping using system command
        // This works in Docker without NET_ADMIN capability
        let output = tokio::process::Command::new("ping")
            .args(["-c", "1", "-W", "3", &dst_addr.to_string()])
            .output()
            .await;

        match output {
            Ok(out) if out.status.success() => {
                tracing::debug!("ICMP proxy: ping {} succeeded", dst_addr);
                Some(self.generate_icmp_reply(&src_mac, &src_ip, &dst_ip, ident, seq))
            }
            Ok(_) => {
                tracing::debug!("ICMP proxy: ping {} failed (timeout or unreachable)", dst_addr);
                None
            }
            Err(e) => {
                tracing::warn!("ICMP proxy: failed to execute ping: {}", e);
                None
            }
        }
    }

    /// Generate an ICMP echo reply frame
    fn generate_icmp_reply(
        &self,
        dst_mac: &[u8; 6],
        dst_ip: &[u8; 4],
        src_ip: &[u8; 4],
        ident: u16,
        seq: u16,
    ) -> Vec<u8> {
        let icmp_data = b"RISCV_PING"; // Match kernel's ping data
        let icmp_len = 8 + icmp_data.len();
        let ip_len = 20 + icmp_len;
        let frame_len = 14 + ip_len;

        let mut frame = vec![0u8; frame_len];

        // Ethernet header
        frame[0..6].copy_from_slice(dst_mac);
        frame[6..12].copy_from_slice(&GATEWAY_MAC);
        frame[12..14].copy_from_slice(&[0x08, 0x00]);

        // IP header
        frame[14] = 0x45;
        frame[15] = 0;
        frame[16..18].copy_from_slice(&(ip_len as u16).to_be_bytes());
        frame[18..20].copy_from_slice(&ident.to_be_bytes());
        frame[20..22].copy_from_slice(&[0x00, 0x00]);
        frame[22] = 64; // TTL
        frame[23] = 1;  // ICMP
        frame[24..26].copy_from_slice(&[0x00, 0x00]); // checksum placeholder
        frame[26..30].copy_from_slice(src_ip);
        frame[30..34].copy_from_slice(dst_ip);

        // IP checksum
        let ip_checksum = compute_checksum(&frame[14..34]);
        frame[24] = (ip_checksum >> 8) as u8;
        frame[25] = (ip_checksum & 0xff) as u8;

        // ICMP header
        frame[34] = 0; // Echo reply
        frame[35] = 0; // Code
        frame[36..38].copy_from_slice(&[0x00, 0x00]); // checksum placeholder
        frame[38..40].copy_from_slice(&ident.to_be_bytes());
        frame[40..42].copy_from_slice(&seq.to_be_bytes());
        frame[42..].copy_from_slice(icmp_data);

        // ICMP checksum
        let icmp_checksum = compute_checksum(&frame[34..]);
        frame[36] = (icmp_checksum >> 8) as u8;
        frame[37] = (icmp_checksum & 0xff) as u8;

        frame
    }

    /// Handle outbound TCP packet
    async fn handle_tcp(&self, frame: &[u8]) -> Option<Vec<u8>> {
        if frame.len() < 54 {
            return None;
        }

        let src_mac: [u8; 6] = frame[6..12].try_into().ok()?;
        let src_ip: [u8; 4] = frame[26..30].try_into().ok()?;
        let dst_ip: [u8; 4] = frame[30..34].try_into().ok()?;

        // Get IP header length
        let ihl = ((frame[14] & 0x0f) * 4) as usize;
        let tcp_start = 14 + ihl;

        if frame.len() < tcp_start + 20 {
            return None;
        }

        let src_port = u16::from_be_bytes([frame[tcp_start], frame[tcp_start + 1]]);
        let dst_port = u16::from_be_bytes([frame[tcp_start + 2], frame[tcp_start + 3]]);
        let seq_num = u32::from_be_bytes([
            frame[tcp_start + 4],
            frame[tcp_start + 5],
            frame[tcp_start + 6],
            frame[tcp_start + 7],
        ]);
        let ack_num = u32::from_be_bytes([
            frame[tcp_start + 8],
            frame[tcp_start + 9],
            frame[tcp_start + 10],
            frame[tcp_start + 11],
        ]);
        let flags = frame[tcp_start + 13];

        let syn = (flags & 0x02) != 0;
        let ack = (flags & 0x10) != 0;
        let fin = (flags & 0x01) != 0;
        let rst = (flags & 0x04) != 0;

        let key = TcpKey {
            src_ip,
            src_port,
            dst_ip,
            dst_port,
        };

        let dst_addr = Ipv4Addr::from(dst_ip);

        // Calculate payload size
        let tcp_header_len = ((frame[tcp_start + 12] >> 4) * 4) as usize;
        let payload_start = tcp_start + tcp_header_len;
        let payload_len = if frame.len() > payload_start { frame.len() - payload_start } else { 0 };
        
        tracing::info!(
            "TCP: {}:{} -> {}:{} flags=[{}{}{}{}] seq={} ack={} payload={}",
            Ipv4Addr::from(src_ip),
            src_port,
            dst_addr,
            dst_port,
            if syn { "S" } else { "" },
            if ack { "A" } else { "" },
            if fin { "F" } else { "" },
            if rst { "R" } else { "" },
            seq_num,
            ack_num,
            payload_len,
        );

        // Handle SYN - new connection or retransmission
        if syn && !ack {
            // Check if we already have a session for this connection
            let sessions = self.tcp_sessions.lock().await;
            if let Some(session) = sessions.get(&key) {
                // SYN retransmission - resend SYN-ACK
                tracing::debug!("TCP proxy: SYN retransmission, resending SYN-ACK");
                let synack = Self::build_tcp_packet(
                    &session.src_mac,
                    &session.src_ip,
                    session.src_port,
                    &session.dst_ip,
                    session.dst_port,
                    session.server_seq,
                    seq_num.wrapping_add(1),
                    0x12, // SYN+ACK
                    &[],
                );
                drop(sessions);
                return Some(synack);
            }
            drop(sessions);
            
            return self.handle_tcp_syn(key, src_mac, src_ip, src_port, dst_ip, dst_port, seq_num).await;
        }

        // Handle RST - connection reset
        if rst {
            let mut sessions = self.tcp_sessions.lock().await;
            if let Some(session) = sessions.remove(&key) {
                tracing::debug!("TCP proxy: connection reset by VM");
                drop(session.tx);
            }
            return None;
        }

        // Handle established connection data
        let mut sessions = self.tcp_sessions.lock().await;
        if let Some(session) = sessions.get_mut(&key) {
            session.last_activity = Instant::now();
            session.vm_seq = seq_num;
            session.vm_ack = ack_num;

            // Handle FIN
            if fin {
                session.state = TcpState::FinWait;
                // Send FIN to server via the channel
                let _ = session.tx.try_send(vec![]);
                
                // Send FIN-ACK back to VM
                let fin_ack = Self::build_tcp_packet(
                    &session.src_mac,
                    &session.src_ip,
                    session.src_port,
                    &session.dst_ip,
                    session.dst_port,
                    session.server_seq,
                    seq_num.wrapping_add(1),
                    0x11, // FIN+ACK
                    &[],
                );
                drop(sessions);
                return Some(fin_ack);
            }

            // Extract TCP payload (payload_start and payload_len already calculated above)
            if payload_len > 0 {
                let packet_end = seq_num.wrapping_add(payload_len as u32);
                
                // Check if this packet contains any new data
                // A packet can be:
                // 1. Pure retransmission: packet_end <= server_ack
                // 2. Partial overlap: seq_num < server_ack < packet_end (has some new data)
                // 3. New data: seq_num >= server_ack
                
                let diff_start = session.server_ack.wrapping_sub(seq_num) as i32;
                let diff_end = packet_end.wrapping_sub(session.server_ack) as i32;
                
                // Pure retransmission: starts before server_ack AND ends at or before server_ack
                let is_pure_retransmission = diff_start > 0 && diff_start < (1 << 30) && 
                                             (diff_end <= 0 || diff_end >= (1 << 30));
                
                if is_pure_retransmission {
                    tracing::debug!("TCP proxy: pure retransmission detected (seq={}, end={}, already_acked={}), sending ACK only", 
                        seq_num, packet_end, session.server_ack);
                    
                    // Just re-send ACK, don't forward to server
                    let our_seq = session.server_seq.wrapping_add(1);
                    let ack_packet = Self::build_tcp_packet(
                        &session.src_mac,
                        &session.src_ip,
                        session.src_port,
                        &session.dst_ip,
                        session.dst_port,
                        our_seq,
                        session.server_ack,  // Use already-acknowledged value
                        0x10, // ACK
                        &[],
                    );
                    drop(sessions);
                    return Some(ack_packet);
                }
                
                // Extract only the new data (skip bytes we've already ACKed)
                let payload = if diff_start > 0 && diff_start < (1 << 30) {
                    // Partial retransmission - extract only new portion
                    let skip_bytes = diff_start as usize;
                    tracing::info!("TCP proxy: partial retransmission - skipping {} already-acked bytes, forwarding {} new bytes",
                        skip_bytes, payload_len - skip_bytes);
                    frame[payload_start + skip_bytes..].to_vec()
                } else {
                    // All new data
                    frame[payload_start..].to_vec()
                };
                
                // Calculate the expected ACK based on actual packet end
                let expected_ack = packet_end;
                
                tracing::info!("TCP proxy: queueing {} bytes for server task (seq={})", payload_len, seq_num);
                
                // Forward data to the server task
                match session.tx.try_send(payload) {
                    Ok(()) => tracing::info!("TCP proxy: data queued successfully"),
                    Err(e) => tracing::error!("TCP proxy: failed to queue data: {}", e),
                }
                
                // Send immediate ACK back to VM so it doesn't timeout
                // Need to use server_seq + 1 (since SYN-ACK consumed one seq number)
                let our_seq = session.server_seq.wrapping_add(1);
                
                tracing::info!("TCP proxy: sending ACK to VM (our_seq={}, acking={})", our_seq, expected_ack);
                
                let ack_packet = Self::build_tcp_packet(
                    &session.src_mac,
                    &session.src_ip,
                    session.src_port,
                    &session.dst_ip,
                    session.dst_port,
                    our_seq,
                    expected_ack,
                    0x10, // ACK
                    &[],
                );
                
                // Update our tracking of what we've acked
                session.server_ack = expected_ack;
                
                drop(sessions);
                return Some(ack_packet);
            }
        } else {
            tracing::debug!("TCP proxy: no session for packet (may be stale)");
        }

        None
    }

    /// Handle TCP SYN - establish new connection
    async fn handle_tcp_syn(
        &self,
        key: TcpKey,
        src_mac: [u8; 6],
        src_ip: [u8; 4],
        src_port: u16,
        dst_ip: [u8; 4],
        dst_port: u16,
        seq_num: u32,
    ) -> Option<Vec<u8>> {
        let dst_addr = Ipv4Addr::from(dst_ip);
        
        tracing::info!("TCP proxy: new connection to {}:{}", dst_addr, dst_port);

        // Try to connect to the external server
        let server_addr = SocketAddrV4::new(dst_addr, dst_port);
        
        let stream = match tokio::time::timeout(
            Duration::from_secs(10),
            TcpStream::connect(server_addr)
        ).await {
            Ok(Ok(stream)) => stream,
            Ok(Err(e)) => {
                tracing::warn!("TCP proxy: connection failed: {}", e);
                return Some(self.generate_tcp_rst(&src_mac, &src_ip, src_port, &dst_ip, dst_port, seq_num));
            }
            Err(_) => {
                tracing::warn!("TCP proxy: connection timeout");
                return Some(self.generate_tcp_rst(&src_mac, &src_ip, src_port, &dst_ip, dst_port, seq_num));
            }
        };

        tracing::info!("TCP proxy: connected to {}:{}", dst_addr, dst_port);

        // Create channel for sending data to the forwarding task
        let (tx, rx) = mpsc::channel(64);

        // Initial sequence numbers (use timestamp-based value)
        let server_seq = std::time::SystemTime::now()
            .duration_since(std::time::UNIX_EPOCH)
            .unwrap()
            .as_nanos() as u32;

        // Store session
        let session = TcpSession {
            src_mac,
            src_ip,
            src_port,
            dst_ip,
            dst_port,
            state: TcpState::SynSent,
            vm_seq: seq_num,
            vm_ack: 0,
            server_seq,
            server_ack: seq_num.wrapping_add(1),
            tx,
            last_activity: Instant::now(),
        };

        self.tcp_sessions.lock().await.insert(key, session);

        // Spawn task to handle this connection
        let response_tx = self.tcp_response_tx.clone();
        tokio::spawn(async move {
            Self::tcp_connection_task(
                stream,
                rx,
                response_tx,
                src_mac,
                src_ip,
                src_port,
                dst_ip,
                dst_port,
                server_seq.wrapping_add(1), // Start data seq after SYN
                seq_num.wrapping_add(1),
            ).await;
        });

        // Send SYN-ACK back to VM
        Some(self.generate_tcp_synack(
            &src_mac,
            &src_ip,
            src_port,
            &dst_ip,
            dst_port,
            server_seq,
            seq_num.wrapping_add(1),
        ))
    }

    /// Task that handles a single TCP connection
    async fn tcp_connection_task(
        mut stream: TcpStream,
        mut rx: mpsc::Receiver<Vec<u8>>,
        response_tx: mpsc::Sender<Vec<u8>>,
        src_mac: [u8; 6],
        src_ip: [u8; 4],
        src_port: u16,
        dst_ip: [u8; 4],
        dst_port: u16,
        mut seq: u32,
        mut ack: u32,
    ) {
        let mut buf = vec![0u8; 4096];
        
        tracing::debug!("TCP proxy task: started with seq={}, ack={}", seq, ack);

        loop {
            tokio::select! {
                // Data from server
                result = stream.read(&mut buf) => {
                    match result {
                        Ok(0) => {
                            tracing::info!("TCP proxy task: server closed connection (sending FIN with seq={}, ack={})", seq, ack);
                            // Send FIN to VM
                            let fin = Self::build_tcp_packet(
                                &src_mac, &src_ip, src_port, &dst_ip, dst_port,
                                seq, ack, 0x11, &[], // FIN+ACK
                            );
                            let _ = response_tx.send(fin).await;
                            break;
                        }
                        Ok(n) => {
                            tracing::info!("TCP proxy task: received {} bytes from server, building packet with seq={}, ack={}", n, seq, ack);
                            
                            // Fragment large data to fit in WebTransport datagrams
                            // Max safe payload size is ~1200 bytes, we use 1000 to be safe
                            const MAX_TCP_PAYLOAD: usize = 1000;
                            let data = &buf[..n];
                            let mut offset = 0;
                            
                            while offset < data.len() {
                                let chunk_end = (offset + MAX_TCP_PAYLOAD).min(data.len());
                                let chunk = &data[offset..chunk_end];
                                let is_last = chunk_end == data.len();
                                
                                // PSH only on last fragment, ACK on all
                                let flags = if is_last { 0x18 } else { 0x10 }; // PSH+ACK or just ACK
                                
                                tracing::info!("TCP proxy task: sending chunk len={} with seq={} to {}:{}", 
                                    chunk.len(), seq, 
                                    std::net::Ipv4Addr::from(src_ip), src_port);
                                
                                let packet = Self::build_tcp_packet(
                                    &src_mac, &src_ip, src_port, &dst_ip, dst_port,
                                    seq, ack, flags, chunk,
                                );
                                seq = seq.wrapping_add(chunk.len() as u32);
                                
                                if let Err(e) = response_tx.send(packet).await {
                                    tracing::error!("TCP proxy task: failed to send to response channel: {}", e);
                                    break;
                                }
                                
                                offset = chunk_end;
                            }
                        }
                        Err(e) => {
                            tracing::warn!("TCP proxy task: read error: {}", e);
                            break;
                        }
                    }
                }

                // Data from VM
                Some(data) = rx.recv() => {
                    if data.is_empty() {
                        // FIN received, close the stream
                        tracing::info!("TCP proxy task: VM requested close");
                        break;
                    }
                    
                    let old_ack = ack;
                    ack = ack.wrapping_add(data.len() as u32);
                    tracing::info!("TCP proxy task: forwarding {} bytes to server (ack {} -> {})", data.len(), old_ack, ack);
                    
                    if let Err(e) = stream.write_all(&data).await {
                        tracing::warn!("TCP proxy task: write error: {}", e);
                        break;
                    }
                    // Note: ACK is sent immediately by handle_tcp, not here
                }
            }
        }

        // Clean shutdown
        let _ = stream.shutdown().await;
    }

    /// Build a TCP packet to send to the VM
    fn build_tcp_packet(
        dst_mac: &[u8; 6],
        dst_ip: &[u8; 4],
        dst_port: u16,
        src_ip: &[u8; 4],
        src_port: u16,
        seq: u32,
        ack: u32,
        flags: u8,
        payload: &[u8],
    ) -> Vec<u8> {
        let tcp_len = 20 + payload.len();
        let ip_len = 20 + tcp_len;
        let frame_len = 14 + ip_len;

        let mut frame = vec![0u8; frame_len];

        // Ethernet header
        frame[0..6].copy_from_slice(dst_mac);
        frame[6..12].copy_from_slice(&GATEWAY_MAC);
        frame[12..14].copy_from_slice(&[0x08, 0x00]);

        // IP header
        frame[14] = 0x45;
        frame[15] = 0;
        frame[16..18].copy_from_slice(&(ip_len as u16).to_be_bytes());
        frame[18..20].copy_from_slice(&[0x00, 0x00]); // identification
        frame[20..22].copy_from_slice(&[0x40, 0x00]); // DF flag
        frame[22] = 64; // TTL
        frame[23] = 6;  // TCP
        frame[24..26].copy_from_slice(&[0x00, 0x00]); // checksum placeholder
        frame[26..30].copy_from_slice(src_ip);
        frame[30..34].copy_from_slice(dst_ip);

        // IP checksum
        let ip_checksum = compute_checksum(&frame[14..34]);
        frame[24] = (ip_checksum >> 8) as u8;
        frame[25] = (ip_checksum & 0xff) as u8;

        // TCP header
        let tcp_start = 34;
        frame[tcp_start..tcp_start + 2].copy_from_slice(&src_port.to_be_bytes());
        frame[tcp_start + 2..tcp_start + 4].copy_from_slice(&dst_port.to_be_bytes());
        frame[tcp_start + 4..tcp_start + 8].copy_from_slice(&seq.to_be_bytes());
        frame[tcp_start + 8..tcp_start + 12].copy_from_slice(&ack.to_be_bytes());
        frame[tcp_start + 12] = 0x50; // Data offset = 5 (20 bytes)
        frame[tcp_start + 13] = flags;
        frame[tcp_start + 14..tcp_start + 16].copy_from_slice(&8192u16.to_be_bytes()); // Window
        frame[tcp_start + 16..tcp_start + 18].copy_from_slice(&[0x00, 0x00]); // Checksum placeholder
        frame[tcp_start + 18..tcp_start + 20].copy_from_slice(&[0x00, 0x00]); // Urgent pointer

        // TCP payload
        if !payload.is_empty() {
            frame[tcp_start + 20..].copy_from_slice(payload);
        }

        // TCP checksum (with pseudo-header)
        let tcp_checksum = compute_tcp_checksum(src_ip, dst_ip, &frame[tcp_start..]);
        frame[tcp_start + 16] = (tcp_checksum >> 8) as u8;
        frame[tcp_start + 17] = (tcp_checksum & 0xff) as u8;

        frame
    }

    /// Generate TCP SYN-ACK packet
    fn generate_tcp_synack(
        &self,
        dst_mac: &[u8; 6],
        dst_ip: &[u8; 4],
        dst_port: u16,
        src_ip: &[u8; 4],
        src_port: u16,
        seq: u32,
        ack: u32,
    ) -> Vec<u8> {
        Self::build_tcp_packet(dst_mac, dst_ip, dst_port, src_ip, src_port, seq, ack, 0x12, &[])
    }

    /// Generate TCP RST packet
    fn generate_tcp_rst(
        &self,
        dst_mac: &[u8; 6],
        dst_ip: &[u8; 4],
        dst_port: u16,
        src_ip: &[u8; 4],
        src_port: u16,
        ack: u32,
    ) -> Vec<u8> {
        Self::build_tcp_packet(dst_mac, dst_ip, dst_port, src_ip, src_port, 0, ack.wrapping_add(1), 0x14, &[])
    }

    /// Handle outbound UDP packet
    async fn handle_udp(&self, frame: &[u8]) -> Option<Vec<u8>> {
        if frame.len() < 42 {
            return None;
        }

        let src_mac: [u8; 6] = frame[6..12].try_into().ok()?;
        let src_ip: [u8; 4] = frame[26..30].try_into().ok()?;
        let dst_ip: [u8; 4] = frame[30..34].try_into().ok()?;

        // Get IP header length
        let ihl = ((frame[14] & 0x0f) * 4) as usize;
        let udp_start = 14 + ihl;

        if frame.len() < udp_start + 8 {
            return None;
        }

        let src_port = u16::from_be_bytes([frame[udp_start], frame[udp_start + 1]]);
        let dst_port = u16::from_be_bytes([frame[udp_start + 2], frame[udp_start + 3]]);
        let udp_len = u16::from_be_bytes([frame[udp_start + 4], frame[udp_start + 5]]) as usize;

        let payload_start = udp_start + 8;
        let payload_end = std::cmp::min(udp_start + udp_len, frame.len());

        if payload_start >= payload_end {
            return None;
        }

        let payload = &frame[payload_start..payload_end];
        let dst_addr = Ipv4Addr::from(dst_ip);

        tracing::debug!(
            "UDP proxy: {}:{} -> {}:{} ({} bytes)",
            Ipv4Addr::from(src_ip),
            src_port,
            dst_addr,
            dst_port,
            payload.len()
        );

        // Store session for response matching
        let session = UdpSession {
            src_mac,
            src_ip,
            src_port,
            dst_ip,
            dst_port,
            created: Instant::now(),
        };

        {
            let mut sessions = self.udp_sessions.lock().await;
            sessions.insert((dst_addr, dst_port, src_port), session);
        }

        // Send to external destination
        let socket = self.udp_socket.lock().await;
        if let Some(ref socket) = *socket {
            let dest = SocketAddrV4::new(dst_addr, dst_port);
            match socket.send_to(payload, dest).await {
                Ok(n) => {
                    tracing::debug!("UDP proxy: sent {} bytes to {}", n, dest);
                }
                Err(e) => {
                    tracing::warn!("UDP proxy: send failed: {}", e);
                }
            }
        }

        // For DNS, we need to wait for a response and return it
        // For now, responses are handled asynchronously via handle_incoming_udp
        None
    }

    /// Handle an incoming UDP packet from the external network
    pub async fn handle_incoming_udp(
        &self,
        data: &[u8],
        src_addr: SocketAddr,
        len: usize,
    ) -> Option<Vec<u8>> {
        self.cleanup_expired_sessions().await;

        let src_ip = match src_addr.ip() {
            std::net::IpAddr::V4(ip) => ip,
            _ => return None,
        };
        let src_port = src_addr.port();

        // Find matching session
        let session = {
            let sessions = self.udp_sessions.lock().await;
            // For DNS responses, the source is the DNS server
            // Try to find a session that matches
            let mut found = None;
            for ((dst_ip, dst_port, _vm_port), session) in sessions.iter() {
                // Match by destination (external server) port
                if *dst_port == src_port {
                    // Check if IP matches or if it's DNS (port 53)
                    if *dst_ip == src_ip || src_port == 53 {
                        found = Some(session.clone());
                        break;
                    }
                }
            }
            found
        };

        if let Some(session) = session {
            tracing::debug!(
                "UDP proxy: response from {} -> VM port {}",
                src_addr,
                session.src_port
            );
            Some(self.generate_udp_response(&session, &data[..len]))
        } else {
            tracing::trace!("UDP proxy: no matching session for {}", src_addr);
            None
        }
    }

    /// Generate a UDP response frame to send back to the VM
    fn generate_udp_response(&self, session: &UdpSession, payload: &[u8]) -> Vec<u8> {
        let udp_len = 8 + payload.len();
        let ip_len = 20 + udp_len;
        let frame_len = 14 + ip_len;

        let mut frame = vec![0u8; frame_len];

        // Ethernet header
        frame[0..6].copy_from_slice(&session.src_mac);
        frame[6..12].copy_from_slice(&GATEWAY_MAC);
        frame[12..14].copy_from_slice(&[0x08, 0x00]);

        // IP header
        frame[14] = 0x45;
        frame[15] = 0;
        frame[16..18].copy_from_slice(&(ip_len as u16).to_be_bytes());
        frame[18..20].copy_from_slice(&[0x00, 0x00]); // identification
        frame[20..22].copy_from_slice(&[0x40, 0x00]); // DF flag
        frame[22] = 64; // TTL
        frame[23] = 17; // UDP
        frame[24..26].copy_from_slice(&[0x00, 0x00]); // checksum placeholder
        frame[26..30].copy_from_slice(&session.dst_ip); // src = external server
        frame[30..34].copy_from_slice(&session.src_ip); // dst = VM

        // IP checksum
        let ip_checksum = compute_checksum(&frame[14..34]);
        frame[24] = (ip_checksum >> 8) as u8;
        frame[25] = (ip_checksum & 0xff) as u8;

        // UDP header
        let udp_start = 34;
        frame[udp_start..udp_start + 2].copy_from_slice(&session.dst_port.to_be_bytes());
        frame[udp_start + 2..udp_start + 4].copy_from_slice(&session.src_port.to_be_bytes());
        frame[udp_start + 4..udp_start + 6].copy_from_slice(&(udp_len as u16).to_be_bytes());
        frame[udp_start + 6..udp_start + 8].copy_from_slice(&[0x00, 0x00]); // checksum optional

        // UDP payload
        frame[udp_start + 8..].copy_from_slice(payload);

        frame
    }

    /// Clean up expired sessions
    async fn cleanup_expired_sessions(&self) {
        let mut udp_sessions = self.udp_sessions.lock().await;
        udp_sessions.retain(|_, session| session.created.elapsed() < self.session_timeout);
        drop(udp_sessions);

        let mut tcp_sessions = self.tcp_sessions.lock().await;
        tcp_sessions.retain(|_, session| session.last_activity.elapsed() < self.session_timeout);
    }
}

impl Default for ExternalProxy {
    fn default() -> Self {
        Self::new()
    }
}

/// Compute Internet checksum
fn compute_checksum(data: &[u8]) -> u16 {
    let mut sum: u32 = 0;
    let mut i = 0;
    while i + 1 < data.len() {
        sum += u16::from_be_bytes([data[i], data[i + 1]]) as u32;
        i += 2;
    }
    if i < data.len() {
        sum += (data[i] as u32) << 8;
    }
    while sum > 0xFFFF {
        sum = (sum & 0xFFFF) + (sum >> 16);
    }
    !(sum as u16)
}

/// Compute TCP checksum including pseudo-header
fn compute_tcp_checksum(src_ip: &[u8; 4], dst_ip: &[u8; 4], tcp_segment: &[u8]) -> u16 {
    let mut sum: u32 = 0;

    // Pseudo-header
    sum += u16::from_be_bytes([src_ip[0], src_ip[1]]) as u32;
    sum += u16::from_be_bytes([src_ip[2], src_ip[3]]) as u32;
    sum += u16::from_be_bytes([dst_ip[0], dst_ip[1]]) as u32;
    sum += u16::from_be_bytes([dst_ip[2], dst_ip[3]]) as u32;
    sum += 6u32; // Protocol (TCP)
    sum += tcp_segment.len() as u32;

    // TCP segment
    let mut i = 0;
    while i + 1 < tcp_segment.len() {
        sum += u16::from_be_bytes([tcp_segment[i], tcp_segment[i + 1]]) as u32;
        i += 2;
    }
    if i < tcp_segment.len() {
        sum += (tcp_segment[i] as u32) << 8;
    }

    while sum > 0xFFFF {
        sum = (sum & 0xFFFF) + (sum >> 16);
    }
    !(sum as u16)
}

#[cfg(test)]
mod tests {
    use super::*;

    #[tokio::test]
    async fn test_proxy_creation() {
        let proxy = ExternalProxy::new();
        assert!(proxy.udp_socket().await.is_none());
    }
}
</file>

<file path="relay/.dockerignore">
target/
</file>

<file path="riscv-vm/native/.gitignore">
# Native addon binaries (platform-specific, generated by napi build)
*.node

# Keep index.js, index.d.ts, and index.mjs - they are needed for the package
</file>

<file path="riscv-vm/native/.npmignore">
# Empty .npmignore to override .gitignore
# This ensures .node files are included in the npm package
# (they are excluded from git but should be included in npm)
</file>

<file path="riscv-vm/native/index.d.ts">
/* tslint:disable */
/* eslint-disable */

/* auto-generated by NAPI-RS */

/** Connection status for JavaScript */
export const enum ConnectionStatus {
  Disconnected = 0,
  Connecting = 1,
  Connected = 2,
  Error = 3
}
/**
 * WebTransport client for Node.js.
 *
 * This class provides WebTransport connectivity using the same implementation
 * as the native Rust VM. It maintains a persistent connection with automatic
 * reconnection and heartbeat handling.
 */
export declare class WebTransportClient {
  /**
   * Create a new WebTransport client and start connecting.
   *
   * @param url - WebTransport server URL (e.g., "https://localhost:4433")
   * @param certHash - Optional certificate hash for self-signed certs (hex string)
   */
  constructor(url: string, certHash?: string | undefined | null)
  /** Check if connected to the relay server. */
  isConnected(): boolean
  /** Check if registered with the relay (IP assigned). */
  isRegistered(): boolean
  /** Get current connection status. */
  status(): ConnectionStatus
  /** Get the MAC address as a hex string. */
  macAddress(): string
  /** Get the MAC address as a byte array. */
  macBytes(): Array<number>
  /** Get the assigned IP address (if any) as a string. */
  assignedIp(): string | null
  /** Get the assigned IP address as bytes (if any). */
  assignedIpBytes(): Array<number> | null
  /** Get the number of connection attempts. */
  connectionAttempts(): number
  /**
   * Send an Ethernet frame to the relay.
   * Returns true if sent successfully, false if not connected.
   */
  send(data: Buffer): boolean
  /**
   * Receive an Ethernet frame from the relay (non-blocking).
   * Returns the frame data or undefined if no frame available.
   */
  recv(): Buffer | null
  /**
   * Receive all pending Ethernet frames (non-blocking).
   * Returns an array of frame buffers.
   */
  recvAll(): Array<Buffer>
  /** Shut down the connection and cleanup. */
  shutdown(): void
}
</file>

<file path="riscv-vm/native/index.js">
/* tslint:disable */
/* eslint-disable */
/* prettier-ignore */

/**
 * Native bindings loader for riscv-vm
 * 
 * This module detects the current platform and loads the appropriate
 * pre-built native binary. All binaries are bundled in this package.
 * 
 * Supported platforms:
 * - darwin-x64 (macOS Intel)
 * - darwin-arm64 (macOS Apple Silicon)
 * - linux-x64-gnu (Linux x64 glibc)
 * - linux-x64-musl (Linux x64 musl/Alpine)
 * - linux-arm64-gnu (Linux ARM64 glibc)
 * - linux-arm64-musl (Linux ARM64 musl/Alpine)
 * - win32-x64-msvc (Windows x64)
 */

const { existsSync, readFileSync } = require('fs')
const { join } = require('path')

const { platform, arch } = process

let nativeBinding = null
let loadError = null

/**
 * Detect if running on musl libc (Alpine Linux, etc.)
 */
function isMusl() {
  if (!process.report || typeof process.report.getReport !== 'function') {
    try {
      const lddPath = require('child_process').execSync('which ldd').toString().trim()
      return readFileSync(lddPath, 'utf8').includes('musl')
    } catch (e) {
      return true
    }
  } else {
    const { glibcVersionRuntime } = process.report.getReport().header
    return !glibcVersionRuntime
  }
}

/**
 * Load a native binding from the native directory
 */
function loadNativeBinding(filename) {
  const filepath = join(__dirname, filename)
  if (!existsSync(filepath)) {
    throw new Error(
      `Native binding not found: ${filename}\n` +
      `Expected at: ${filepath}\n` +
      `Platform: ${platform}, Architecture: ${arch}\n\n` +
      `This platform may not be supported, or the package was not installed correctly.\n` +
      `Try reinstalling the package: npm install virtual-machine`
    )
  }
  return require(filepath)
}

/**
 * Determine the correct native binding filename for the current platform
 */
function getNativeBindingFilename() {
  switch (platform) {
    case 'darwin':
      switch (arch) {
        case 'x64':
          return 'riscv-vm-native.darwin-x64.node'
        case 'arm64':
          return 'riscv-vm-native.darwin-arm64.node'
        default:
          throw new Error(`Unsupported architecture on macOS: ${arch}`)
      }

    case 'linux':
      const musl = isMusl()
      switch (arch) {
        case 'x64':
          return musl 
            ? 'riscv-vm-native.linux-x64-musl.node'
            : 'riscv-vm-native.linux-x64-gnu.node'
        case 'arm64':
          return musl
            ? 'riscv-vm-native.linux-arm64-musl.node'
            : 'riscv-vm-native.linux-arm64-gnu.node'
        default:
          throw new Error(`Unsupported architecture on Linux: ${arch}`)
      }

    case 'win32':
      switch (arch) {
        case 'x64':
          return 'riscv-vm-native.win32-x64-msvc.node'
        default:
          throw new Error(`Unsupported architecture on Windows: ${arch}`)
      }

    default:
      throw new Error(`Unsupported platform: ${platform}`)
  }
}

// Load the native binding
try {
  const filename = getNativeBindingFilename()
  nativeBinding = loadNativeBinding(filename)
} catch (e) {
  loadError = e
}

if (!nativeBinding) {
  if (loadError) {
    throw loadError
  }
  throw new Error('Failed to load native binding')
}

// Export the native binding APIs
const { ConnectionStatus, WebTransportClient } = nativeBinding

module.exports.ConnectionStatus = ConnectionStatus
module.exports.WebTransportClient = WebTransportClient
</file>

<file path="riscv-vm/native/index.mjs">
/**
 * ESM wrapper for native addon.
 */
import { createRequire } from 'module';
const require = createRequire(import.meta.url);
const native = require('./index.js');

export const { ConnectionStatus, WebTransportClient } = native;
</file>

<file path="riscv-vm/src/console.rs">
//! Non-blocking console I/O for native builds.

#![cfg(not(target_arch = "wasm32"))]

use std::io::{self, Read, Write};
use std::sync::mpsc::{self, Receiver, TryRecvError};
use std::thread::{self, JoinHandle};

/// Non-blocking console input handler.
/// 
/// Spawns a background thread that reads from stdin
/// and makes bytes available via `try_read()`.
pub struct Console {
    rx: Receiver<u8>,
    _handle: Option<JoinHandle<()>>,
}

impl Console {
    /// Create a new console with a background input thread.
    pub fn new() -> Self {
        let (tx, rx) = mpsc::channel();

        let handle = thread::Builder::new()
            .name("console-input".to_string())
            .spawn(move || {
                let stdin = io::stdin();
                let mut buffer = [0u8; 1];
                
                // Set terminal to raw mode
                #[cfg(unix)]
                let _raw_guard = RawModeGuard::new();
                
                loop {
                    match stdin.lock().read(&mut buffer) {
                        Ok(1) => {
                            if tx.send(buffer[0]).is_err() {
                                // Receiver dropped, exit
                                break;
                            }
                        }
                        Ok(0) => {
                            // EOF
                            break;
                        }
                        Err(e) => {
                            if e.kind() != io::ErrorKind::Interrupted {
                                break;
                            }
                        }
                        _ => {}
                    }
                }
            })
            .expect("Failed to spawn console thread");

        Self { rx, _handle: Some(handle) }
    }

    /// Try to read a byte from stdin (non-blocking).
    /// 
    /// Returns `Some(byte)` if input is available, `None` otherwise.
    pub fn try_read(&self) -> Option<u8> {
        match self.rx.try_recv() {
            Ok(byte) => Some(byte),
            Err(TryRecvError::Empty) => None,
            Err(TryRecvError::Disconnected) => None,
        }
    }

    /// Read all available input bytes.
    pub fn read_available(&self) -> Vec<u8> {
        let mut bytes = Vec::new();
        while let Some(byte) = self.try_read() {
            bytes.push(byte);
        }
        bytes
    }

    /// Alias for try_read() for backwards compatibility.
    pub fn poll(&self) -> Option<u8> {
        self.try_read()
    }
}

impl Drop for Console {
    fn drop(&mut self) {
        // Thread will exit when channel is dropped
        // We don't explicitly join because stdin.read() blocks
    }
}

impl Default for Console {
    fn default() -> Self {
        Self::new()
    }
}

/// RAII guard for Unix raw terminal mode.
#[cfg(unix)]
struct RawModeGuard {
    original: libc::termios,
}

#[cfg(unix)]
impl RawModeGuard {
    fn new() -> Self {
        use std::os::unix::io::AsRawFd;
        use std::mem::MaybeUninit;
        
        let fd = io::stdin().as_raw_fd();
        let mut original = MaybeUninit::<libc::termios>::uninit();
        
        unsafe {
            libc::tcgetattr(fd, original.as_mut_ptr());
            let original = original.assume_init();
            
            let mut raw = original;
            // Disable canonical mode and echo
            raw.c_lflag &= !(libc::ICANON | libc::ECHO);
            // Read returns after 1 byte
            raw.c_cc[libc::VMIN] = 1;
            raw.c_cc[libc::VTIME] = 0;
            
            libc::tcsetattr(fd, libc::TCSANOW, &raw);
            
            Self { original }
        }
    }
}

#[cfg(unix)]
impl Drop for RawModeGuard {
    fn drop(&mut self) {
        use std::os::unix::io::AsRawFd;
        let fd = io::stdin().as_raw_fd();
        unsafe {
            libc::tcsetattr(fd, libc::TCSANOW, &self.original);
        }
        // Flush any pending output
        let _ = io::stdout().flush();
    }
}

// Windows stub
#[cfg(windows)]
struct RawModeGuard;

#[cfg(windows)]
impl RawModeGuard {
    fn new() -> Self {
        // TODO: Implement Windows console mode using SetConsoleMode
        Self
    }
}
</file>

<file path="riscv-vm/src/napi_bindings.rs">
//! Node.js native addon bindings via napi-rs.
//!
//! This module exposes WebTransport client functionality to Node.js,
//! reusing the existing native WebTransport implementation.

use napi_derive::napi;
use napi_rs::bindgen_prelude::*;

// Re-export napi for the macro to find
use napi_rs as napi;
use std::sync::atomic::{AtomicBool, AtomicU32, Ordering};
use std::sync::mpsc::{channel, Receiver, Sender, TryRecvError};
use std::sync::{Arc, Mutex};
use std::thread;
use std::time::Duration;
use tokio::runtime::Runtime;
use wtransport::tls::Sha256Digest;
use wtransport::ClientConfig;
use wtransport::Endpoint;

/// Message type prefix for control messages
const MSG_TYPE_CONTROL: u8 = 0x00;
/// Message type prefix for Ethernet data frames  
const MSG_TYPE_DATA: u8 = 0x01;

/// Heartbeat interval in seconds
const HEARTBEAT_INTERVAL_SECS: u64 = 15;

/// QUIC keep-alive interval in seconds
const QUIC_KEEP_ALIVE_SECS: u64 = 10;

/// Maximum reconnection delay in seconds
const MAX_RECONNECT_DELAY_SECS: u64 = 30;

/// Initial reconnection delay in seconds
const INITIAL_RECONNECT_DELAY_SECS: u64 = 2;

/// Control message for registration
fn make_register_message(mac: &[u8; 6]) -> Vec<u8> {
    let json = format!(
        r#"{{"type":"Register","mac":[{},{},{},{},{},{}]}}"#,
        mac[0], mac[1], mac[2], mac[3], mac[4], mac[5]
    );
    let mut msg = Vec::with_capacity(1 + json.len());
    msg.push(MSG_TYPE_CONTROL);
    msg.extend(json.bytes());
    msg
}

/// Control message for heartbeat
fn make_heartbeat_message() -> Vec<u8> {
    let json = r#"{"type":"Heartbeat"}"#;
    let mut msg = Vec::with_capacity(1 + json.len());
    msg.push(MSG_TYPE_CONTROL);
    msg.extend(json.bytes());
    msg
}

/// Encode an Ethernet frame with the data prefix
fn encode_data_frame(ethernet_frame: &[u8]) -> Vec<u8> {
    let mut frame = Vec::with_capacity(1 + ethernet_frame.len());
    frame.push(MSG_TYPE_DATA);
    frame.extend(ethernet_frame);
    frame
}

/// Decode a received message, stripping the type prefix for data frames
fn decode_message(data: &[u8]) -> Option<Vec<u8>> {
    if data.is_empty() {
        return None;
    }

    match data[0] {
        MSG_TYPE_DATA => {
            // Return the Ethernet frame without the prefix
            Some(data[1..].to_vec())
        }
        MSG_TYPE_CONTROL => {
            // Control messages are handled internally
            if let Ok(json_str) = std::str::from_utf8(&data[1..]) {
                if json_str.contains("\"type\":\"Assigned\"") {
                    log::info!("[WebTransport] Received IP assignment: {}", json_str);
                } else if json_str.contains("\"type\":\"HeartbeatAck\"") {
                    log::trace!("[WebTransport] Heartbeat acknowledged");
                } else if json_str.contains("\"type\":\"Error\"") {
                    log::error!("[WebTransport] Error from relay: {}", json_str);
                }
            }
            None
        }
        _ => {
            log::warn!("[WebTransport] Unknown message type: {}", data[0]);
            None
        }
    }
}

/// Parse IP address from JSON string containing "ip":[a,b,c,d]
fn parse_ip_from_json(json_str: &str) -> Option<[u8; 4]> {
    let start_marker = "\"ip\":[";
    if let Some(start) = json_str.find(start_marker) {
        let rest = &json_str[start + start_marker.len()..];
        if let Some(end) = rest.find(']') {
            let ip_str = &rest[..end];
            let parts: Vec<&str> = ip_str.split(',').collect();
            if parts.len() == 4 {
                let b0 = parts[0].trim().parse().ok()?;
                let b1 = parts[1].trim().parse().ok()?;
                let b2 = parts[2].trim().parse().ok()?;
                let b3 = parts[3].trim().parse().ok()?;
                return Some([b0, b1, b2, b3]);
            }
        }
    }
    None
}

/// Connection status for JavaScript
#[napi]
pub enum ConnectionStatus {
    Disconnected,
    Connecting,
    Connected,
    Error,
}

/// WebTransport client for Node.js.
/// 
/// This class provides WebTransport connectivity using the same implementation
/// as the native Rust VM. It maintains a persistent connection with automatic
/// reconnection and heartbeat handling.
#[napi]
pub struct WebTransportClient {
    tx_to_transport: Option<Sender<Vec<u8>>>,
    rx_from_transport: Option<Receiver<Vec<u8>>>,
    mac: [u8; 6],
    registered: Arc<AtomicBool>,
    assigned_ip: Arc<Mutex<Option<[u8; 4]>>>,
    connection_attempts: Arc<AtomicU32>,
    connected: Arc<AtomicBool>,
    shutdown: Arc<AtomicBool>,
}

#[napi]
impl WebTransportClient {
    /// Create a new WebTransport client and start connecting.
    ///
    /// @param url - WebTransport server URL (e.g., "https://localhost:4433")
    /// @param certHash - Optional certificate hash for self-signed certs (hex string)
    #[napi(constructor)]
    pub fn new(url: String, cert_hash: Option<String>) -> Self {
        // Initialize env_logger if not already done
        let _ = env_logger::try_init();

        log::info!("[WebTransport] Creating client for URL: {}", url);

        // Generate a random MAC address
        let now = std::time::SystemTime::now()
            .duration_since(std::time::UNIX_EPOCH)
            .unwrap_or_default();
        let nanos = now.as_nanos() as u64;
        let pid = std::process::id() as u64;
        let url_hash: u64 = url
            .bytes()
            .fold(0u64, |acc, b| acc.wrapping_mul(31).wrapping_add(b as u64));
        let seed = nanos ^ (pid << 32) ^ url_hash;

        let mut mac = [0x52, 0x54, 0x00, 0x00, 0x00, 0x00];
        mac[2] = ((seed >> 40) & 0xff) as u8;
        mac[3] = ((seed >> 32) & 0xff) as u8;
        mac[4] = ((seed >> 16) & 0xff) as u8;
        mac[5] = (seed & 0xff) as u8;

        let (tx_to_transport, rx_to_transport) = channel::<Vec<u8>>();
        let (tx_from_transport, rx_from_transport) = channel::<Vec<u8>>();

        let mac_copy = mac;
        let registered = Arc::new(AtomicBool::new(false));
        let registered_clone = registered.clone();
        let assigned_ip = Arc::new(Mutex::new(None));
        let assigned_ip_clone = assigned_ip.clone();
        let connection_attempts = Arc::new(AtomicU32::new(0));
        let connection_attempts_clone = connection_attempts.clone();
        let connected = Arc::new(AtomicBool::new(false));
        let connected_clone = connected.clone();
        let shutdown = Arc::new(AtomicBool::new(false));
        let shutdown_clone = shutdown.clone();

        thread::spawn(move || {
            let rt = Runtime::new().unwrap();
            rt.block_on(async move {
                // Parse cert hash once
                let cert_digest = if let Some(hash_str) = &cert_hash {
                    log::info!("[WebTransport] Using certificate hash: {}", hash_str);
                    let bytes = match hex::decode(hash_str.replace(":", "")) {
                        Ok(b) => b,
                        Err(e) => {
                            log::error!("[WebTransport] Invalid hex hash: {}", e);
                            return;
                        }
                    };
                    let bytes_len = bytes.len();
                    let array: [u8; 32] = match bytes.try_into() {
                        Ok(a) => a,
                        Err(_) => {
                            log::error!(
                                "[WebTransport] Hash must be 32 bytes, got {} bytes",
                                bytes_len
                            );
                            return;
                        }
                    };
                    Some(Sha256Digest::from(array))
                } else {
                    log::warn!("[WebTransport] No certificate hash provided, disabling cert validation");
                    None
                };

                let mut reconnect_delay = INITIAL_RECONNECT_DELAY_SECS;

                // Reconnection loop
                loop {
                    // Check for shutdown
                    if shutdown_clone.load(Ordering::SeqCst) {
                        log::info!("[WebTransport] Shutdown requested, exiting");
                        break;
                    }

                    let attempt = connection_attempts_clone.fetch_add(1, Ordering::SeqCst) + 1;

                    if attempt > 1 {
                        log::info!(
                            "[WebTransport] Reconnection attempt {} (delay was {}s)...",
                            attempt,
                            reconnect_delay
                        );
                    } else {
                        log::info!("[WebTransport] Starting connection to {}...", url);
                    }

                    // Reset state
                    registered_clone.store(false, Ordering::SeqCst);
                    connected_clone.store(false, Ordering::SeqCst);

                    // Build config
                    let config = if let Some(ref digest) = cert_digest {
                        ClientConfig::builder()
                            .with_bind_default()
                            .with_server_certificate_hashes(vec![digest.clone()])
                            .keep_alive_interval(Some(Duration::from_secs(QUIC_KEEP_ALIVE_SECS)))
                            .build()
                    } else {
                        ClientConfig::builder()
                            .with_bind_default()
                            .with_no_cert_validation()
                            .keep_alive_interval(Some(Duration::from_secs(QUIC_KEEP_ALIVE_SECS)))
                            .build()
                    };

                    let endpoint = match Endpoint::client(config) {
                        Ok(ep) => ep,
                        Err(e) => {
                            log::error!("[WebTransport] Failed to provision endpoint: {}", e);
                            tokio::time::sleep(Duration::from_secs(reconnect_delay)).await;
                            reconnect_delay = (reconnect_delay * 2).min(MAX_RECONNECT_DELAY_SECS);
                            continue;
                        }
                    };

                    log::info!("[WebTransport] Connecting to {}...", url);
                    let connection = match endpoint.connect(&url).await {
                        Ok(conn) => {
                            reconnect_delay = INITIAL_RECONNECT_DELAY_SECS;
                            conn
                        }
                        Err(e) => {
                            log::error!("[WebTransport] Connection failed: {}", e);
                            tokio::time::sleep(Duration::from_secs(reconnect_delay)).await;
                            reconnect_delay = (reconnect_delay * 2).min(MAX_RECONNECT_DELAY_SECS);
                            continue;
                        }
                    };

                    log::info!("[WebTransport] Connected successfully!");
                    connected_clone.store(true, Ordering::SeqCst);

                    // Send registration
                    let register_msg = make_register_message(&mac_copy);
                    if let Err(e) = connection.send_datagram(register_msg) {
                        log::error!("[WebTransport] Failed to send registration: {}", e);
                        connected_clone.store(false, Ordering::SeqCst);
                        tokio::time::sleep(Duration::from_secs(reconnect_delay)).await;
                        reconnect_delay = (reconnect_delay * 2).min(MAX_RECONNECT_DELAY_SECS);
                        continue;
                    }

                    log::info!(
                        "[WebTransport] Registration sent, MAC: {:02x}:{:02x}:{:02x}:{:02x}:{:02x}:{:02x}",
                        mac_copy[0], mac_copy[1], mac_copy[2], mac_copy[3], mac_copy[4], mac_copy[5]
                    );

                    let connection = Arc::new(connection);

                    // Combined send/receive/heartbeat loop
                    let mut heartbeat_interval =
                        tokio::time::interval(Duration::from_secs(HEARTBEAT_INTERVAL_SECS));
                    let mut send_check_interval = tokio::time::interval(Duration::from_millis(1));

                    'connection_loop: loop {
                        // Check for shutdown
                        if shutdown_clone.load(Ordering::SeqCst) {
                            log::info!("[WebTransport] Shutdown requested during connection");
                            return;
                        }

                        tokio::select! {
                            // Check for data to send
                            _ = send_check_interval.tick() => {
                                loop {
                                    match rx_to_transport.try_recv() {
                                        Ok(data) => {
                                            if let Err(e) = connection.send_datagram(data) {
                                                log::error!("Failed to send datagram: {}", e);
                                                break 'connection_loop;
                                            }
                                        }
                                        Err(TryRecvError::Empty) => break,
                                        Err(TryRecvError::Disconnected) => {
                                            log::warn!("[WebTransport] TX channel disconnected");
                                            return;
                                        }
                                    }
                                }
                            }

                            // Send heartbeats
                            _ = heartbeat_interval.tick() => {
                                let heartbeat = make_heartbeat_message();
                                if let Err(e) = connection.send_datagram(heartbeat) {
                                    log::warn!("[WebTransport] Failed to send heartbeat: {}", e);
                                    break 'connection_loop;
                                }
                                log::trace!("[WebTransport] Heartbeat sent");
                            }

                            // Receive data
                            result = connection.receive_datagram() => {
                                match result {
                                    Ok(datagram) => {
                                        let data = datagram.to_vec();

                                        // Handle Assigned message
                                        if !data.is_empty() && data[0] == MSG_TYPE_CONTROL {
                                            if let Ok(json_str) = std::str::from_utf8(&data[1..]) {
                                                if json_str.contains("\"type\":\"Assigned\"") {
                                                    registered_clone.store(true, Ordering::SeqCst);

                                                    if let Some(ip) = parse_ip_from_json(json_str) {
                                                        if let Ok(mut guard) = assigned_ip_clone.lock() {
                                                            *guard = Some(ip);
                                                        }
                                                        log::info!(
                                                            "[WebTransport] IP Assigned: {}.{}.{}.{}",
                                                            ip[0], ip[1], ip[2], ip[3]
                                                        );
                                                    }

                                                    log::info!(
                                                        "[WebTransport] Registered with relay: {}",
                                                        json_str
                                                    );
                                                }
                                            }
                                        }

                                        // Forward Ethernet frames
                                        if let Some(ethernet_frame) = decode_message(&data) {
                                            let _ = tx_from_transport.send(ethernet_frame);
                                        }
                                    }
                                    Err(e) => {
                                        log::warn!("[WebTransport] Connection lost: {}", e);
                                        break 'connection_loop;
                                    }
                                }
                            }
                        }
                    }

                    // Connection lost
                    connected_clone.store(false, Ordering::SeqCst);
                    log::info!(
                        "[WebTransport] Scheduling reconnection in {}s...",
                        reconnect_delay
                    );
                    tokio::time::sleep(Duration::from_secs(reconnect_delay)).await;
                    reconnect_delay = (reconnect_delay * 2).min(MAX_RECONNECT_DELAY_SECS);
                }
            });
        });

        Self {
            tx_to_transport: Some(tx_to_transport),
            rx_from_transport: Some(rx_from_transport),
            mac,
            registered,
            assigned_ip,
            connection_attempts,
            connected,
            shutdown,
        }
    }

    /// Check if connected to the relay server.
    #[napi]
    pub fn is_connected(&self) -> bool {
        self.connected.load(Ordering::SeqCst)
    }

    /// Check if registered with the relay (IP assigned).
    #[napi]
    pub fn is_registered(&self) -> bool {
        self.registered.load(Ordering::SeqCst)
    }

    /// Get current connection status.
    #[napi]
    pub fn status(&self) -> ConnectionStatus {
        if self.registered.load(Ordering::SeqCst) {
            ConnectionStatus::Connected
        } else if self.connected.load(Ordering::SeqCst) {
            ConnectionStatus::Connecting
        } else {
            ConnectionStatus::Disconnected
        }
    }

    /// Get the MAC address as a hex string.
    #[napi]
    pub fn mac_address(&self) -> String {
        format!(
            "{:02x}:{:02x}:{:02x}:{:02x}:{:02x}:{:02x}",
            self.mac[0], self.mac[1], self.mac[2], self.mac[3], self.mac[4], self.mac[5]
        )
    }

    /// Get the MAC address as a byte array.
    #[napi]
    pub fn mac_bytes(&self) -> Vec<u8> {
        self.mac.to_vec()
    }

    /// Get the assigned IP address (if any) as a string.
    #[napi]
    pub fn assigned_ip(&self) -> Option<String> {
        if let Ok(guard) = self.assigned_ip.lock() {
            guard.map(|ip| format!("{}.{}.{}.{}", ip[0], ip[1], ip[2], ip[3]))
        } else {
            None
        }
    }

    /// Get the assigned IP address as bytes (if any).
    #[napi]
    pub fn assigned_ip_bytes(&self) -> Option<Vec<u8>> {
        if let Ok(guard) = self.assigned_ip.lock() {
            guard.map(|ip| ip.to_vec())
        } else {
            None
        }
    }

    /// Get the number of connection attempts.
    #[napi]
    pub fn connection_attempts(&self) -> u32 {
        self.connection_attempts.load(Ordering::SeqCst)
    }

    /// Send an Ethernet frame to the relay.
    /// Returns true if sent successfully, false if not connected.
    #[napi]
    pub fn send(&self, data: Buffer) -> bool {
        if let Some(tx) = &self.tx_to_transport {
            let framed = encode_data_frame(&data);
            tx.send(framed).is_ok()
        } else {
            false
        }
    }

    /// Receive an Ethernet frame from the relay (non-blocking).
    /// Returns the frame data or undefined if no frame available.
    #[napi]
    pub fn recv(&self) -> Option<Buffer> {
        if let Some(rx) = &self.rx_from_transport {
            match rx.try_recv() {
                Ok(data) => Some(Buffer::from(data)),
                Err(_) => None,
            }
        } else {
            None
        }
    }

    /// Receive all pending Ethernet frames (non-blocking).
    /// Returns an array of frame buffers.
    #[napi]
    pub fn recv_all(&self) -> Vec<Buffer> {
        let mut frames = Vec::new();
        if let Some(rx) = &self.rx_from_transport {
            loop {
                match rx.try_recv() {
                    Ok(data) => frames.push(Buffer::from(data)),
                    Err(_) => break,
                }
            }
        }
        frames
    }

    /// Shut down the connection and cleanup.
    #[napi]
    pub fn shutdown(&self) {
        self.shutdown.store(true, Ordering::SeqCst);
        log::info!("[WebTransport] Shutdown signaled");
    }
}
</file>

<file path="riscv-vm/src/net_async.rs">
//! Async network backend wrapper for VirtIO networking.
//!
//! This module provides `AsyncNetworkBackend`, which wraps any `NetworkBackend`
//! implementation and provides non-blocking I/O through a dedicated I/O thread
//! and channel-based communication.
//!
//! Benefits:
//! - Non-blocking `try_receive()` for polling without waiting
//! - Non-blocking `send()` that queues packets for async transmission
//! - Lower latency: packets are queued by I/O thread while CPU runs
//! - Better throughput: batched processing of multiple packets

use std::sync::mpsc::{channel, Receiver, Sender, TryRecvError};
use std::sync::atomic::{AtomicBool, Ordering};
use std::sync::Arc;
use std::thread::{self, JoinHandle};
use std::time::Duration;

use crate::net::NetworkBackend;

/// Async wrapper around NetworkBackend.
///
/// Uses a dedicated thread for network I/O, communicating via channels.
/// This allows the main emulation loop to poll for packets without blocking.
pub struct AsyncNetworkBackend {
    /// Receive channel for incoming packets
    rx: Receiver<Vec<u8>>,

    /// Send channel for outgoing packets
    tx: Sender<Vec<u8>>,

    /// Handle to the I/O thread
    _io_thread: JoinHandle<()>,

    /// Shutdown signal
    shutdown: Arc<AtomicBool>,

    /// MAC address (cached from underlying backend)
    mac: [u8; 6],

    /// Assigned IP address (updated from I/O thread)
    assigned_ip: Arc<std::sync::Mutex<Option<[u8; 4]>>>,
}

impl AsyncNetworkBackend {
    /// Create a new async backend wrapping the given underlying backend.
    ///
    /// This spawns a dedicated I/O thread that handles all blocking network
    /// operations, communicating with the main thread via channels.
    pub fn new(mut backend: Box<dyn NetworkBackend>) -> Self {
        // Get MAC before moving backend to I/O thread
        let mac = backend.mac_address();

        // Initialize the backend
        if let Err(e) = backend.init() {
            log::error!("[AsyncNetworkBackend] Failed to initialize backend: {}", e);
        }

        let (tx_to_net, rx_from_vm) = channel::<Vec<u8>>();
        let (tx_to_vm, rx_from_net) = channel::<Vec<u8>>();
        let shutdown = Arc::new(AtomicBool::new(false));
        let shutdown_clone = Arc::clone(&shutdown);
        let assigned_ip = Arc::new(std::sync::Mutex::new(None));
        let assigned_ip_clone = Arc::clone(&assigned_ip);

        let io_thread = thread::Builder::new()
            .name("virtio-net-io".to_string())
            .spawn(move || {
                Self::io_loop(backend, rx_from_vm, tx_to_vm, shutdown_clone, assigned_ip_clone);
            })
            .expect("Failed to spawn network I/O thread");

        Self {
            rx: rx_from_net,
            tx: tx_to_net,
            _io_thread: io_thread,
            shutdown,
            mac,
            assigned_ip,
        }
    }

    /// I/O thread main loop.
    ///
    /// This thread handles all blocking network operations:
    /// - Polls the backend for incoming packets (with timeout)
    /// - Sends queued outgoing packets
    fn io_loop(
        mut backend: Box<dyn NetworkBackend>,
        rx_from_vm: Receiver<Vec<u8>>,
        tx_to_vm: Sender<Vec<u8>>,
        shutdown: Arc<AtomicBool>,
        assigned_ip: Arc<std::sync::Mutex<Option<[u8; 4]>>>,
    ) {
        log::debug!("[AsyncNetworkBackend] I/O thread started");

        loop {
            if shutdown.load(Ordering::Relaxed) {
                log::debug!("[AsyncNetworkBackend] I/O thread shutting down");
                break;
            }

            // Check for outgoing packets (non-blocking)
            loop {
                match rx_from_vm.try_recv() {
                    Ok(packet) => {
                        if let Err(e) = backend.send(&packet) {
                            log::warn!("[AsyncNetworkBackend] Send error: {}", e);
                        }
                    }
                    Err(TryRecvError::Empty) => break,
                    Err(TryRecvError::Disconnected) => {
                        log::debug!("[AsyncNetworkBackend] TX channel disconnected");
                        return;
                    }
                }
            }

            // Check for incoming packets (with timeout to allow shutdown checks)
            match backend.receive_timeout(Duration::from_millis(10)) {
                Ok(Some(packet)) => {
                    log::trace!("[AsyncNetworkBackend] Received {} byte packet", packet.len());
                    if tx_to_vm.send(packet).is_err() {
                        log::debug!("[AsyncNetworkBackend] RX channel disconnected");
                        break;
                    }
                }
                Ok(None) => {
                    // No packet available, continue polling
                }
                Err(e) => {
                    log::warn!("[AsyncNetworkBackend] Receive error: {}", e);
                }
            }

            // Update assigned IP (for relay-based networking)
            if let Some(ip) = backend.get_assigned_ip() {
                let mut guard = assigned_ip.lock().unwrap();
                if guard.is_none() {
                    log::info!(
                        "[AsyncNetworkBackend] IP assigned: {}.{}.{}.{}",
                        ip[0], ip[1], ip[2], ip[3]
                    );
                    *guard = Some(ip);
                }
            }
        }
    }

    /// Non-blocking receive.
    ///
    /// Returns the next available packet, or `None` if no packets are queued.
    /// This never blocks - packets are pre-fetched by the I/O thread.
    #[inline]
    pub fn try_receive(&self) -> Option<Vec<u8>> {
        self.rx.try_recv().ok()
    }

    /// Queue packet for sending.
    ///
    /// This is non-blocking - the packet is queued and the I/O thread will
    /// send it asynchronously. If the queue is full, the packet is dropped
    /// (similar to real network behavior under load).
    #[inline]
    pub fn send(&self, packet: Vec<u8>) {
        // Use send() which blocks if channel is full - but with unbounded channel
        // this won't happen in practice. For bounded channels, consider try_send().
        let _ = self.tx.send(packet);
    }

    /// Get the MAC address.
    #[inline]
    pub fn mac_address(&self) -> [u8; 6] {
        self.mac
    }

    /// Get the assigned IP address (if any).
    ///
    /// For relay-based networking, the relay assigns an IP to each client.
    /// Returns `None` until the IP is assigned.
    pub fn get_assigned_ip(&self) -> Option<[u8; 4]> {
        self.assigned_ip.lock().unwrap().clone()
    }
}

impl Drop for AsyncNetworkBackend {
    fn drop(&mut self) {
        log::debug!("[AsyncNetworkBackend] Shutting down");
        self.shutdown.store(true, Ordering::Release);
        // The I/O thread will exit on next iteration when it sees the shutdown flag
    }
}

/// Implement NetworkBackend trait so AsyncNetworkBackend can be used transparently
/// with VirtioNet. All operations are non-blocking.
impl NetworkBackend for AsyncNetworkBackend {
    fn init(&mut self) -> Result<(), String> {
        // Backend is already initialized in new()
        Ok(())
    }

    fn recv(&mut self) -> Result<Option<Vec<u8>>, String> {
        // Non-blocking receive via channel
        Ok(self.try_receive())
    }

    fn send(&self, buf: &[u8]) -> Result<(), String> {
        // Non-blocking send via channel
        self.send(buf.to_vec());
        Ok(())
    }

    fn mac_address(&self) -> [u8; 6] {
        self.mac
    }

    fn get_assigned_ip(&self) -> Option<[u8; 4]> {
        self.assigned_ip.lock().unwrap().clone()
    }

    fn receive_timeout(&mut self, timeout: Duration) -> Result<Option<Vec<u8>>, String> {
        // Use recv_timeout on the channel for timeout support
        match self.rx.recv_timeout(timeout) {
            Ok(packet) => Ok(Some(packet)),
            Err(std::sync::mpsc::RecvTimeoutError::Timeout) => Ok(None),
            Err(std::sync::mpsc::RecvTimeoutError::Disconnected) => {
                Err("Channel disconnected".to_string())
            }
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::net::DummyBackend;

    #[test]
    fn test_async_backend_creation() {
        let backend = Box::new(DummyBackend::new());
        let async_backend = AsyncNetworkBackend::new(backend);

        // Should get the MAC from the underlying backend
        let mac = async_backend.mac_address();
        assert_eq!(mac[0] & 0x02, 0x02); // Locally administered bit set
    }

    #[test]
    fn test_async_backend_try_receive_empty() {
        let backend = Box::new(DummyBackend::new());
        let async_backend = AsyncNetworkBackend::new(backend);

        // DummyBackend never receives packets, so try_receive should return None
        assert!(async_backend.try_receive().is_none());
    }

    #[test]
    fn test_async_backend_send() {
        let backend = Box::new(DummyBackend::new());
        let async_backend = AsyncNetworkBackend::new(backend);

        // Send should not panic or block
        async_backend.send(vec![0x00, 0x01, 0x02, 0x03]);

        // Give the I/O thread time to process
        std::thread::sleep(Duration::from_millis(50));
    }

    #[test]
    fn test_async_backend_shutdown() {
        let backend = Box::new(DummyBackend::new());
        let async_backend = AsyncNetworkBackend::new(backend);

        // Drop should trigger clean shutdown
        drop(async_backend);

        // If we get here without hanging, the test passes
    }
}
</file>

<file path="riscv-vm/src/net_external.rs">
//! External network backend for Node.js native addon bridging.
//!
//! This backend allows JavaScript code to inject/extract packets directly,
//! enabling the use of native Node.js WebTransport addon with the WASM VM.

use crate::net::NetworkBackend;
use std::collections::VecDeque;
use std::sync::{Arc, Mutex};

/// External network backend that can be driven from JavaScript.
///
/// Packets are injected via `inject_rx_packet()` and extracted via `extract_tx_packet()`.
/// This enables bridging the WASM VM to native networking code in Node.js.
pub struct ExternalNetworkBackend {
    state: Mutex<ExternalNetState>,
}

struct ExternalNetState {
    /// Queue of packets to be received by the guest (injected from external source)
    rx_queue: VecDeque<Vec<u8>>,
    /// Queue of packets sent by the guest (to be extracted by external sink)
    tx_queue: VecDeque<Vec<u8>>,
    /// MAC address
    mac: [u8; 6],
    /// Assigned IP address (if any)
    assigned_ip: Option<[u8; 4]>,
    /// Whether the backend is connected
    connected: bool,
}

impl ExternalNetworkBackend {
    /// Create a new external network backend with the given MAC address.
    pub fn new(mac: [u8; 6]) -> Self {
        Self {
            state: Mutex::new(ExternalNetState {
                rx_queue: VecDeque::new(),
                tx_queue: VecDeque::new(),
                mac,
                assigned_ip: None,
                connected: false,
            }),
        }
    }

    /// Inject a packet to be received by the guest.
    /// Called from JavaScript when the native addon receives a packet.
    pub fn inject_rx_packet(&self, packet: Vec<u8>) {
        if let Ok(mut state) = self.state.lock() {
            state.rx_queue.push_back(packet);
        }
    }

    /// Extract a packet sent by the guest.
    /// Called from JavaScript to get packets to send via native addon.
    pub fn extract_tx_packet(&self) -> Option<Vec<u8>> {
        if let Ok(mut state) = self.state.lock() {
            state.tx_queue.pop_front()
        } else {
            None
        }
    }

    /// Extract all pending TX packets.
    pub fn extract_all_tx_packets(&self) -> Vec<Vec<u8>> {
        if let Ok(mut state) = self.state.lock() {
            state.tx_queue.drain(..).collect()
        } else {
            Vec::new()
        }
    }

    /// Set the assigned IP address.
    pub fn set_assigned_ip(&self, ip: [u8; 4]) {
        if let Ok(mut state) = self.state.lock() {
            state.assigned_ip = Some(ip);
        }
    }

    /// Set connection status.
    pub fn set_connected(&self, connected: bool) {
        if let Ok(mut state) = self.state.lock() {
            state.connected = connected;
        }
    }

    /// Check if connected.
    pub fn is_connected(&self) -> bool {
        if let Ok(state) = self.state.lock() {
            state.connected
        } else {
            false
        }
    }

    /// Get number of pending RX packets.
    pub fn rx_queue_len(&self) -> usize {
        if let Ok(state) = self.state.lock() {
            state.rx_queue.len()
        } else {
            0
        }
    }

    /// Get number of pending TX packets.
    pub fn tx_queue_len(&self) -> usize {
        if let Ok(state) = self.state.lock() {
            state.tx_queue.len()
        } else {
            0
        }
    }
}

// Make it Send for the NetworkBackend trait
unsafe impl Send for ExternalNetworkBackend {}

impl NetworkBackend for ExternalNetworkBackend {
    fn init(&mut self) -> Result<(), String> {
        if let Ok(mut state) = self.state.lock() {
            state.connected = true;
        }
        Ok(())
    }

    fn recv(&mut self) -> Result<Option<Vec<u8>>, String> {
        if let Ok(mut state) = self.state.lock() {
            Ok(state.rx_queue.pop_front())
        } else {
            Err("Failed to lock state".to_string())
        }
    }

    fn send(&self, buf: &[u8]) -> Result<(), String> {
        if let Ok(mut state) = self.state.lock() {
            state.tx_queue.push_back(buf.to_vec());
            Ok(())
        } else {
            Err("Failed to lock state".to_string())
        }
    }

    fn mac_address(&self) -> [u8; 6] {
        if let Ok(state) = self.state.lock() {
            state.mac
        } else {
            [0x52, 0x54, 0x00, 0x12, 0x34, 0x56]
        }
    }

    fn get_assigned_ip(&self) -> Option<[u8; 4]> {
        if let Ok(state) = self.state.lock() {
            state.assigned_ip
        } else {
            None
        }
    }
}

/// Wrapper around Arc<ExternalNetworkBackend> that implements NetworkBackend.
/// This is needed because VirtioNet takes Box<dyn NetworkBackend>.
pub struct ExternalBackendWrapper {
    pub inner: Arc<ExternalNetworkBackend>,
}

unsafe impl Send for ExternalBackendWrapper {}

impl NetworkBackend for ExternalBackendWrapper {
    fn init(&mut self) -> Result<(), String> {
        if let Ok(mut state) = self.inner.state.lock() {
            state.connected = true;
        }
        Ok(())
    }

    fn recv(&mut self) -> Result<Option<Vec<u8>>, String> {
        if let Ok(mut state) = self.inner.state.lock() {
            Ok(state.rx_queue.pop_front())
        } else {
            Err("Failed to lock state".to_string())
        }
    }

    fn send(&self, buf: &[u8]) -> Result<(), String> {
        if let Ok(mut state) = self.inner.state.lock() {
            state.tx_queue.push_back(buf.to_vec());
            Ok(())
        } else {
            Err("Failed to lock state".to_string())
        }
    }

    fn mac_address(&self) -> [u8; 6] {
        if let Ok(state) = self.inner.state.lock() {
            state.mac
        } else {
            [0x52, 0x54, 0x00, 0x12, 0x34, 0x56]
        }
    }

    fn get_assigned_ip(&self) -> Option<[u8; 4]> {
        if let Ok(state) = self.inner.state.lock() {
            state.assigned_ip
        } else {
            None
        }
    }
}
</file>

<file path="riscv-vm/tsup/index.ts">
/** biome-ignore-all lint/suspicious/noExplicitAny: Not needed here */

import fs from "node:fs";
import path from "node:path";
import { NodeResolvePlugin } from "@esbuild-plugins/node-resolve";
import { defineConfig, type Format } from "tsup";

const packagesDir = path.resolve(process.cwd());
// Browser-compatible base64 to Uint8Array decoder
const base64DecodeCode = `
function __decodeBase64(base64) {
  if (typeof Buffer !== 'undefined') {
    // Node.js environment
    return Buffer.from(base64, 'base64');
  }
  // Browser environment - use atob
  const binaryString = atob(base64);
  const bytes = new Uint8Array(binaryString.length);
  for (let i = 0; i < binaryString.length; i++) {
    bytes[i] = binaryString.charCodeAt(i);
  }
  return bytes;
}
`;

export const wasmPlugin = {
  name: "wasm",
  setup(build: any) {
    build.onResolve({ filter: /\.wasm$/ }, (args: any) => {
      if (fs.existsSync(path.resolve(packagesDir, args.path))) {
        return { path: path.resolve(packagesDir, args.path), namespace: "wasm" };
      }
      return { path: path.resolve("node_modules", args.path), namespace: "wasm" };
    });
    build.onLoad({ filter: /.*/, namespace: "wasm" }, async (args: any) => {
      const buffer = await fs.promises.readFile(args.path);
      const base64 = buffer.toString("base64");
      return {
        // Use browser-compatible base64 decoding
        contents: `${base64DecodeCode}\nexport default __decodeBase64("${base64}");`,
        loader: "js",
      };
    });
  },
};

export const plugins = [
  NodeResolvePlugin({
    extensions: [".ts", ".js", ".wasm"],
    onResolved: (resolved) => {
      if (resolved.includes("node_modules")) {
        return {
          external: true,
        };
      }
      return resolved;
    },
  }),
];

export default function createConfig({
  format,
  entry,
  banner,
  platform,
  external
}: {
  format: Format | Format[] | undefined;
  entry: string[] | undefined;
  banner?: { js: string };
  platform?: "neutral" | "node" | "browser";
  external?: string[] | undefined;
}) {
  return defineConfig(({ watch: _watch }) => ({
    entry,
    format,
    outDir: "build",
    target: "esnext",
    minify: false,
    platform: platform || "neutral",
    clean: false,
    esbuildPlugins: [wasmPlugin, ...plugins],
    banner,
    esbuildOptions: (options, _context) => {
      options.platform = platform || "neutral";
    },
    external: [
      "buffer",
      "next",
      "vitest",
      "react-server-dom-webpack",
      "tsup",
      "react-server-dom-webpack/client.edge",
      ...(external ?? [])
    ],
  }));
}
</file>

<file path="riscv-vm/tsup/tsup.node-worker.ts">
import createConfig from './';

export default createConfig({
  format: ['cjs'],
  entry: ['node-worker.ts'],
  external: [],
  platform: 'node',
  // Don't bundle the WASM bindings - they're loaded dynamically
  noExternal: [],
});
</file>

<file path="riscv-vm/build.rs">
fn main() {
    // napi-build setup (only when napi feature is enabled)
    #[cfg(feature = "napi")]
    {
        extern crate napi_build;
        napi_build::setup();
    }
}
</file>

<file path="riscv-vm/node-worker.ts">
/**
 * Node.js Worker Thread entry point for RISC-V hart.
 *
 * This worker runs a secondary RISC-V hart (1, 2, 3, ...) sharing memory
 * with the main thread via SharedArrayBuffer using Node.js worker_threads.
 *
 * ## Architecture
 *
 * - Workers run secondary harts (1+)
 * - Hart 0 runs on main thread (handles I/O)
 * - Shared via SharedArrayBuffer:
 *   - Control region (halt flags)
 *   - CLINT (timer, IPI)
 *   - DRAM (kernel memory)
 *
 * ## Communication Protocol
 *
 * Main → Worker: workerData (hartId, sharedMem, entryPc, wasmPath)
 * Worker → Main: WorkerReadyMessage | WorkerHaltedMessage | WorkerErrorMessage
 */

import { parentPort, workerData } from 'node:worker_threads';
import fs from 'node:fs';
import path from 'node:path';

// WorkerStepResult enum values (must match worker.rs)
const WorkerStepResult = {
  Continue: 0,
  Halted: 1,
  Shutdown: 2,
  Error: 3,
} as const;

// ============================================================================
// Message Types
// ============================================================================

interface WorkerData {
  hartId: number;
  sharedMem: SharedArrayBuffer;
  entryPc: number;
  wasmPath: string;
}

interface WorkerReadyMessage {
  type: "ready";
  hartId: number;
}

interface WorkerHaltedMessage {
  type: "halted";
  hartId: number;
  stepCount?: number;
}

interface WorkerErrorMessage {
  type: "error";
  hartId?: number;
  error: string;
}

type WorkerOutboundMessage =
  | WorkerReadyMessage
  | WorkerHaltedMessage
  | WorkerErrorMessage;

// ============================================================================
// Shared Memory Layout (must match shared_mem.rs)
// ============================================================================

const CTRL_HALT_REQUESTED = 0;

// ============================================================================
// Worker Context
// ============================================================================

let controlView: Int32Array | null = null;
let workerState: any = null;

// Tuning parameters for execution
const BATCH_SIZE = 100_000;
const BATCHES_PER_YIELD = 10;

function postMessage(msg: WorkerOutboundMessage): void {
  parentPort?.postMessage(msg);
}

/**
 * Run loop using optimized blocking execution with periodic yields.
 */
function runLoop(hartId: number): void {
  if (!workerState || !controlView) {
    console.error('[Worker] runLoop called without workerState or controlView');
    return;
  }

  let shouldContinue = true;
  let batchCount = 0;

  while (shouldContinue) {
    const result = workerState.step_batch(BATCH_SIZE);

    switch (result) {
      case WorkerStepResult.Continue:
        batchCount++;

        // Yield periodically to allow halt signals to be processed
        if (batchCount >= BATCHES_PER_YIELD) {
          batchCount = 0;

          // Use Atomics.wait with 0ms timeout for efficient yielding
          try {
            Atomics.wait(controlView, CTRL_HALT_REQUESTED, 0, 0);
          } catch {
            // Fall back gracefully
          }
        }
        break;

      case WorkerStepResult.Halted:
        console.log(`[Worker ${hartId}] Halted after ${workerState.step_count()} steps`);
        postMessage({ type: "halted", hartId, stepCount: Number(workerState.step_count()) });
        cleanup();
        shouldContinue = false;
        break;

      case WorkerStepResult.Shutdown:
        console.log(`[Worker ${hartId}] Shutdown after ${workerState.step_count()} steps`);
        postMessage({ type: "halted", hartId, stepCount: Number(workerState.step_count()) });
        cleanup();
        shouldContinue = false;
        break;

      case WorkerStepResult.Error:
        console.error(`[Worker ${hartId}] Error after ${workerState.step_count()} steps`);
        postMessage({ type: "error", hartId, error: "Execution error" });
        cleanup();
        shouldContinue = false;
        break;
    }
  }
}

function cleanup(): void {
  workerState = null;
  controlView = null;
}

async function main(): Promise<void> {
  const { hartId, sharedMem, entryPc, wasmPath } = workerData as WorkerData;

  console.log(`[Worker ${hartId}] Starting with WASM from ${wasmPath}`);

  try {
    // Load WASM module
    const wasmBytes = fs.readFileSync(wasmPath);
    
    // Load the JS bindings
    const jsPath = wasmPath.replace('_bg.wasm', '.js');
    const wasmModule = await import(jsPath);
    
    // Initialize WASM with the bytes
    wasmModule.initSync(wasmBytes);
    
    console.log(`[Worker ${hartId}] WASM initialized`);

    // Verify SharedArrayBuffer
    if (!(sharedMem instanceof SharedArrayBuffer)) {
      throw new Error("sharedMem must be a SharedArrayBuffer");
    }

    // Notify main thread that we're ready
    postMessage({ type: "ready", hartId });

    // Convert entryPc to BigInt for u64
    const pc = BigInt(Math.floor(entryPc));
    console.log(`[Worker ${hartId}] Starting execution at PC=0x${pc.toString(16)}`);

    // Set up control view for Atomics
    controlView = new Int32Array(sharedMem);

    // Create worker state
    workerState = new wasmModule.WorkerState(hartId, sharedMem, pc);

    // Start the run loop
    runLoop(hartId);
  } catch (e) {
    console.error(`[Worker ${hartId}] Error:`, e);
    postMessage({
      type: "error",
      hartId,
      error: String(e),
    });
  }
}

// Start the worker
main().catch((e) => {
  console.error('[Worker] Fatal error:', e);
  postMessage({
    type: "error",
    error: String(e),
  });
});
</file>

<file path="riscv-vm/project.json">
{
  "name": "riscv-vm",
  "release": {
    "version": {
      "generator": "@nx/js:release-version",
      "generatorOptions": {
        "packageRoot": "riscv-vm",
        "currentVersionResolver": "git-tag",
        "fallbackCurrentVersionResolver": "disk"
      }
    }
  },
  "targets": {
    "build": {
      "executor": "nx:run-script",
      "options": {
        "script": "build"
      },
      "outputs": [
        "{projectRoot}/build"
      ]
    },
    "lint": {
      "executor": "nx:run-commands",
      "options": {
        "command": "cargo clippy",
        "cwd": "riscv-vm"
      }
    },
    "test-rust": {
      "executor": "nx:run-commands",
      "options": {
        "command": "cargo test",
        "cwd": "riscv-vm"
      }
    },
    "nx-release-publish": {
      "executor": "nx:run-commands",
      "options": {
        "command": "npm publish --provenance --access public",
        "cwd": "riscv-vm",
        "parallel": false
      },
      "dependsOn": ["build"]
    }
  }
}
</file>

<file path="riscv-vm/README.md">
# RISC-V Virtual Machine

A complete RISC-V 64-bit (RV64GC) virtual machine implementation in Rust, capable of running modern operating systems like Linux (xv6) and custom bare-metal kernels. It is designed to run both natively and in the browser via WebAssembly.

## Features

- **Core**: Full RV64GC instruction set implementation (IMAFDC + Zicsr + Zifencei).
- **Memory**: Sv39 Virtual Memory Management Unit (MMU) with TLB.
- **Peripherals**:
  - **UART**: 16550-compatible serial console.
  - **PLIC**: Platform-Level Interrupt Controller.
  - **CLINT**: Core Local Interruptor (Timer).
  - **VirtIO**: Block Device (Disk) and Network Device (Net).
- **Networking**:
  - Native TAP interface support (Linux).
  - WebSocket backend for browser/cross-platform networking.
  - WebTransport backend for P2P connectivity.
- **Platform**:
  - **WASM**: Compiles to WebAssembly for browser execution.
  - **Native**: Runs as a CLI application on Host OS.

## Usage

### CLI (Native)

Run the emulator from the command line:

```bash
# Run a kernel image
cargo run --release -- --kernel path/to/kernel

# Run with networking (WebSocket backend)
cargo run --release -- --kernel path/to/kernel --net-ws ws://localhost:8765

# Run with block device
cargo run --release -- --kernel path/to/kernel --disk path/to/fs.img
```

### WebAssembly

The VM exposes a simple API for JavaScript integration:

```typescript
import { WasmVm } from "virtual-machine";

// Initialize VM with kernel binary
const vm = new WasmVm(kernelBytes);

// Connect networking
vm.connect_network("ws://localhost:8765");

// Step execution
while (running) {
  vm.step();
}
```

## Architecture

The VM follows a modular design:
- `cpu.rs`: Instruction decoder and execution pipeline.
- `mmu.rs`: Virtual address translation.
- `bus.rs`: Memory mapping and device routing.
- `virtio.rs`: VirtIO device implementations.
- `net.rs`: Network backend abstraction.

## Build

```bash
# Build native CLI
cargo build --release

# Build WASM package
wasm-pack build --target web
```
</file>

<file path="riscv-vm/worker-utils.ts">
/**
 * Worker utility types and functions.
 * 
 * This module contains only types and side-effect-free utility functions
 * that can be safely imported in Node.js or browser environments.
 * 
 * The actual worker entry point is in worker.ts (browser-only).
 */

// ============================================================================
// Message Types
// ============================================================================

/** Message sent from main thread to initialize the worker */
export interface WorkerInitMessage {
  hartId: number;
  /** SharedArrayBuffer containing control + CLINT + DRAM */
  sharedMem: SharedArrayBuffer;
  entryPc: number;
}

/** Message sent when worker is ready to execute */
export interface WorkerReadyMessage {
  type: "ready";
  hartId: number;
}

/** Message sent when worker has halted */
export interface WorkerHaltedMessage {
  type: "halted";
  hartId: number;
  stepCount?: number;
}

/** Message sent when an error occurs */
export interface WorkerErrorMessage {
  type: "error";
  hartId?: number;
  error: string;
}

export type WorkerOutboundMessage =
  | WorkerReadyMessage
  | WorkerHaltedMessage
  | WorkerErrorMessage;

// ============================================================================
// Shared Memory Layout (must match shared_mem.rs)
// ============================================================================

/** Control region offsets (i32 indices) */
const CTRL_HALT_REQUESTED = 0;
const CTRL_HALTED = 1;

// ============================================================================
// Utility Functions (side-effect-free, Node.js compatible)
// ============================================================================

/**
 * Check if halt has been requested in the shared control region.
 * This can be used for JS-side polling if needed.
 */
export function isHaltRequested(sharedMem: SharedArrayBuffer): boolean {
  const view = new Int32Array(sharedMem);
  return Atomics.load(view, CTRL_HALT_REQUESTED) !== 0;
}

/**
 * Request halt by setting the flag in shared memory.
 * This can be called from any thread.
 */
export function requestHalt(sharedMem: SharedArrayBuffer): void {
  const view = new Int32Array(sharedMem);
  Atomics.store(view, CTRL_HALT_REQUESTED, 1);
  Atomics.notify(view, CTRL_HALT_REQUESTED);
}

/**
 * Check if VM has halted.
 */
export function isHalted(sharedMem: SharedArrayBuffer): boolean {
  const view = new Int32Array(sharedMem);
  return Atomics.load(view, CTRL_HALTED) !== 0;
}
</file>

<file path="kernel/.cargo/config.toml">
[build]
target = "riscv64gc-unknown-none-elf"

[target.riscv64gc-unknown-none-elf]
# Enable linker relaxation which can convert JAL to AUIPC+JALR for long jumps
# This helps when code size exceeds the 1MB JAL range
rustflags = [
    "-C", "link-arg=-Tlink.x",
    "-C", "link-arg=--relax",
    "-C", "link-arg=--no-relax-gp",
]
</file>

<file path="kernel/src/http.rs">
//! HTTP client implementation for making HTTP requests.
//!
//! This module provides a simple HTTP/1.1 client that supports:
//! - GET, POST, PUT, DELETE methods
//! - Custom headers
//! - Response parsing with status, headers, and body
//! - Automatic redirect following (301, 302, 303, 307, 308)

use alloc::string::{String, ToString};
use alloc::vec::Vec;
use alloc::collections::BTreeMap;
use alloc::format;
use smoltcp::wire::Ipv4Address;

/// Maximum number of redirects to follow before giving up
const MAX_REDIRECTS: u8 = 10;

/// HTTP methods
#[derive(Clone, Copy, Debug, PartialEq)]
pub enum HttpMethod {
    Get,
    Post,
    Put,
    Delete,
    Head,
}

impl HttpMethod {
    pub fn as_str(&self) -> &'static str {
        match self {
            HttpMethod::Get => "GET",
            HttpMethod::Post => "POST",
            HttpMethod::Put => "PUT",
            HttpMethod::Delete => "DELETE",
            HttpMethod::Head => "HEAD",
        }
    }
}

/// HTTP request builder
pub struct HttpRequest {
    pub method: HttpMethod,
    pub host: String,
    pub path: String,
    pub port: u16,
    pub headers: BTreeMap<String, String>,
    pub body: Option<Vec<u8>>,
    pub is_https: bool,
}

impl HttpRequest {
    /// Create a new GET request
    pub fn get(url: &str) -> Result<Self, &'static str> {
        Self::new(HttpMethod::Get, url)
    }
    
    /// Create a new POST request
    pub fn post(url: &str) -> Result<Self, &'static str> {
        Self::new(HttpMethod::Post, url)
    }
    
    /// Create a new request with the given method
    pub fn new(method: HttpMethod, url: &str) -> Result<Self, &'static str> {
        let parsed = parse_url(url)?;
        
        let mut headers = BTreeMap::new();
        headers.insert("Host".to_string(), parsed.host.clone());
        headers.insert("User-Agent".to_string(), format!("BAVY OS/{}", env!("CARGO_PKG_VERSION")));
        headers.insert("Accept".to_string(), "*/*".to_string());
        headers.insert("Connection".to_string(), "close".to_string());
        
        Ok(HttpRequest {
            method,
            host: parsed.host,
            path: parsed.path,
            port: parsed.port,
            headers,
            body: None,
            is_https: parsed.is_https,
        })
    }
    
    /// Set a header
    pub fn header(mut self, key: &str, value: &str) -> Self {
        self.headers.insert(key.to_string(), value.to_string());
        self
    }
    
    /// Set the request body
    pub fn body(mut self, body: Vec<u8>) -> Self {
        let len = body.len();
        self.body = Some(body);
        self.headers.insert("Content-Length".to_string(), len.to_string());
        self
    }
    
    /// Set the request body as a string
    pub fn body_str(self, body: &str) -> Self {
        self.body(body.as_bytes().to_vec())
    }
    
    /// Build the HTTP request bytes
    pub fn build(&self) -> Vec<u8> {
        let mut request = format!(
            "{} {} HTTP/1.1\r\n",
            self.method.as_str(),
            self.path
        );
        
        for (key, value) in &self.headers {
            request.push_str(key);
            request.push_str(": ");
            request.push_str(value);
            request.push_str("\r\n");
        }
        
        request.push_str("\r\n");
        
        let mut bytes = request.into_bytes();
        
        if let Some(ref body) = self.body {
            bytes.extend_from_slice(body);
        }
        
        bytes
    }
}

/// HTTP response
#[derive(Debug)]
pub struct HttpResponse {
    pub status_code: u16,
    pub status_text: String,
    pub headers: BTreeMap<String, String>,
    pub body: Vec<u8>,
}

impl HttpResponse {
    /// Get body as UTF-8 string
    pub fn text(&self) -> String {
        String::from_utf8_lossy(&self.body).into_owned()
    }
    
    /// Check if response is successful (2xx)
    pub fn is_success(&self) -> bool {
        self.status_code >= 200 && self.status_code < 300
    }
    
    /// Check if response is redirect (3xx)
    pub fn is_redirect(&self) -> bool {
        self.status_code >= 300 && self.status_code < 400
    }
    
    /// Get a header value (case-insensitive)
    pub fn header(&self, name: &str) -> Option<&String> {
        let lower = name.to_lowercase();
        self.headers.iter()
            .find(|(k, _)| k.to_lowercase() == lower)
            .map(|(_, v)| v)
    }
    
    /// Get content length from headers
    pub fn content_length(&self) -> Option<usize> {
        self.header("content-length")
            .and_then(|v| v.parse().ok())
    }
    
    /// Get redirect location if this is a redirect response
    pub fn redirect_location(&self) -> Option<&String> {
        if self.is_redirect() {
            self.header("location")
        } else {
            None
        }
    }
}

/// URL parsing result
pub struct ParsedUrl {
    pub host: String,
    pub port: u16,
    pub path: String,
    pub is_https: bool,
}

/// Parse URL into (host, port, path, is_https)
fn parse_url(url: &str) -> Result<ParsedUrl, &'static str> {
    // Detect protocol and strip prefix
    let (url, is_https, default_port) = if url.starts_with("https://") {
        (&url[8..], true, 443u16)
    } else if url.starts_with("http://") {
        (&url[7..], false, 80u16)
    } else {
        (url, false, 80u16)
    };
    
    // Split host and path
    let (host_port, path) = match url.find('/') {
        Some(idx) => (&url[..idx], &url[idx..]),
        None => (url, "/"),
    };
    
    // Parse host and port
    let (host, port) = match host_port.find(':') {
        Some(idx) => {
            let port_str = &host_port[idx + 1..];
            let port: u16 = port_str.parse().map_err(|_| "Invalid port number")?;
            (&host_port[..idx], port)
        }
        None => (host_port, default_port),
    };
    
    Ok(ParsedUrl {
        host: host.to_string(),
        port,
        path: path.to_string(),
        is_https,
    })
}

/// Resolve a redirect URL relative to the original request
/// 
/// Handles:
/// - Absolute URLs (http://example.com/path or https://...)
/// - Protocol-relative URLs (//example.com/path)  
/// - Absolute paths (/path/to/resource)
/// - Relative paths (path/to/resource)
fn resolve_redirect_url(original: &HttpRequest, location: &str) -> Result<String, &'static str> {
    // Absolute URL
    if location.starts_with("http://") || location.starts_with("https://") {
        return Ok(location.to_string());
    }
    
    // Protocol-relative URL
    if location.starts_with("//") {
        let protocol = if original.is_https { "https:" } else { "http:" };
        return Ok(format!("{}{}", protocol, location));
    }
    
    // Build base URL from original request
    let protocol = if original.is_https { "https" } else { "http" };
    let port_str = if (original.is_https && original.port == 443) || 
                      (!original.is_https && original.port == 80) {
        String::new()
    } else {
        format!(":{}", original.port)
    };
    
    // Absolute path
    if location.starts_with('/') {
        return Ok(format!("{}://{}{}{}", protocol, original.host, port_str, location));
    }
    
    // Relative path - resolve against current path
    let base_path = if let Some(last_slash) = original.path.rfind('/') {
        &original.path[..=last_slash]
    } else {
        "/"
    };
    
    Ok(format!("{}://{}{}{}{}", protocol, original.host, port_str, base_path, location))
}

/// Parse raw HTTP response bytes into HttpResponse
pub fn parse_response(data: &[u8]) -> Result<HttpResponse, &'static str> {
    // Convert to string for easier parsing
    let response_str = core::str::from_utf8(data)
        .map_err(|_| "Invalid UTF-8 in response")?;
    
    // Find header/body separator
    let header_end = response_str.find("\r\n\r\n")
        .ok_or("No header/body separator found")?;
    
    let header_section = &response_str[..header_end];
    let body_start = header_end + 4;
    
    // Parse status line
    let mut lines = header_section.lines();
    let status_line = lines.next().ok_or("Missing status line")?;
    
    // Parse "HTTP/1.x STATUS STATUS_TEXT"
    let mut parts = status_line.splitn(3, ' ');
    let _version = parts.next().ok_or("Missing HTTP version")?;
    let status_str = parts.next().ok_or("Missing status code")?;
    let status_text = parts.next().unwrap_or("").to_string();
    
    let status_code: u16 = status_str.parse()
        .map_err(|_| "Invalid status code")?;
    
    // Parse headers
    let mut headers = BTreeMap::new();
    for line in lines {
        if let Some(colon_idx) = line.find(':') {
            let key = line[..colon_idx].trim().to_string();
            let value = line[colon_idx + 1..].trim().to_string();
            headers.insert(key, value);
        }
    }
    
    // Extract body
    let body = data[body_start..].to_vec();
    
    Ok(HttpResponse {
        status_code,
        status_text,
        headers,
        body,
    })
}

/// Perform an HTTP request using the network stack
/// 
/// This is a blocking call that:
/// 1. Resolves the hostname to IP (if needed)
/// 2. Connects via TCP (and TLS for HTTPS)
/// 3. Sends the HTTP request
/// 4. Receives and parses the response
pub fn http_request(
    net: &mut crate::net::NetState,
    request: &HttpRequest,
    timeout_ms: i64,
    get_time_ms: fn() -> i64,
) -> Result<HttpResponse, &'static str> {
    // For HTTPS, use the TLS module
    if request.is_https {
        return https_request(net, request, timeout_ms, get_time_ms);
    }
    
    // HTTP (non-TLS) request
    let dest_ip = resolve_host(net, &request.host, timeout_ms, get_time_ms)?;
    
    let start_time = get_time_ms();
    
    // Connect to the server
    net.tcp_connect(dest_ip, request.port, start_time)?;
    
    // Wait for connection to establish
    loop {
        let now = get_time_ms();
        if now - start_time > timeout_ms {
            net.tcp_abort();
            return Err("Connection timeout");
        }
        
        net.poll(now);
        
        if net.tcp_is_connected() {
            break;
        }
        
        if net.tcp_connection_failed() {
            return Err("Connection failed");
        }
        
        // Small delay to avoid busy-waiting
        for _ in 0..10000 {
            core::hint::spin_loop();
        }
    }
    
    // Send the HTTP request
    let request_bytes = request.build();
    let mut sent = 0;
    
    while sent < request_bytes.len() {
        let now = get_time_ms();
        if now - start_time > timeout_ms {
            net.tcp_abort();
            return Err("Send timeout");
        }
        
        net.poll(now);
        
        match net.tcp_send(&request_bytes[sent..], now) {
            Ok(n) if n > 0 => sent += n,
            Ok(_) => {}
            Err(e) => {
                net.tcp_abort();
                return Err(e);
            }
        }
        
        // Small delay
        for _ in 0..5000 {
            core::hint::spin_loop();
        }
    }
    
    // Receive the response
    let mut response_buf = Vec::with_capacity(8192);
    let mut recv_buf = [0u8; 1024];
    let mut headers_complete = false;
    let mut content_length: Option<usize> = None;
    let mut body_start = 0;
    
    loop {
        let now = get_time_ms();
        if now - start_time > timeout_ms {
            net.tcp_abort();
            return Err("Receive timeout");
        }
        
        net.poll(now);
        
        match net.tcp_recv(&mut recv_buf, now) {
            Ok(n) if n > 0 => {
                response_buf.extend_from_slice(&recv_buf[..n]);
                
                // Check if we've received all headers
                if !headers_complete {
                    if let Some(pos) = find_header_end(&response_buf) {
                        headers_complete = true;
                        body_start = pos + 4;
                        
                        // Parse content-length from headers
                        if let Ok(s) = core::str::from_utf8(&response_buf[..pos]) {
                            for line in s.lines() {
                                if line.to_lowercase().starts_with("content-length:") {
                                    if let Some(len_str) = line.split(':').nth(1) {
                                        content_length = len_str.trim().parse().ok();
                                    }
                                }
                            }
                        }
                    }
                }
                
                // Check if we've received the complete response
                if headers_complete {
                    let body_len = response_buf.len() - body_start;
                    match content_length {
                        Some(expected) if body_len >= expected => break,
                        None => {
                            // No content-length, wait for connection close
                        }
                        _ => {}
                    }
                }
            }
            Ok(_) => {
                // No data available, check if connection closed
                if net.tcp_connection_failed() {
                    break;
                }
            }
            Err(e) => {
                if e == "Connection closed by peer" && response_buf.len() > 0 {
                    break;
                }
                net.tcp_abort();
                return Err(e);
            }
        }
        
        // Small delay
        for _ in 0..5000 {
            core::hint::spin_loop();
        }
    }
    
    // Close the connection
    net.tcp_close(get_time_ms());
    
    // Parse the response
    if response_buf.is_empty() {
        return Err("Empty response");
    }
    
    parse_response(&response_buf)
}

/// Perform an HTTP request with automatic redirect following
/// 
/// This is similar to `http_request` but automatically follows 3xx redirects
/// up to MAX_REDIRECTS times.
/// 
/// Redirect types handled:
/// - 301 Moved Permanently
/// - 302 Found
/// - 303 See Other (method changes to GET)
/// - 307 Temporary Redirect (preserves method)
/// - 308 Permanent Redirect (preserves method)
pub fn http_request_follow_redirects(
    net: &mut crate::net::NetState,
    request: &HttpRequest,
    timeout_ms: i64,
    get_time_ms: fn() -> i64,
) -> Result<HttpResponse, &'static str> {
    let mut current_request = HttpRequest {
        method: request.method,
        host: request.host.clone(),
        path: request.path.clone(),
        port: request.port,
        headers: request.headers.clone(),
        body: request.body.clone(),
        is_https: request.is_https,
    };
    
    let mut redirects = 0u8;
    
    loop {
        let response = http_request(net, &current_request, timeout_ms, get_time_ms)?;
        
        // Check if this is a redirect
        if !response.is_redirect() {
            return Ok(response);
        }
        
        // Check redirect limit
        redirects += 1;
        if redirects > MAX_REDIRECTS {
            return Err("Too many redirects");
        }
        
        // Get redirect location
        let location = response.redirect_location()
            .ok_or("Redirect without Location header")?;
        
        // Resolve the redirect URL
        let new_url = resolve_redirect_url(&current_request, location)?;
        
        crate::uart::write_str("Redirecting to: ");
        crate::uart::write_line(&new_url);
        
        // Parse the new URL
        let parsed = parse_url(&new_url)?;
        
        // For 303, change method to GET and drop body
        // For 301/302, many clients also change to GET (though technically shouldn't for 301)
        let new_method = if response.status_code == 303 || 
                           (response.status_code == 301 || response.status_code == 302) && 
                           current_request.method == HttpMethod::Post {
            HttpMethod::Get
        } else {
            current_request.method
        };
        
        // Build new request
        let mut new_headers = BTreeMap::new();
        new_headers.insert("Host".to_string(), parsed.host.clone());
        new_headers.insert("User-Agent".to_string(), format!("BAVY OS/{}", env!("CARGO_PKG_VERSION")));
        new_headers.insert("Accept".to_string(), "*/*".to_string());
        new_headers.insert("Connection".to_string(), "close".to_string());
        
        // Drop body for GET requests
        let new_body = if new_method == HttpMethod::Get {
            None
        } else {
            current_request.body.clone()
        };
        
        current_request = HttpRequest {
            method: new_method,
            host: parsed.host,
            path: parsed.path,
            port: parsed.port,
            headers: new_headers,
            body: new_body,
            is_https: parsed.is_https,
        };
    }
}

/// Resolve hostname to IP address (handles both IPs and hostnames)
fn resolve_host(
    net: &mut crate::net::NetState,
    host: &str,
    timeout_ms: i64,
    get_time_ms: fn() -> i64,
) -> Result<Ipv4Address, &'static str> {
    // Try to parse as IP address first
    if let Some(ip) = crate::net::parse_ipv4(host.as_bytes()) {
        return Ok(ip);
    }
    
    // Resolve via DNS
    crate::dns::resolve(net, host.as_bytes(), crate::net::DNS_SERVER, timeout_ms, get_time_ms)
        .ok_or("DNS resolution failed")
}

/// Find the end of HTTP headers (double CRLF)
fn find_header_end(data: &[u8]) -> Option<usize> {
    for i in 0..data.len().saturating_sub(3) {
        if data[i] == b'\r' && data[i + 1] == b'\n' 
           && data[i + 2] == b'\r' && data[i + 3] == b'\n' {
            return Some(i);
        }
    }
    None
}

/// Simple GET request helper (does not follow redirects)
pub fn get(
    net: &mut crate::net::NetState,
    url: &str,
    timeout_ms: i64,
    get_time_ms: fn() -> i64,
) -> Result<HttpResponse, &'static str> {
    let request = HttpRequest::get(url)?;
    http_request(net, &request, timeout_ms, get_time_ms)
}

/// Simple GET request helper that follows redirects
pub fn get_follow_redirects(
    net: &mut crate::net::NetState,
    url: &str,
    timeout_ms: i64,
    get_time_ms: fn() -> i64,
) -> Result<HttpResponse, &'static str> {
    let request = HttpRequest::get(url)?;
    http_request_follow_redirects(net, &request, timeout_ms, get_time_ms)
}

/// Simple POST request helper
pub fn post(
    net: &mut crate::net::NetState,
    url: &str,
    body: &str,
    content_type: &str,
    timeout_ms: i64,
    get_time_ms: fn() -> i64,
) -> Result<HttpResponse, &'static str> {
    let request = HttpRequest::post(url)?
        .header("Content-Type", content_type)
        .body_str(body);
    http_request(net, &request, timeout_ms, get_time_ms)
}

// ═══════════════════════════════════════════════════════════════════════════════
// HTTPS SUPPORT
// ═══════════════════════════════════════════════════════════════════════════════

/// Perform an HTTPS request using TLS
/// Tries TLS 1.3 first, falls back to TLS 1.2 if needed
fn https_request(
    net: &mut crate::net::NetState,
    request: &HttpRequest,
    timeout_ms: i64,
    get_time_ms: fn() -> i64,
) -> Result<HttpResponse, &'static str> {
    // Resolve hostname to IP address
    let dest_ip = resolve_host(net, &request.host, timeout_ms, get_time_ms)?;
    
    // Build the HTTP request bytes
    let request_bytes = request.build();
    
    // Use longer timeout for HTTPS (TLS handshake needs multiple round trips)
    let https_timeout = timeout_ms.max(30000);
    
    // Try TLS 1.3 first (embedded-tls)
    let response_bytes = match crate::tls::https_request(
        net,
        dest_ip,
        request.port,
        &request.host,
        &request_bytes,
        https_timeout,
        get_time_ms,
    ) {
        Ok(bytes) => bytes,
        Err(_) => {
            // TLS 1.3 failed, try TLS 1.2
            crate::uart::write_line("TLS 1.3 failed, trying TLS 1.2...");
            
            crate::tls12::https_request_tls12(
                net,
                dest_ip,
                request.port,
                &request.host,
                &request_bytes,
                https_timeout,
                get_time_ms,
            ).map_err(|e| match e {
                crate::tls::TlsError::ConnectionError => "HTTPS: TCP connection failed",
                crate::tls::TlsError::TlsProtocolError => "HTTPS: TLS handshake failed",
                crate::tls::TlsError::Timeout => "HTTPS: Connection timeout",
                crate::tls::TlsError::InvalidData => "HTTPS: Invalid TLS data",
                crate::tls::TlsError::Io => "HTTPS: I/O error",
                crate::tls::TlsError::ConnectionClosed => "HTTPS: Connection closed",
                crate::tls::TlsError::NotConnected => "HTTPS: Not connected",
                crate::tls::TlsError::DnsError => "HTTPS: DNS resolution failed",
                crate::tls::TlsError::InternalError => "HTTPS: Internal TLS error",
            })?
        }
    };
    
    // Parse the response
    if response_bytes.is_empty() {
        return Err("Empty HTTPS response");
    }
    
    parse_response(&response_bytes)
}
</file>

<file path="kernel/src/lock.rs">
//! Spinlock implementation for SMP synchronization.
//!
//! Provides mutual exclusion primitives based on spinning (busy-waiting).
//! Appropriate for kernel code without a scheduler.

use core::cell::UnsafeCell;
use core::ops::{Deref, DerefMut};
use core::sync::atomic::{AtomicU32, Ordering};
#[cfg(debug_assertions)]
use core::sync::atomic::AtomicUsize;
use core::hint::spin_loop;

// Lock states as u32 for 32-bit atomic operations.
// On RISC-V, AtomicBool uses byte operations which may not be properly
// synchronized across harts in some emulators. Using AtomicU32 ensures
// we get proper AMOSWAP.W instructions that are correctly serialized.
const UNLOCKED: u32 = 0;
const LOCKED: u32 = 1;

/// A mutual exclusion primitive based on spinning.
///
/// # Example
///
/// ```
/// static COUNTER: Spinlock<u64> = Spinlock::new(0);
///
/// fn increment() {
///     let mut guard = COUNTER.lock();
///     *guard += 1;
/// }
/// ```
pub struct Spinlock<T> {
    // Use AtomicU32 instead of AtomicBool to ensure 32-bit atomic operations.
    // This guarantees we use AMOSWAP.W for swap and aligned LW/SW for load/store,
    // which are properly synchronized across harts.
    locked: AtomicU32,
    data: UnsafeCell<T>,
    #[cfg(debug_assertions)]
    holder: AtomicUsize, // Debug: track which hart holds the lock
}

// Safety: Spinlock provides synchronized access to T
unsafe impl<T: Send> Sync for Spinlock<T> {}
unsafe impl<T: Send> Send for Spinlock<T> {}

impl<T> Spinlock<T> {
    /// Create a new spinlock wrapping the given value.
    pub const fn new(data: T) -> Self {
        Self {
            locked: AtomicU32::new(UNLOCKED),
            data: UnsafeCell::new(data),
            #[cfg(debug_assertions)]
            holder: AtomicUsize::new(usize::MAX),
        }
    }

    /// Acquire the lock, blocking until available.
    ///
    /// Returns a guard that releases the lock when dropped.
    /// 
    /// NOTE: Uses `swap` (AMOSWAP.W instruction) for acquisition because it's a single
    /// atomic instruction that works correctly for SMP. We use AtomicU32 instead of
    /// AtomicBool to ensure we get 32-bit operations (AMOSWAP.W, LW, SW) which are
    /// properly synchronized across harts, rather than byte operations which may not be.
    #[inline]
    pub fn lock(&self) -> SpinlockGuard<T> {
        let mut spin_count = 0u32;

        loop {
            // Try to acquire using swap (AMOSWAP.W instruction on RISC-V)
            // swap(LOCKED) atomically sets the lock and returns the old value
            // If old value was UNLOCKED, we acquired the lock
            if self.locked.swap(LOCKED, Ordering::Acquire) == UNLOCKED {
                // Acquired! (old value was UNLOCKED)
                #[cfg(debug_assertions)]
                {
                    let hart_id = get_hart_id();
                    self.holder.store(hart_id, Ordering::Relaxed);
                }
                return SpinlockGuard {
                    lock: self,
                    _not_send: core::marker::PhantomData,
                };
            }

            // Lock was already held - spin until we can acquire it
            // Note: We continue trying swap instead of just loading, because
            // the emulator's AMO operations are properly serialized while
            // regular loads may not have proper visibility across harts.
            loop {
                spin_loop();
                spin_count = spin_count.wrapping_add(1);

                // Detect potential deadlock in debug mode
                #[cfg(debug_assertions)]
                if spin_count > 1_000_000 {
                    let holder = self.holder.load(Ordering::Relaxed);
                    let my_hart = get_hart_id();
                    if holder == my_hart {
                        panic!(
                            "Deadlock detected: hart {} trying to re-acquire lock it already holds",
                            my_hart
                        );
                    }
                    spin_count = 0; // Reset counter
                }
                
                // Try to acquire again with swap
                if self.locked.swap(LOCKED, Ordering::Acquire) == UNLOCKED {
                    // Got it!
                    #[cfg(debug_assertions)]
                    {
                        let hart_id = get_hart_id();
                        self.holder.store(hart_id, Ordering::Relaxed);
                    }
                    return SpinlockGuard {
                        lock: self,
                        _not_send: core::marker::PhantomData,
                    };
                }
            }
        }
    }

    /// Try to acquire the lock without blocking.
    ///
    /// Returns `Some(guard)` if successful, `None` if lock is held.
    #[inline]
    pub fn try_lock(&self) -> Option<SpinlockGuard<T>> {
        // Use swap instead of compare_exchange to ensure AMOSWAP.W is used
        if self.locked.swap(LOCKED, Ordering::Acquire) == UNLOCKED {
            #[cfg(debug_assertions)]
            self.holder.store(get_hart_id(), Ordering::Relaxed);
            Some(SpinlockGuard {
                lock: self,
                _not_send: core::marker::PhantomData,
            })
        } else {
            None
        }
    }

    /// Check if the lock is currently held (for debugging).
    pub fn is_locked(&self) -> bool {
        self.locked.load(Ordering::Relaxed) != UNLOCKED
    }

    /// Get the data without locking (unsafe).
    ///
    /// # Safety
    /// Caller must ensure no concurrent access.
    #[allow(dead_code)]
    pub unsafe fn get_unchecked(&self) -> &T {
        &*self.data.get()
    }

    /// Get mutable data without locking (unsafe).
    ///
    /// # Safety
    /// Caller must ensure no concurrent access.
    #[allow(dead_code)]
    pub unsafe fn get_unchecked_mut(&self) -> &mut T {
        &mut *self.data.get()
    }
}

/// Get current hart ID.
#[cfg(debug_assertions)]
fn get_hart_id() -> usize {
    let id: usize;
    unsafe {
        core::arch::asm!("csrr {}, mhartid", out(reg) id, options(nomem, nostack));
    }
    id
}

/// RAII guard that releases the spinlock when dropped.
pub struct SpinlockGuard<'a, T> {
    lock: &'a Spinlock<T>,
    // Prevent Send - this type contains a raw pointer conceptually
    _not_send: core::marker::PhantomData<*const ()>,
}

impl<T> Deref for SpinlockGuard<'_, T> {
    type Target = T;

    #[inline]
    fn deref(&self) -> &T {
        // Safety: We hold the lock, so exclusive access is guaranteed
        unsafe { &*self.lock.data.get() }
    }
}

impl<T> DerefMut for SpinlockGuard<'_, T> {
    #[inline]
    fn deref_mut(&mut self) -> &mut T {
        // Safety: We hold the lock exclusively
        unsafe { &mut *self.lock.data.get() }
    }
}

impl<T> Drop for SpinlockGuard<'_, T> {
    #[inline]
    fn drop(&mut self) {
        #[cfg(debug_assertions)]
        self.lock.holder.store(usize::MAX, Ordering::Relaxed);

        // Release the lock using AMOSWAP.W to ensure visibility across harts.
        // Using swap instead of store because the emulator serializes AMO operations
        // but may not properly synchronize regular store visibility across hart threads.
        self.lock.locked.swap(UNLOCKED, Ordering::Release);
    }
}

// ============================================================================
// Memory Fence Helpers
// ============================================================================

/// Full memory fence (FENCE IORW, IORW).
///
/// Ensures all memory operations before the fence are visible
/// to all harts before any operations after the fence.
///
/// Use when you need a full barrier, e.g., between init and signaling ready.
#[inline]
#[allow(dead_code)]
pub fn fence_memory() {
    unsafe {
        core::arch::asm!("fence iorw, iorw", options(nomem, nostack));
    }
}

/// Read fence (FENCE IR, IR).
///
/// Ensures all reads before the fence complete before reads after.
#[inline]
#[allow(dead_code)]
pub fn fence_read() {
    unsafe {
        core::arch::asm!("fence ir, ir", options(nomem, nostack));
    }
}

/// Write fence (FENCE OW, OW).
///
/// Ensures all writes before the fence complete before writes after.
#[inline]
#[allow(dead_code)]
pub fn fence_write() {
    unsafe {
        core::arch::asm!("fence ow, ow", options(nomem, nostack));
    }
}

/// Fence for device I/O (FENCE O, I).
///
/// Ensures device writes are complete before device reads.
/// Use when communicating with MMIO devices.
#[inline]
#[allow(dead_code)]
pub fn fence_io() {
    unsafe {
        core::arch::asm!("fence o, i", options(nomem, nostack));
    }
}

/// Instruction fence (FENCE.I).
///
/// Ensures instruction fetches see recent stores.
/// Required after modifying code (e.g., dynamic loading, JIT).
#[inline]
#[allow(dead_code)]
pub fn fence_i() {
    unsafe {
        core::arch::asm!("fence.i", options(nomem, nostack));
    }
}

/// Release fence (FENCE W, W).
///
/// Ensures writes are visible before a release store.
/// Use before storing a flag that another hart will read.
#[inline]
#[allow(dead_code)]
pub fn fence_release() {
    unsafe {
        core::arch::asm!("fence w, w", options(nomem, nostack));
    }
}

/// Acquire fence (FENCE R, R).
///
/// Ensures subsequent reads see writes from before the acquire load.
/// Use after loading a flag written by another hart.
#[inline]
#[allow(dead_code)]
pub fn fence_acquire() {
    unsafe {
        core::arch::asm!("fence r, r", options(nomem, nostack));
    }
}
</file>

<file path="kernel/src/scheduler.rs">
//! Multi-hart task scheduler
//!
//! Provides a simple priority-based scheduler that distributes tasks across
//! available harts. Features:
//! - Per-hart run queues
//! - Priority-based scheduling
//! - Work stealing (idle harts can take work from busy ones)
//! - Hart affinity support

use alloc::collections::{BTreeMap, VecDeque};
use alloc::sync::Arc;
use alloc::vec::Vec;
use core::sync::atomic::{AtomicBool, AtomicUsize, Ordering, fence};

use crate::task::{Task, TaskEntry, TaskInfo, TaskState, Pid, Priority};
use crate::Spinlock;
use crate::MAX_HARTS;

/// Per-hart run queue
pub struct RunQueue {
    /// Tasks waiting to run (priority sorted)
    tasks: VecDeque<Arc<Task>>,
    /// Currently running task on this hart
    current: Option<Arc<Task>>,
}

impl RunQueue {
    pub const fn new() -> Self {
        Self {
            tasks: VecDeque::new(),
            current: None,
        }
    }
    
    /// Add a task to the queue (maintains priority order)
    pub fn enqueue(&mut self, task: Arc<Task>) {
        // Insert based on priority (higher priority = earlier in queue)
        let priority = task.priority;
        let mut insert_pos = self.tasks.len();
        for (i, t) in self.tasks.iter().enumerate() {
            if t.priority < priority {
                insert_pos = i;
                break;
            }
        }
        self.tasks.insert(insert_pos, task);
    }
    
    /// Get next task to run
    pub fn dequeue(&mut self) -> Option<Arc<Task>> {
        // Find first runnable task
        for i in 0..self.tasks.len() {
            if self.tasks[i].is_runnable() {
                return self.tasks.remove(i);
            }
        }
        None
    }
    
    /// Number of tasks in queue
    pub fn len(&self) -> usize {
        self.tasks.len()
    }
    
    /// Check if queue is empty
    pub fn is_empty(&self) -> bool {
        self.tasks.is_empty()
    }
    
    /// Steal a task from this queue (for work stealing)
    pub fn steal(&mut self) -> Option<Arc<Task>> {
        // Steal lowest priority task from back of queue
        if self.tasks.len() > 1 {
            self.tasks.pop_back()
        } else {
            None
        }
    }
}

/// Global scheduler
pub struct Scheduler {
    /// Per-hart run queues
    queues: [Spinlock<RunQueue>; MAX_HARTS],
    /// Global task registry (PID -> Task)
    tasks: Spinlock<BTreeMap<Pid, Arc<Task>>>,
    /// Next PID to assign
    next_pid: AtomicUsize,
    /// Number of active harts
    num_harts: AtomicUsize,
    /// Scheduler is initialized and running
    running: AtomicBool,
}

// Create array of spinlocks for run queues
const fn create_queue_array() -> [Spinlock<RunQueue>; MAX_HARTS] {
    const INIT: Spinlock<RunQueue> = Spinlock::new(RunQueue {
        tasks: VecDeque::new(),
        current: None,
    });
    [INIT; MAX_HARTS]
}

/// Global scheduler instance
pub static SCHEDULER: Scheduler = Scheduler {
    queues: create_queue_array(),
    tasks: Spinlock::new(BTreeMap::new()),
    next_pid: AtomicUsize::new(1), // PID 0 is reserved (idle)
    num_harts: AtomicUsize::new(1),
    running: AtomicBool::new(false),
};

impl Scheduler {
    /// Initialize the scheduler with the number of available harts
    pub fn init(&self, num_harts: usize) {
        self.num_harts.store(num_harts, Ordering::Release);
        self.running.store(true, Ordering::Release);
        fence(Ordering::SeqCst);
        
        crate::klog::klog_info("sched", &alloc::format!("Scheduler initialized with {} harts", num_harts));
    }
    
    /// Check if scheduler is running
    pub fn is_running(&self) -> bool {
        self.running.load(Ordering::Acquire)
    }
    
    /// Spawn a new task
    pub fn spawn(&self, name: &str, entry: TaskEntry, priority: Priority) -> Pid {
        self.spawn_on_hart(name, entry, priority, None)
    }
    
    /// Spawn a task with hart affinity
    pub fn spawn_on_hart(
        &self,
        name: &str,
        entry: TaskEntry,
        priority: Priority,
        hart_affinity: Option<usize>,
    ) -> Pid {
        let pid = self.next_pid.fetch_add(1, Ordering::SeqCst) as Pid;
        let mut task = Task::new(pid, name, entry, priority);
        task.hart_affinity = hart_affinity;
        
        let task = Arc::new(task);
        
        // Register in global task table
        self.tasks.lock().insert(pid, task.clone());
        
        // Determine target hart
        let target_hart = hart_affinity.unwrap_or_else(|| self.find_least_loaded_hart());
        
        // Enqueue the task
        self.queues[target_hart].lock().enqueue(task);
        
        crate::klog::klog_debug("sched", &alloc::format!(
            "Spawned task '{}' (PID {}) on hart {}", name, pid, target_hart
        ));
        
        // Wake the target hart if not primary
        if target_hart != 0 {
            crate::send_ipi(target_hart);
        }
        
        pid
    }
    
    /// Spawn a daemon task (long-running service)
    pub fn spawn_daemon(&self, name: &str, entry: TaskEntry, priority: Priority) -> Pid {
        self.spawn_daemon_on_hart(name, entry, priority, None)
    }
    
    /// Spawn a daemon task on a specific hart
    pub fn spawn_daemon_on_hart(
        &self,
        name: &str,
        entry: TaskEntry,
        priority: Priority,
        hart_affinity: Option<usize>,
    ) -> Pid {
        let pid = self.next_pid.fetch_add(1, Ordering::SeqCst) as Pid;
        let mut task = Task::new_daemon(pid, name, entry, priority);
        task.hart_affinity = hart_affinity;
        
        let task = Arc::new(task);
        
        self.tasks.lock().insert(pid, task.clone());
        
        let target_hart = hart_affinity.unwrap_or_else(|| self.find_least_loaded_hart());
        self.queues[target_hart].lock().enqueue(task);
        
        crate::klog::klog_debug("sched", &alloc::format!(
            "Spawned daemon '{}' (PID {}) on hart {}", name, pid, target_hart
        ));
        
        pid
    }
    
    /// Find the hart with the fewest queued tasks
    fn find_least_loaded_hart(&self) -> usize {
        let num_harts = self.num_harts.load(Ordering::Relaxed);
        let mut min_load = usize::MAX;
        let mut target = 0;
        
        for hart in 0..num_harts {
            let load = self.queues[hart].lock().len();
            if load < min_load {
                min_load = load;
                target = hart;
            }
        }
        
        target
    }
    
    /// Pick the next task for a hart to run
    pub fn pick_next(&self, hart_id: usize) -> Option<Arc<Task>> {
        // First try our own queue
        if let Some(task) = self.queues[hart_id].lock().dequeue() {
            return Some(task);
        }
        
        // Try work stealing from other harts
        let num_harts = self.num_harts.load(Ordering::Relaxed);
        for other in 0..num_harts {
            if other != hart_id {
                if let Some(task) = self.queues[other].lock().steal() {
                    crate::klog::klog_trace("sched", &alloc::format!(
                        "Hart {} stole task '{}' from hart {}", 
                        hart_id, task.name, other
                    ));
                    return Some(task);
                }
            }
        }
        
        None
    }
    
    /// Requeue a task (e.g., after time slice expires)
    pub fn requeue(&self, task: Arc<Task>, hart_id: usize) {
        task.set_state(TaskState::Ready);
        self.queues[hart_id].lock().enqueue(task);
    }
    
    /// Mark a task as finished
    pub fn finish_task(&self, pid: Pid, exit_code: usize) {
        if let Some(task) = self.tasks.lock().get(&pid) {
            task.mark_finished(exit_code);
            
            crate::klog::klog_info("sched", &alloc::format!(
                "Task '{}' (PID {}) exited with code {}", task.name, pid, exit_code
            ));
            
            // If daemon with restart_on_exit, respawn it
            if task.is_daemon && task.restart_on_exit {
                let name = task.name.clone();
                let entry = task.entry;
                let priority = task.priority;
                let affinity = task.hart_affinity;
                
                // Schedule respawn
                crate::klog::klog_info("sched", &alloc::format!(
                    "Respawning daemon '{}'", name
                ));
                self.spawn_on_hart(&name, entry, priority, affinity);
            }
        }
    }
    
    /// Clean up zombie tasks
    pub fn reap_zombies(&self) -> usize {
        let mut tasks = self.tasks.lock();
        let zombies: Vec<Pid> = tasks
            .iter()
            .filter(|(_, t)| t.get_state() == TaskState::Zombie && !t.restart_on_exit)
            .map(|(pid, _)| *pid)
            .collect();
        
        let count = zombies.len();
        for pid in zombies {
            tasks.remove(&pid);
        }
        
        count
    }
    
    /// Get task by PID
    pub fn get_task(&self, pid: Pid) -> Option<Arc<Task>> {
        self.tasks.lock().get(&pid).cloned()
    }
    
    /// List all tasks
    pub fn list_tasks(&self) -> Vec<TaskInfo> {
        let current_time = crate::get_time_ms() as u64;
        self.tasks
            .lock()
            .values()
            .map(|t| t.info(current_time))
            .collect()
    }
    
    /// Get number of active tasks
    pub fn task_count(&self) -> usize {
        self.tasks.lock().len()
    }
    
    /// Get total tasks in all queues
    pub fn queued_count(&self) -> usize {
        let num_harts = self.num_harts.load(Ordering::Relaxed);
        let mut total = 0;
        for hart in 0..num_harts {
            total += self.queues[hart].lock().len();
        }
        total
    }
    
    /// Kill a task by PID
    pub fn kill(&self, pid: Pid) -> bool {
        if let Some(task) = self.tasks.lock().get(&pid) {
            task.mark_finished(137); // SIGKILL-like
            crate::klog::klog_info("sched", &alloc::format!(
                "Killed task '{}' (PID {})", task.name, pid
            ));
            true
        } else {
            false
        }
    }
}
</file>

<file path="kernel/src/tls.rs">
//! TLS 1.3 support for HTTPS connections using embedded-tls.
//!
//! This module provides full TLS 1.3 support for making secure HTTPS connections.
//! It uses the embedded-tls crate with AES-128-GCM-SHA256 cipher suite.
//!
//! ## Features
//! - TLS 1.3 handshake with modern cipher suites
//! - Blocking I/O wrapper for smoltcp TCP sockets
//! - Certificate verification disabled for development (NoVerify)
//!
//! ## Architecture
//! The TLS implementation uses a single-request-per-connection model:
//! 1. Establish TCP connection
//! 2. Perform TLS handshake
//! 3. Send HTTP request over TLS
//! 4. Receive HTTP response over TLS
//! 5. Close connection
//!
//! This matches the HTTP/1.1 "Connection: close" behavior and avoids
//! complex lifetime management in a no_std environment.

use alloc::vec::Vec;
use embedded_io::{ErrorType, Read, Write};

// Re-export embedded-tls types we use
pub use embedded_tls::blocking::{Aes128GcmSha256, TlsConfig, TlsContext, NoVerify, TlsConnection};
pub use embedded_tls::TlsError as EmbeddedTlsError;

// ═══════════════════════════════════════════════════════════════════════════════
// SIMPLE RNG - Using timer-based entropy
// ═══════════════════════════════════════════════════════════════════════════════

/// Simple RNG using CLINT timer as entropy source.
/// 
/// Note: This is NOT cryptographically secure in a production sense,
/// but provides functional randomness for TLS handshakes in our
/// bare-metal environment. For production use, consider adding
/// a hardware RNG or entropy accumulator.
pub struct SimpleRng {
    state: u64,
}

impl SimpleRng {
    pub fn new() -> Self {
        // Seed from timer
        const CLINT_MTIME: usize = 0x0200_BFF8;
        let seed = unsafe { core::ptr::read_volatile(CLINT_MTIME as *const u64) };
        // Mix in some additional entropy from multiple timer reads
        let mut state = seed ^ 0xdeadbeef_cafebabe;
        for _ in 0..10 {
            let t = unsafe { core::ptr::read_volatile(CLINT_MTIME as *const u64) };
            state = state.wrapping_mul(6364136223846793005).wrapping_add(t);
        }
        Self { state }
    }
    
    fn next_u64(&mut self) -> u64 {
        // xorshift128+ style PRNG for better quality
        let mut s = self.state;
        s ^= s << 13;
        s ^= s >> 7;
        s ^= s << 17;
        self.state = s;
        s
    }
}

impl Default for SimpleRng {
    fn default() -> Self {
        Self::new()
    }
}

impl rand_core::RngCore for SimpleRng {
    fn next_u32(&mut self) -> u32 {
        self.next_u64() as u32
    }
    
    fn next_u64(&mut self) -> u64 {
        SimpleRng::next_u64(self)
    }
    
    fn fill_bytes(&mut self, dest: &mut [u8]) {
        let mut i = 0;
        while i < dest.len() {
            let r = self.next_u64().to_le_bytes();
            let remaining = dest.len() - i;
            let to_copy = remaining.min(8);
            dest[i..i + to_copy].copy_from_slice(&r[..to_copy]);
            i += to_copy;
        }
    }
    
    fn try_fill_bytes(&mut self, dest: &mut [u8]) -> Result<(), rand_core::Error> {
        self.fill_bytes(dest);
        Ok(())
    }
}

// Required for TLS - marks this as suitable for cryptographic use
// WARNING: In production, use a proper CSPRNG with hardware entropy
impl rand_core::CryptoRng for SimpleRng {}

// ═══════════════════════════════════════════════════════════════════════════════
// ERROR TYPES
// ═══════════════════════════════════════════════════════════════════════════════

/// Error type for TLS operations
#[derive(Debug, Clone, Copy)]
pub enum TlsError {
    /// TCP connection error
    ConnectionError,
    /// TLS handshake or protocol error
    TlsProtocolError,
    /// Operation timed out
    Timeout,
    /// Invalid data received
    InvalidData,
    /// I/O error
    Io,
    /// Connection closed
    ConnectionClosed,
    /// Handshake not completed
    NotConnected,
    /// DNS resolution failed
    DnsError,
    /// Internal error
    InternalError,
}

impl core::fmt::Display for TlsError {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        match self {
            TlsError::ConnectionError => write!(f, "Connection error"),
            TlsError::TlsProtocolError => write!(f, "TLS protocol error"),
            TlsError::Timeout => write!(f, "Timeout"),
            TlsError::InvalidData => write!(f, "Invalid data"),
            TlsError::Io => write!(f, "I/O error"),
            TlsError::ConnectionClosed => write!(f, "Connection closed"),
            TlsError::NotConnected => write!(f, "Not connected"),
            TlsError::DnsError => write!(f, "DNS error"),
            TlsError::InternalError => write!(f, "Internal error"),
        }
    }
}

impl embedded_io::Error for TlsError {
    fn kind(&self) -> embedded_io::ErrorKind {
        match self {
            TlsError::ConnectionClosed => embedded_io::ErrorKind::ConnectionReset,
            TlsError::Timeout => embedded_io::ErrorKind::TimedOut,
            _ => embedded_io::ErrorKind::Other,
        }
    }
}

impl From<EmbeddedTlsError> for TlsError {
    fn from(e: EmbeddedTlsError) -> Self {
        match e {
            EmbeddedTlsError::ConnectionClosed => TlsError::ConnectionClosed,
            EmbeddedTlsError::IoError => TlsError::Io,
            EmbeddedTlsError::Io(_) => TlsError::Io,
            _ => TlsError::TlsProtocolError,
        }
    }
}

// ═══════════════════════════════════════════════════════════════════════════════
// BLOCKING TCP SOCKET
// ═══════════════════════════════════════════════════════════════════════════════

/// Blocking TCP socket that implements embedded-io traits.
/// This allows embedded-tls to use our smoltcp-based TCP stack.
///
/// The socket holds mutable references to the network state and timing function,
/// and provides blocking read/write operations with timeout support.
pub struct BlockingTcpSocket<'a> {
    net: &'a mut crate::net::NetState,
    timeout_ms: i64,
    get_time: fn() -> i64,
    start_time: i64,
}

impl<'a> BlockingTcpSocket<'a> {
    /// Create a new blocking TCP socket wrapper.
    pub fn new(
        net: &'a mut crate::net::NetState,
        timeout_ms: i64,
        get_time: fn() -> i64,
    ) -> Self {
        let start_time = get_time();
        Self {
            net,
            timeout_ms,
            get_time,
            start_time,
        }
    }
    
    /// Reset the timeout timer (call after successful operations).
    pub fn reset_timeout(&mut self) {
        self.start_time = (self.get_time)();
    }
    
    /// Check if we've exceeded the timeout.
    fn check_timeout(&self) -> bool {
        let now = (self.get_time)();
        now - self.start_time > self.timeout_ms
    }
    
    /// Poll the network stack.
    fn poll_network(&mut self) {
        let now = (self.get_time)();
        self.net.poll(now);
    }
    
    /// Small delay to avoid busy-waiting.
    fn small_delay(&self) {
        for _ in 0..1000 {
            core::hint::spin_loop();
        }
    }
    
    /// Connect to a remote host (TCP only, no TLS).
    pub fn connect(&mut self, ip: smoltcp::wire::Ipv4Address, port: u16) -> Result<(), TlsError> {
        let now = (self.get_time)();
        self.net.tcp_connect(ip, port, now)
            .map_err(|_| TlsError::ConnectionError)?;
        
        // Wait for TCP connection to establish
        self.reset_timeout();
        loop {
            if self.check_timeout() {
                self.net.tcp_abort();
                return Err(TlsError::Timeout);
            }
            
            self.poll_network();
            
            if self.net.tcp_is_connected() {
                self.reset_timeout();
                return Ok(());
            }
            
            if self.net.tcp_connection_failed() {
                return Err(TlsError::ConnectionError);
            }
            
            self.small_delay();
        }
    }
    
    /// Close the TCP connection.
    pub fn close(&mut self) {
        let now = (self.get_time)();
        self.net.tcp_close(now);
    }
    
    /// Abort the TCP connection immediately.
    pub fn abort(&mut self) {
        self.net.tcp_abort();
    }
}

impl ErrorType for BlockingTcpSocket<'_> {
    type Error = TlsError;
}

impl Read for BlockingTcpSocket<'_> {
    fn read(&mut self, buf: &mut [u8]) -> Result<usize, Self::Error> {
        let mut poll_count = 0u32;
        loop {
            if self.check_timeout() {
                // Debug: Print TCP state on timeout
                crate::uart::write_str("TCP read timeout after ");
                let mut num_buf = [0u8; 12];
                let n = format_u32(poll_count, &mut num_buf);
                crate::uart::write_str(core::str::from_utf8(&num_buf[..n]).unwrap_or("?"));
                crate::uart::write_str(" polls, state=");
                crate::uart::write_line(self.net.tcp_state());
                return Err(TlsError::Timeout);
            }
            
            self.poll_network();
            poll_count += 1;
            
            let now = (self.get_time)();
            match self.net.tcp_recv(buf, now) {
                Ok(n) if n > 0 => {
                    self.reset_timeout();
                    return Ok(n);
                }
                Ok(_) => {
                    // No data available yet
                    if self.net.tcp_connection_failed() {
                        crate::uart::write_str("TCP connection failed, state=");
                        crate::uart::write_line(self.net.tcp_state());
                        return Err(TlsError::ConnectionClosed);
                    }
                    self.small_delay();
                }
                Err(e) => {
                    if e == "Connection closed by peer" {
                        return Err(TlsError::ConnectionClosed);
                    }
                    return Err(TlsError::ConnectionError);
                }
            }
        }
    }
}

/// Format u32 as decimal string
fn format_u32(mut n: u32, buf: &mut [u8]) -> usize {
    if n == 0 {
        buf[0] = b'0';
        return 1;
    }
    let mut i = 0;
    let mut tmp = [0u8; 10];
    while n > 0 {
        tmp[i] = b'0' + (n % 10) as u8;
        n /= 10;
        i += 1;
    }
    for j in 0..i {
        buf[j] = tmp[i - 1 - j];
    }
    i
}

impl Write for BlockingTcpSocket<'_> {
    fn write(&mut self, buf: &[u8]) -> Result<usize, Self::Error> {
        let mut total_sent = 0;
        
        while total_sent < buf.len() {
            if self.check_timeout() {
                return if total_sent > 0 {
                    Ok(total_sent)
                } else {
                    Err(TlsError::Timeout)
                };
            }
            
            self.poll_network();
            let now = (self.get_time)();
            
            match self.net.tcp_send(&buf[total_sent..], now) {
                Ok(n) if n > 0 => {
                    total_sent += n;
                    self.reset_timeout();
                }
                Ok(_) => {
                    // Buffer full, wait a bit
                    self.small_delay();
                }
                Err(_) => {
                    return if total_sent > 0 {
                        Ok(total_sent)
                    } else {
                        Err(TlsError::ConnectionError)
                    };
                }
            }
        }
        
        Ok(total_sent)
    }
    
    fn flush(&mut self) -> Result<(), Self::Error> {
        self.poll_network();
        Ok(())
    }
}

// ═══════════════════════════════════════════════════════════════════════════════
// TLS HTTPS REQUEST - High-level HTTPS API
// ═══════════════════════════════════════════════════════════════════════════════

/// Buffer sizes for TLS records.
/// Maximum TLS record size is 16KB, plus overhead for encryption.
/// Write buffer must be large enough for the TLS handshake (~2KB minimum).
const TLS_READ_BUFFER_SIZE: usize = 16640;
const TLS_WRITE_BUFFER_SIZE: usize = 8192;

/// Perform a complete HTTPS request and return the response.
///
/// This function handles the entire HTTPS request lifecycle:
/// 1. Establish TCP connection
/// 2. Perform TLS 1.3 handshake
/// 3. Send HTTP request over encrypted connection
/// 4. Receive and return HTTP response
/// 5. Close connection
///
/// # Arguments
/// * `net` - Network state
/// * `ip` - Server IP address
/// * `port` - Server port (typically 443)
/// * `hostname` - Server hostname (for SNI)
/// * `request_bytes` - Complete HTTP request as bytes
/// * `timeout_ms` - Timeout in milliseconds
/// * `get_time` - Function to get current time in milliseconds
///
/// # Returns
/// Response body as bytes on success, or TlsError on failure.
pub fn https_request(
    net: &mut crate::net::NetState,
    ip: smoltcp::wire::Ipv4Address,
    port: u16,
    hostname: &str,
    request_bytes: &[u8],
    timeout_ms: i64,
    get_time: fn() -> i64,
) -> Result<Vec<u8>, TlsError> {
    // Allocate TLS buffers
    let mut read_buffer = alloc::vec![0u8; TLS_READ_BUFFER_SIZE];
    let mut write_buffer = alloc::vec![0u8; TLS_WRITE_BUFFER_SIZE];
    let mut rng = SimpleRng::new();
    
    // Create blocking TCP socket and connect
    crate::uart::write_str("TLS: Connecting to port ");
    let mut port_buf = [0u8; 8];
    let port_len = format_u16(port, &mut port_buf);
    crate::uart::write_line(core::str::from_utf8(&port_buf[..port_len]).unwrap_or("?"));
    
    let mut socket = BlockingTcpSocket::new(net, timeout_ms, get_time);
    socket.connect(ip, port).map_err(|e| {
        crate::uart::write_line("TLS: TCP connection failed");
        e
    })?;
    
    crate::uart::write_line("TLS: TCP connected");
    
    // Create TLS config with SNI
    let config: TlsConfig<'_, Aes128GcmSha256> = TlsConfig::new()
        .with_server_name(hostname);
    
    // Create TLS connection wrapping our TCP socket
    let mut tls: TlsConnection<'_, BlockingTcpSocket<'_>, Aes128GcmSha256> = 
        TlsConnection::new(
            socket,
            &mut read_buffer,
            &mut write_buffer,
        );
    
    // Create context with config and RNG
    let context = TlsContext::new(&config, &mut rng);
    
    // Perform TLS 1.3 handshake
    crate::uart::write_str("TLS: Starting handshake with ");
    crate::uart::write_line(hostname);
    
    tls.open::<_, NoVerify>(context).map_err(|e| {
        crate::uart::write_str("TLS: Handshake failed - ");
        log_tls_error(&e);
        TlsError::from(e)
    })?;
    
    crate::uart::write_line("TLS: Handshake complete");
    
    // Send HTTP request over TLS
    let mut sent = 0;
    while sent < request_bytes.len() {
        match tls.write(&request_bytes[sent..]) {
            Ok(n) if n > 0 => sent += n,
            Ok(_) => {}
            Err(e) => {
                let _ = tls.close();
                return Err(TlsError::from(e));
            }
        }
    }
    
    // Flush to ensure all data is sent
    if let Err(e) = tls.flush() {
        let _ = tls.close();
        return Err(TlsError::from(e));
    }
    
    // Receive HTTP response over TLS
    let mut response_buf = Vec::with_capacity(8192);
    let mut recv_buf = [0u8; 1024];
    
    loop {
        match tls.read(&mut recv_buf) {
            Ok(0) => {
                // Connection closed, we have the full response
                break;
            }
            Ok(n) => {
                response_buf.extend_from_slice(&recv_buf[..n]);
                
                // Check if we've received a complete HTTP response
                if is_http_response_complete(&response_buf) {
                    break;
                }
            }
            Err(EmbeddedTlsError::ConnectionClosed) => {
                // Server closed connection, this is normal for Connection: close
                break;
            }
            Err(e) => {
                let _ = tls.close();
                return Err(TlsError::from(e));
            }
        }
    }
    
    // Close TLS connection cleanly
    let _ = tls.close();
    
    Ok(response_buf)
}

/// Check if we've received a complete HTTP response.
fn is_http_response_complete(data: &[u8]) -> bool {
    // Find end of headers
    let header_end = match find_header_end(data) {
        Some(pos) => pos,
        None => return false,
    };
    
    let body_start = header_end + 4;
    
    // Try to parse Content-Length
    if let Ok(headers_str) = core::str::from_utf8(&data[..header_end]) {
        for line in headers_str.lines() {
            let lower = line.to_lowercase();
            if lower.starts_with("content-length:") {
                if let Some(len_str) = line.split(':').nth(1) {
                    if let Ok(content_length) = len_str.trim().parse::<usize>() {
                        let body_len = data.len().saturating_sub(body_start);
                        return body_len >= content_length;
                    }
                }
            }
            // Check for Transfer-Encoding: chunked - harder to parse
            if lower.starts_with("transfer-encoding:") && lower.contains("chunked") {
                // For chunked, check if we have the final chunk marker
                return data.windows(5).any(|w| w == b"0\r\n\r\n");
            }
        }
    }
    
    // No Content-Length header, assume complete if we have headers + some body
    data.len() > body_start
}

/// Find the end of HTTP headers (double CRLF).
fn find_header_end(data: &[u8]) -> Option<usize> {
    for i in 0..data.len().saturating_sub(3) {
        if data[i] == b'\r' && data[i + 1] == b'\n' 
           && data[i + 2] == b'\r' && data[i + 3] == b'\n' {
            return Some(i);
        }
    }
    None
}

/// Log TLS error details for debugging.
fn log_tls_error(e: &EmbeddedTlsError) {
    crate::uart::write_str("TLS error: ");
    match e {
        EmbeddedTlsError::HandshakeAborted(level, desc) => {
            crate::uart::write_str("Handshake aborted (level=");
            let mut buf = [0u8; 20];
            let n = format_u8(*level as u8, &mut buf);
            crate::uart::write_str(core::str::from_utf8(&buf[..n]).unwrap_or("?"));
            crate::uart::write_str(", desc=");
            let n = format_u8(*desc as u8, &mut buf);
            crate::uart::write_str(core::str::from_utf8(&buf[..n]).unwrap_or("?"));
            crate::uart::write_line(")");
        }
        EmbeddedTlsError::InvalidCertificate => crate::uart::write_line("Invalid certificate"),
        EmbeddedTlsError::InvalidSignature => crate::uart::write_line("Invalid signature"),
        EmbeddedTlsError::InvalidHandshake => crate::uart::write_line("Invalid handshake (server may not support TLS 1.3)"),
        EmbeddedTlsError::InvalidRecord => crate::uart::write_line("Invalid record"),
        EmbeddedTlsError::InvalidSupportedVersions => crate::uart::write_line("Invalid supported versions (server may not support TLS 1.3)"),
        EmbeddedTlsError::ConnectionClosed => crate::uart::write_line("Connection closed by server"),
        EmbeddedTlsError::IoError => crate::uart::write_line("I/O error"),
        EmbeddedTlsError::DecodeError => crate::uart::write_line("Decode error (incompatible TLS version?)"),
        EmbeddedTlsError::Io(k) => {
            crate::uart::write_str("I/O: ");
            crate::uart::write_line(match k {
                embedded_io::ErrorKind::Other => "Other",
                embedded_io::ErrorKind::NotFound => "NotFound",
                embedded_io::ErrorKind::PermissionDenied => "PermissionDenied",
                embedded_io::ErrorKind::ConnectionRefused => "ConnectionRefused",
                embedded_io::ErrorKind::ConnectionReset => "ConnectionReset",
                embedded_io::ErrorKind::ConnectionAborted => "ConnectionAborted",
                embedded_io::ErrorKind::NotConnected => "NotConnected",
                embedded_io::ErrorKind::AddrInUse => "AddrInUse",
                embedded_io::ErrorKind::AddrNotAvailable => "AddrNotAvailable",
                embedded_io::ErrorKind::BrokenPipe => "BrokenPipe",
                embedded_io::ErrorKind::AlreadyExists => "AlreadyExists",
                embedded_io::ErrorKind::InvalidInput => "InvalidInput",
                embedded_io::ErrorKind::InvalidData => "InvalidData",
                embedded_io::ErrorKind::TimedOut => "TimedOut",
                embedded_io::ErrorKind::Interrupted => "Interrupted",
                embedded_io::ErrorKind::Unsupported => "Unsupported",
                embedded_io::ErrorKind::OutOfMemory => "OutOfMemory",
                _ => "Unknown",
            });
        }
        _ => crate::uart::write_line("Unknown error (check TLS 1.3 compatibility)"),
    }
}

// ═══════════════════════════════════════════════════════════════════════════════
// HTTPS GET HELPER
// ═══════════════════════════════════════════════════════════════════════════════

/// Perform an HTTPS GET request.
///
/// This is a convenience function that builds the HTTP request and calls `https_request`.
///
/// # Arguments
/// * `net` - Network state
/// * `hostname` - Server hostname (used for DNS and SNI)
/// * `ip` - Server IP (if already resolved)
/// * `port` - Server port (typically 443)
/// * `path` - Request path (e.g., "/api/data")
/// * `timeout_ms` - Timeout in milliseconds
/// * `get_time` - Function to get current time in milliseconds
///
/// # Returns
/// Response bytes on success, or TlsError on failure.
pub fn https_get(
    net: &mut crate::net::NetState,
    hostname: &str,
    ip: smoltcp::wire::Ipv4Address,
    port: u16,
    path: &str,
    timeout_ms: i64,
    get_time: fn() -> i64,
) -> Result<Vec<u8>, TlsError> {
    // Build HTTP GET request
    let request = alloc::format!(
        "GET {} HTTP/1.1\r\n\
         Host: {}\r\n\
         User-Agent: BAVY OS/{}\r\n\
         Accept: */*\r\n\
         Connection: close\r\n\
         \r\n",
        path, hostname, env!("CARGO_PKG_VERSION")
    );
    
    https_request(net, ip, port, hostname, request.as_bytes(), timeout_ms, get_time)
}

/// Resolve hostname and perform HTTPS GET request.
///
/// This function handles DNS resolution before making the request.
pub fn https_get_url(
    net: &mut crate::net::NetState,
    hostname: &str,
    port: u16,
    path: &str,
    timeout_ms: i64,
    get_time: fn() -> i64,
) -> Result<Vec<u8>, TlsError> {
    // Try to parse as IP first
    if let Some(ip) = crate::net::parse_ipv4(hostname.as_bytes()) {
        return https_get(net, hostname, ip, port, path, timeout_ms, get_time);
    }
    
    // Resolve via DNS
    let ip = crate::dns::resolve(
        net, 
        hostname.as_bytes(), 
        crate::net::DNS_SERVER, 
        timeout_ms, 
        get_time
    ).ok_or(TlsError::DnsError)?;
    
    https_get(net, hostname, ip, port, path, timeout_ms, get_time)
}

// ═══════════════════════════════════════════════════════════════════════════════
// PUBLIC API
// ═══════════════════════════════════════════════════════════════════════════════

/// Check if TLS/HTTPS is available.
///
/// Returns true if TLS 1.3 support is compiled in and functional.
pub fn is_available() -> bool {
    true
}

/// Get TLS status message.
pub fn status() -> &'static str {
    "TLS 1.3 only (AES-128-GCM-SHA256, no cert verification)"
}

// ═══════════════════════════════════════════════════════════════════════════════
// UTILITY FUNCTIONS
// ═══════════════════════════════════════════════════════════════════════════════

/// Format a u8 as decimal string.
pub fn format_u8(n: u8, buf: &mut [u8]) -> usize {
    if n >= 100 {
        buf[0] = b'0' + (n / 100);
        buf[1] = b'0' + ((n / 10) % 10);
        buf[2] = b'0' + (n % 10);
        3
    } else if n >= 10 {
        buf[0] = b'0' + (n / 10);
        buf[1] = b'0' + (n % 10);
        2
    } else {
        buf[0] = b'0' + n;
        1
    }
}

/// Format a u16 as decimal string.
pub fn format_u16(mut n: u16, buf: &mut [u8]) -> usize {
    if n == 0 {
        buf[0] = b'0';
        return 1;
    }
    let mut i = 0;
    let mut tmp = [0u8; 5];
    while n > 0 {
        tmp[i] = b'0' + (n % 10) as u8;
        n /= 10;
        i += 1;
    }
    // Reverse into buf
    for j in 0..i {
        buf[j] = tmp[i - 1 - j];
    }
    i
}
</file>

<file path="kernel/src/virtio_net.rs">
//! VirtIO Network Driver for the kernel.
//!
//! This driver communicates with the VirtIO MMIO network device
//! to send and receive Ethernet frames.

use core::ptr::{read_volatile, write_volatile};

/// VirtIO MMIO base address for first device slot.
pub const VIRTIO_BASE: usize = 0x1000_1000;
/// VirtIO MMIO stride between devices.
pub const VIRTIO_STRIDE: usize = 0x1000;
/// Maximum number of VirtIO devices to scan.
pub const VIRTIO_MAX_DEVICES: usize = 8;

/// Legacy constant for compatibility.
pub const VIRTIO_NET_BASE: usize = VIRTIO_BASE;

// MMIO register offsets
const MAGIC_VALUE_OFFSET: usize = 0x000;
const VERSION_OFFSET: usize = 0x004;
const DEVICE_ID_OFFSET: usize = 0x008;
#[allow(dead_code)]
const VENDOR_ID_OFFSET: usize = 0x00c;
const DEVICE_FEATURES_OFFSET: usize = 0x010;
const DEVICE_FEATURES_SEL_OFFSET: usize = 0x014;
const DRIVER_FEATURES_OFFSET: usize = 0x020;
const DRIVER_FEATURES_SEL_OFFSET: usize = 0x024;
const GUEST_PAGE_SIZE_OFFSET: usize = 0x028;
const QUEUE_SEL_OFFSET: usize = 0x030;
const QUEUE_NUM_MAX_OFFSET: usize = 0x034;
const QUEUE_NUM_OFFSET: usize = 0x038;
const QUEUE_PFN_OFFSET: usize = 0x040;
#[allow(dead_code)]
const QUEUE_READY_OFFSET: usize = 0x044;
const QUEUE_NOTIFY_OFFSET: usize = 0x050;
const INTERRUPT_STATUS_OFFSET: usize = 0x060;
const INTERRUPT_ACK_OFFSET: usize = 0x064;
const STATUS_OFFSET: usize = 0x070;
const CONFIG_SPACE_OFFSET: usize = 0x100;

// Expected values
const VIRTIO_MAGIC: u32 = 0x7472_6976;
const VIRTIO_VERSION: u32 = 2;
const VIRTIO_NET_DEVICE_ID: u32 = 1;

// Device status bits
const STATUS_ACKNOWLEDGE: u32 = 1;
const STATUS_DRIVER: u32 = 2;
const STATUS_FEATURES_OK: u32 = 8;
const STATUS_DRIVER_OK: u32 = 4;

// Feature bits
const VIRTIO_NET_F_MAC: u32 = 1 << 5;
const VIRTIO_NET_F_STATUS: u32 = 1 << 16;

// Descriptor flags
#[allow(dead_code)]
const VRING_DESC_F_NEXT: u16 = 1;
const VRING_DESC_F_WRITE: u16 = 2;

/// Queue size (number of descriptors)
pub const QUEUE_SIZE: usize = 16;

/// Page size for queue alignment
const PAGE_SIZE: usize = 4096;

/// VirtIO descriptor structure (16 bytes)
#[repr(C)]
#[derive(Clone, Copy, Default)]
pub struct VirtqDesc {
    pub addr: u64,   // Physical address of buffer
    pub len: u32,    // Length of buffer
    pub flags: u16,  // Descriptor flags
    pub next: u16,   // Next descriptor index (if NEXT flag set)
}

/// VirtIO available ring
#[repr(C)]
pub struct VirtqAvail {
    pub flags: u16,
    pub idx: u16,
    pub ring: [u16; QUEUE_SIZE],
    pub used_event: u16,
}

/// VirtIO used ring element
#[repr(C)]
#[derive(Clone, Copy, Default)]
pub struct VirtqUsedElem {
    pub id: u32,  // Descriptor chain head index
    pub len: u32, // Total bytes written to descriptor buffers
}

/// VirtIO used ring
#[repr(C)]
pub struct VirtqUsed {
    pub flags: u16,
    pub idx: u16,
    pub ring: [VirtqUsedElem; QUEUE_SIZE],
    pub avail_event: u16,
}

/// VirtIO network header (prepended to all packets)
#[repr(C)]
#[derive(Clone, Copy, Default)]
pub struct VirtioNetHdr {
    pub flags: u8,
    pub gso_type: u8,
    pub hdr_len: u16,
    pub gso_size: u16,
    pub csum_start: u16,
    pub csum_offset: u16,
    pub num_buffers: u16,  // Only for mergeable rx buffers
}

impl VirtioNetHdr {
    pub const SIZE: usize = 12; // We use 12 bytes (includes num_buffers for alignment)
}

/// A single virtqueue
pub struct VirtQueue {
    /// Descriptor table
    pub desc: &'static mut [VirtqDesc; QUEUE_SIZE],
    /// Available ring
    pub avail: &'static mut VirtqAvail,
    /// Used ring
    pub used: &'static mut VirtqUsed,
    /// Index of next descriptor to allocate
    free_head: u16,
    /// Number of free descriptors
    num_free: u16,
    /// Last seen used index
    last_used_idx: u16,
    /// Queue index (0 = RX, 1 = TX)
    #[allow(dead_code)]
    queue_idx: u16,
}

impl VirtQueue {
    /// Create a new virtqueue at the given memory address.
    /// Memory must be page-aligned and zeroed.
    pub unsafe fn new(mem: *mut u8, queue_idx: u16) -> Self {
        // Layout: Descriptors | Avail | padding | Used
        let desc = &mut *(mem as *mut [VirtqDesc; QUEUE_SIZE]);
        let avail = &mut *(mem.add(QUEUE_SIZE * 16) as *mut VirtqAvail);
        
        // Used ring must be page-aligned
        let avail_end = mem.add(QUEUE_SIZE * 16 + 6 + 2 * QUEUE_SIZE) as usize;
        let used_start = (avail_end + PAGE_SIZE - 1) & !(PAGE_SIZE - 1);
        let used = &mut *(used_start as *mut VirtqUsed);
        
        // Initialize descriptor free list
        for i in 0..QUEUE_SIZE as u16 {
            desc[i as usize].next = i + 1;
        }
        
        VirtQueue {
            desc,
            avail,
            used,
            free_head: 0,
            num_free: QUEUE_SIZE as u16,
            last_used_idx: 0,
            queue_idx,
        }
    }
    
    /// Allocate a descriptor from the free list
    pub fn alloc_desc(&mut self) -> Option<u16> {
        if self.num_free == 0 {
            return None;
        }
        let idx = self.free_head;
        self.free_head = self.desc[idx as usize].next;
        self.num_free -= 1;
        Some(idx)
    }
    
    /// Free a descriptor back to the free list
    pub fn free_desc(&mut self, idx: u16) {
        self.desc[idx as usize].next = self.free_head;
        self.free_head = idx;
        self.num_free += 1;
    }
    
    /// Add a buffer to the available ring
    pub fn push_avail(&mut self, desc_idx: u16) {
        let avail_idx = unsafe { read_volatile(&self.avail.idx) };
        self.avail.ring[(avail_idx as usize) % QUEUE_SIZE] = desc_idx;
        // Memory barrier
        core::sync::atomic::fence(core::sync::atomic::Ordering::SeqCst);
        unsafe { write_volatile(&mut self.avail.idx, avail_idx.wrapping_add(1)) };
    }
    
    /// Check if there are used buffers to process
    #[allow(dead_code)]
    pub fn has_used(&self) -> bool {
        let used_idx = unsafe { read_volatile(&self.used.idx) };
        self.last_used_idx != used_idx
    }
    
    /// Pop a used buffer (returns descriptor index and length)
    pub fn pop_used(&mut self) -> Option<(u16, u32)> {
        let used_idx = unsafe { read_volatile(&self.used.idx) };
        if self.last_used_idx == used_idx {
            return None;
        }
        
        let elem = &self.used.ring[(self.last_used_idx as usize) % QUEUE_SIZE];
        let id = elem.id as u16;
        let len = elem.len;
        
        self.last_used_idx = self.last_used_idx.wrapping_add(1);
        Some((id, len))
    }
}

/// RX buffer entry
struct RxBuffer {
    desc_idx: u16,
    data: [u8; 1526], // Max ethernet frame + virtio header
}

/// TX buffer entry  
struct TxBuffer {
    desc_idx: u16,
    data: [u8; 1526],
}

/// VirtIO Network Driver
pub struct VirtioNet {
    base: usize,
    pub mac: [u8; 6],
    rx_queue: VirtQueue,
    tx_queue: VirtQueue,
    rx_buffers: [Option<RxBuffer>; QUEUE_SIZE],
    tx_buffers: [Option<TxBuffer>; QUEUE_SIZE],
}

// Static storage for queues (must be page-aligned)
#[repr(C, align(4096))]
struct QueueMem {
    data: [u8; PAGE_SIZE * 2],
}

static mut RX_QUEUE_MEM: QueueMem = QueueMem { data: [0; PAGE_SIZE * 2] };
static mut TX_QUEUE_MEM: QueueMem = QueueMem { data: [0; PAGE_SIZE * 2] };

impl VirtioNet {
    /// Read a 32-bit MMIO register
    fn read32(&self, offset: usize) -> u32 {
        unsafe { read_volatile((self.base + offset) as *const u32) }
    }
    
    /// Write a 32-bit MMIO register
    fn write32(&self, offset: usize, val: u32) {
        unsafe { write_volatile((self.base + offset) as *mut u32, val) }
    }
    
    /// Read an 8-bit config space register
    fn read_config8(&self, offset: usize) -> u8 {
        unsafe { read_volatile((self.base + CONFIG_SPACE_OFFSET + offset) as *const u8) }
    }
    
    /// Probe for a VirtIO network device by scanning all VirtIO slots.
    /// Returns None if no valid network device found.
    pub fn probe() -> Option<Self> {
        for i in 0..VIRTIO_MAX_DEVICES {
            let addr = VIRTIO_BASE + i * VIRTIO_STRIDE;
            if let Some(dev) = Self::probe_at(addr) {
                return Some(dev);
            }
        }
        None
    }
    
    /// Probe for a VirtIO network device at the given address.
    pub fn probe_at(base: usize) -> Option<Self> {
        let magic = unsafe { read_volatile((base + MAGIC_VALUE_OFFSET) as *const u32) };
        if magic != VIRTIO_MAGIC {
            return None;
        }
        
        let version = unsafe { read_volatile((base + VERSION_OFFSET) as *const u32) };
        if version != VIRTIO_VERSION {
            return None;
        }
        
        let device_id = unsafe { read_volatile((base + DEVICE_ID_OFFSET) as *const u32) };
        if device_id != VIRTIO_NET_DEVICE_ID {
            return None;
        }
        
        // Create uninitialized driver
        let rx_queue = unsafe { VirtQueue::new(RX_QUEUE_MEM.data.as_mut_ptr(), 0) };
        let tx_queue = unsafe { VirtQueue::new(TX_QUEUE_MEM.data.as_mut_ptr(), 1) };
        
        const NONE_RX: Option<RxBuffer> = None;
        const NONE_TX: Option<TxBuffer> = None;
        
        Some(VirtioNet {
            base,
            mac: [0; 6],
            rx_queue,
            tx_queue,
            rx_buffers: [NONE_RX; QUEUE_SIZE],
            tx_buffers: [NONE_TX; QUEUE_SIZE],
        })
    }
    
    /// Get the base address of this device
    pub fn base_addr(&self) -> usize {
        self.base
    }
    
    /// Initialize the device (phase 1: configure queues but don't populate RX buffers yet)
    pub fn init(&mut self) -> Result<(), &'static str> {
        // 1. Reset device
        self.write32(STATUS_OFFSET, 0);
        
        // 2. Set ACKNOWLEDGE status bit
        self.write32(STATUS_OFFSET, STATUS_ACKNOWLEDGE);
        
        // 3. Set DRIVER status bit
        self.write32(STATUS_OFFSET, STATUS_ACKNOWLEDGE | STATUS_DRIVER);
        
        // 4. Read device features
        self.write32(DEVICE_FEATURES_SEL_OFFSET, 0);
        let features = self.read32(DEVICE_FEATURES_OFFSET);
        
        // 5. Negotiate features (we want MAC and STATUS)
        let negotiated = features & (VIRTIO_NET_F_MAC | VIRTIO_NET_F_STATUS);
        self.write32(DRIVER_FEATURES_SEL_OFFSET, 0);
        self.write32(DRIVER_FEATURES_OFFSET, negotiated);
        
        // 6. Set FEATURES_OK
        self.write32(STATUS_OFFSET, STATUS_ACKNOWLEDGE | STATUS_DRIVER | STATUS_FEATURES_OK);
        
        // 7. Verify FEATURES_OK is still set
        let status = self.read32(STATUS_OFFSET);
        if status & STATUS_FEATURES_OK == 0 {
            return Err("Device did not accept features");
        }
        
        // 8. Set page size (legacy)
        self.write32(GUEST_PAGE_SIZE_OFFSET, PAGE_SIZE as u32);
        
        // 9. Configure RX queue (queue 0)
        self.write32(QUEUE_SEL_OFFSET, 0);
        let queue_max = self.read32(QUEUE_NUM_MAX_OFFSET);
        if queue_max < QUEUE_SIZE as u32 {
            return Err("RX queue too small");
        }
        self.write32(QUEUE_NUM_OFFSET, QUEUE_SIZE as u32);
        
        // Calculate PFN (page frame number) for RX queue
        let rx_pfn = unsafe { RX_QUEUE_MEM.data.as_ptr() as u64 / PAGE_SIZE as u64 };
        self.write32(QUEUE_PFN_OFFSET, rx_pfn as u32);
        
        // 10. Configure TX queue (queue 1)
        self.write32(QUEUE_SEL_OFFSET, 1);
        let queue_max = self.read32(QUEUE_NUM_MAX_OFFSET);
        if queue_max < QUEUE_SIZE as u32 {
            return Err("TX queue too small");
        }
        self.write32(QUEUE_NUM_OFFSET, QUEUE_SIZE as u32);
        
        let tx_pfn = unsafe { TX_QUEUE_MEM.data.as_ptr() as u64 / PAGE_SIZE as u64 };
        self.write32(QUEUE_PFN_OFFSET, tx_pfn as u32);
        
        // 11. Read MAC address from config space
        for i in 0..6 {
            self.mac[i] = self.read_config8(i);
        }
        
        // 12. Set DRIVER_OK
        self.write32(STATUS_OFFSET, STATUS_ACKNOWLEDGE | STATUS_DRIVER | STATUS_FEATURES_OK | STATUS_DRIVER_OK);
        
        // NOTE: RX queue population must happen AFTER the VirtioNet is moved to its final location!
        // Call finalize_init() after the containing struct is in place.
        
        Ok(())
    }
    
    /// Finalize initialization by populating RX buffers.
    /// Must be called AFTER the VirtioNet struct is in its final memory location!
    pub fn finalize_init(&mut self) {
        self.populate_rx_queue();
    }
    
    /// Populate the RX queue with empty buffers
    fn populate_rx_queue(&mut self) {
        for i in 0..QUEUE_SIZE {
            if self.rx_buffers[i].is_some() {
                continue;
            }
            
            let desc_idx = match self.rx_queue.alloc_desc() {
                Some(idx) => idx,
                None => break,
            };
            
            // Create and store buffer FIRST
            self.rx_buffers[i] = Some(RxBuffer {
                desc_idx,
                data: [0; 1526],
            });
            
            // Now get the address from the stored buffer (after it's been placed in its final location)
            let buffer = self.rx_buffers[i].as_ref().unwrap();
            
            // Set up descriptor (device writes to this buffer)
            let desc = &mut self.rx_queue.desc[desc_idx as usize];
            desc.addr = buffer.data.as_ptr() as u64;
            desc.len = buffer.data.len() as u32;
            desc.flags = VRING_DESC_F_WRITE;
            desc.next = 0;
            
            // Add to available ring
            self.rx_queue.push_avail(desc_idx);
        }
        
        // Notify device that RX buffers are available
        self.write32(QUEUE_NOTIFY_OFFSET, 0);
    }
    
    /// Receive a packet (returns None if no packet available)
    #[allow(dead_code)]
    pub fn recv(&mut self) -> Option<&[u8]> {
        // Check for used buffers
        let (desc_idx, total_len) = self.rx_queue.pop_used()?;
        
        // Find the buffer
        for buf_opt in &self.rx_buffers {
            if let Some(buf) = buf_opt {
                if buf.desc_idx == desc_idx {
                    // Skip virtio header (12 bytes)
                    let data_start = VirtioNetHdr::SIZE;
                    let data_len = total_len as usize - VirtioNetHdr::SIZE;
                    if data_len > 0 && data_start + data_len <= buf.data.len() {
                        return Some(&buf.data[data_start..data_start + data_len]);
                    }
                }
            }
        }
        None
    }
    
    /// Recycle an RX buffer after processing
    pub fn recycle_rx(&mut self, desc_idx: u16) {
        // Re-add to available ring
        self.rx_queue.push_avail(desc_idx);
        // Notify device
        self.write32(QUEUE_NOTIFY_OFFSET, 0);
    }
    
    /// Receive a packet with full control (returns desc_idx for recycling)
    pub fn recv_with_desc(&mut self) -> Option<(u16, &[u8])> {
        let (desc_idx, total_len) = self.rx_queue.pop_used()?;
        
        for buf_opt in &self.rx_buffers {
            if let Some(buf) = buf_opt {
                if buf.desc_idx == desc_idx {
                    let data_start = VirtioNetHdr::SIZE;
                    let data_len = (total_len as usize).saturating_sub(VirtioNetHdr::SIZE);
                    if data_len > 0 && data_start + data_len <= buf.data.len() {
                        return Some((desc_idx, &buf.data[data_start..data_start + data_len]));
                    }
                }
            }
        }
        None
    }
    
    /// Send a packet
    pub fn send(&mut self, data: &[u8]) -> Result<(), &'static str> {
        if data.len() > 1514 {
            return Err("Packet too large");
        }
        
        // Allocate descriptor
        let desc_idx = self.tx_queue.alloc_desc().ok_or("No TX descriptors available")?;
        
        // Find free TX buffer slot
        let mut slot_idx = None;
        for (i, buf_opt) in self.tx_buffers.iter().enumerate() {
            if buf_opt.is_none() {
                slot_idx = Some(i);
                break;
            }
        }
        let slot_idx = slot_idx.ok_or("No TX buffer slots")?;
        
        // Create buffer with virtio header + data
        let mut buffer = TxBuffer {
            desc_idx,
            data: [0; 1526],
        };
        
        // Write virtio header (all zeros)
        // Then copy packet data
        buffer.data[VirtioNetHdr::SIZE..VirtioNetHdr::SIZE + data.len()].copy_from_slice(data);
        
        // Set up descriptor
        let desc = &mut self.tx_queue.desc[desc_idx as usize];
        desc.addr = buffer.data.as_ptr() as u64;
        desc.len = (VirtioNetHdr::SIZE + data.len()) as u32;
        desc.flags = 0; // Device reads from this buffer
        desc.next = 0;
        
        self.tx_buffers[slot_idx] = Some(buffer);
        
        // Add to available ring
        self.tx_queue.push_avail(desc_idx);
        
        // Notify device
        self.write32(QUEUE_NOTIFY_OFFSET, 1);
        
        Ok(())
    }
    
    /// Process completed TX buffers
    pub fn process_tx(&mut self) {
        while let Some((desc_idx, _len)) = self.tx_queue.pop_used() {
            // Find and free the buffer
            for buf_opt in &mut self.tx_buffers {
                if let Some(buf) = buf_opt {
                    if buf.desc_idx == desc_idx {
                        *buf_opt = None;
                        break;
                    }
                }
            }
            // Return descriptor to free list
            self.tx_queue.free_desc(desc_idx);
        }
    }
    
    /// Poll for activity (call periodically)
    pub fn poll(&mut self) {
        // Process completed TX buffers
        self.process_tx();
        
        // Acknowledge interrupts
        let status = self.read32(INTERRUPT_STATUS_OFFSET);
        if status != 0 {
            self.write32(INTERRUPT_ACK_OFFSET, status);
        }
    }
    
    /// Check if the device has an interrupt pending
    #[allow(dead_code)]
    pub fn has_interrupt(&self) -> bool {
        self.read32(INTERRUPT_STATUS_OFFSET) != 0
    }
    
    /// Get MAC address as a formatted string
    pub fn mac_str(&self) -> [u8; 17] {
        let mut buf = [0u8; 17];
        let hex = b"0123456789abcdef";
        for i in 0..6 {
            buf[i * 3] = hex[(self.mac[i] >> 4) as usize];
            buf[i * 3 + 1] = hex[(self.mac[i] & 0xf) as usize];
            if i < 5 {
                buf[i * 3 + 2] = b':';
            }
        }
        buf
    }
    
    /// Read the IP address from the device configuration space.
    /// This is a custom extension (Config offset 8 = 0x108 absolute).
    /// Returns None if the IP is 0.0.0.0 (not yet assigned).
    pub fn get_config_ip(&self) -> Option<[u8; 4]> {
        // Read 32-bit value at config offset 8 (CONFIG_SPACE_OFFSET + 8)
        let ip_u32 = unsafe { 
            read_volatile((self.base + CONFIG_SPACE_OFFSET + 8) as *const u32) 
        };
        if ip_u32 == 0 {
            None
        } else {
            Some(ip_u32.to_le_bytes())
        }
    }
}
</file>

<file path="kernel/link.x">
PROVIDE(_stext = ORIGIN(REGION_TEXT));
PROVIDE(_stack_start = ORIGIN(REGION_STACK) + LENGTH(REGION_STACK));
/* Use direct assignment to override riscv-rt's default PROVIDE */
_max_hart_id = 7;              /* Support 8 harts (0-7), value is max ID */
_hart_stack_size = 128K;
_heap_size = 64M;

PROVIDE(UserSoft = DefaultHandler);
PROVIDE(SupervisorSoft = DefaultHandler);
PROVIDE(MachineSoft = DefaultHandler);
PROVIDE(UserTimer = DefaultHandler);
PROVIDE(SupervisorTimer = DefaultHandler);
PROVIDE(MachineTimer = DefaultHandler);
PROVIDE(UserExternal = DefaultHandler);
PROVIDE(SupervisorExternal = DefaultHandler);
PROVIDE(MachineExternal = DefaultHandler);

PROVIDE(DefaultHandler = DefaultInterruptHandler);
PROVIDE(ExceptionHandler = DefaultExceptionHandler);

/* # Pre-initialization function */
/* If the user overrides this using the `#[pre_init]` attribute or by creating a `__pre_init` function,
   then the function this points to will be called before the RAM is initialized. */
PROVIDE(__pre_init = default_pre_init);

/* A PAC/HAL defined routine that should initialize custom interrupt controller if needed. */
PROVIDE(_setup_interrupts = default_setup_interrupts);

/* # Multi-processing hook function
   fn _mp_hook() -> bool;

   This function is called from all the harts and must return true only for one hart,
   which will perform memory initialization. For other harts it must return false
   and implement wake-up in platform-dependent way (e.g. after waiting for a user interrupt).
*/
PROVIDE(_mp_hook = default_mp_hook);

/* # Start trap function override
  By default uses the riscv crates default trap handler
  but by providing the `_start_trap` symbol external crates can override.
*/
PROVIDE(_start_trap = default_start_trap);

SECTIONS
{
  .text.dummy (NOLOAD) :
  {
    /* This section is intended to make _stext address work */
    . = ABSOLUTE(_stext);
  } > REGION_TEXT

  .text _stext :
  {
    /* Put reset handler first in .text section so it ends up as the entry */
    /* point of the program. */
    KEEP(*(.init));
    KEEP(*(.init.rust));
    . = ALIGN(4);
    *(.trap);
    *(.trap.rust);

    /* Place critical runtime functions close to .init to stay within JAL range */
    /* These are functions referenced by riscv-rt startup code */
    *libriscv_rt*.rlib:*(.text .text.*);
    *libpanic_halt*.rlib:*(.text .text.*);
    
    /* Now place all other text sections */
    *(.text .text.*);
  } > REGION_TEXT

  .rodata : ALIGN(4)
  {
    *(.srodata .srodata.*);
    *(.rodata .rodata.*);

    /* 4-byte align the end (VMA) of this section.
       This is required by LLD to ensure the LMA of the following .data
       section will have the correct alignment. */
    . = ALIGN(4);
  } > REGION_RODATA

  .data : ALIGN(4)
  {
    _sidata = LOADADDR(.data);
    _sdata = .;
    /* Must be called __global_pointer$ for linker relaxations to work. */
    PROVIDE(__global_pointer$ = . + 0x800);
    *(.sdata .sdata.* .sdata2 .sdata2.*);
    *(.data .data.*);
    . = ALIGN(4);
    _edata = .;
  } > REGION_DATA AT > REGION_RODATA

  .bss (NOLOAD) :
  {
    _sbss = .;
    *(.sbss .sbss.* .bss .bss.*);
    . = ALIGN(4);
    _ebss = .;
  } > REGION_BSS

  /* fictitious region that represents the memory available for the heap */
  .heap (NOLOAD) :
  {
    _sheap = .;
    . += _heap_size;
    . = ALIGN(4);
    _eheap = .;
  } > REGION_HEAP

  /* fictitious region that represents the memory available for the stack */
  .stack (NOLOAD) :
  {
    _estack = .;
    . = ABSOLUTE(_stack_start);
    _sstack = .;
  } > REGION_STACK

  /* fake output .got section */
  /* Dynamic relocations are unsupported. This section is only used to detect
     relocatable code in the input files and raise an error if relocatable code
     is found */
  .got (INFO) :
  {
    KEEP(*(.got .got.*));
  }

  /DISCARD/ :
  {
    *(.eh_frame)
    *(.eh_frame_hdr)
  }
}

/* Do not exceed this mark in the error messages above                                    | */
ASSERT(ORIGIN(REGION_TEXT) % 4 == 0, "
ERROR(riscv-rt): the start of the REGION_TEXT must be 4-byte aligned");

ASSERT(ORIGIN(REGION_RODATA) % 4 == 0, "
ERROR(riscv-rt): the start of the REGION_RODATA must be 4-byte aligned");

ASSERT(ORIGIN(REGION_DATA) % 4 == 0, "
ERROR(riscv-rt): the start of the REGION_DATA must be 4-byte aligned");

ASSERT(ORIGIN(REGION_HEAP) % 4 == 0, "
ERROR(riscv-rt): the start of the REGION_HEAP must be 4-byte aligned");

ASSERT(ORIGIN(REGION_TEXT) % 4 == 0, "
ERROR(riscv-rt): the start of the REGION_TEXT must be 4-byte aligned");

ASSERT(ORIGIN(REGION_STACK) % 4 == 0, "
ERROR(riscv-rt): the start of the REGION_STACK must be 4-byte aligned");

ASSERT(_stext % 4 == 0, "
ERROR(riscv-rt): `_stext` must be 4-byte aligned");

ASSERT(_sdata % 4 == 0 && _edata % 4 == 0, "
BUG(riscv-rt): .data is not 4-byte aligned");

ASSERT(_sidata % 4 == 0, "
BUG(riscv-rt): the LMA of .data is not 4-byte aligned");

ASSERT(_sbss % 4 == 0 && _ebss % 4 == 0, "
BUG(riscv-rt): .bss is not 4-byte aligned");

ASSERT(_sheap % 4 == 0, "
BUG(riscv-rt): start of .heap is not 4-byte aligned");

ASSERT(_stext + SIZEOF(.text) < ORIGIN(REGION_TEXT) + LENGTH(REGION_TEXT), "
ERROR(riscv-rt): The .text section must be placed inside the REGION_TEXT region.
Set _stext to an address smaller than 'ORIGIN(REGION_TEXT) + LENGTH(REGION_TEXT)'");

ASSERT(SIZEOF(.stack) > (_max_hart_id + 1) * _hart_stack_size, "
ERROR(riscv-rt): .stack section is too small for allocating stacks for all the harts.
Consider changing `_max_hart_id` or `_hart_stack_size`.");

ASSERT(SIZEOF(.got) == 0, "
.got section detected in the input files. Dynamic relocations are not
supported. If you are linking to C code compiled using the `gcc` crate
then modify your build script to compile the C code _without_ the
-fPIC flag. See the documentation of the `gcc::Config.fpic` method for
details.");

/* Do not exceed this mark in the error messages above                                    | */
</file>

<file path="kernel/README.md">
# Custom RISC-V Kernel

A lightweight, bare-metal operating system kernel written in Rust for the RISC-V architecture. It serves as a demonstration of the VM's capabilities, featuring a command-line interface, memory management, and a TCP/IP networking stack.

## Features

- **Pure Rust**: Built with `#![no_std]` for bare-metal execution.
- **Networking**: Full TCP/IP stack via `smoltcp` driver for VirtIO-Net.
- **Memory Management**: Dynamic heap allocation using a linked-list allocator.
- **Interactive Shell**: Built-in UART console with command history and editing.
- **Device Drivers**:
  - VirtIO Network (Net)
  - UART Console
  - CLINT Timer

## Commands

The kernel boots into an interactive shell supporting the following commands:

| Command | Description |
|---------|-------------|
| `help` | Show available commands |
| `ip addr` | Display network interface configuration (IP/MAC/Gateway) |
| `ping <addr>` | Send ICMP Echo requests to an IP or hostname |
| `nslookup <host>` | Resolve a hostname to an IP address using DNS |
| `netstat` | Show network device status |
| `alloc <bytes>` | Allocate memory on the heap (debug) |
| `memstats` | Show heap usage statistics |
| `memtest` | Run memory allocation/deallocation stress tests |
| `clear` | Clear the screen |

## Building

To build the kernel, you need the RISC-V target installed:

```bash
rustup target add riscv64gc-unknown-none-elf
```

Build the kernel binary:

```bash
cargo build --release
```

The artifact will be located at `../target/riscv64gc-unknown-none-elf/release/kernel`.

## Running

You can run this kernel using the `riscv-vm` emulator:

```bash
cargo run -p riscv-vm --release -- --kernel target/riscv64gc-unknown-none-elf/release/kernel
```
</file>

<file path="mkfs/root/etc/init.d/klogd">
// /etc/init.d/klogd - Kernel Logger Daemon init script
// Usage: /etc/init.d/klogd {start|stop|restart|status}

let SERVICE = "klogd";

fn show_usage() {
    print("Usage: /etc/init.d/" + SERVICE + " {start|stop|restart|status}");
}

fn do_start() {
    let status = service_status(SERVICE);
    if status == "running" {
        print(SERVICE + " is already running");
        return;
    }
    
    print("Starting " + SERVICE + "...");
    if start_service(SERVICE) {
        print("\x1b[1;32m[OK]\x1b[0m " + SERVICE + " started");
    } else {
        print("\x1b[1;31m[FAIL]\x1b[0m Failed to start " + SERVICE);
    }
}

fn do_stop() {
    let status = service_status(SERVICE);
    if status != "running" {
        print(SERVICE + " is not running");
        return;
    }
    
    print("Stopping " + SERVICE + "...");
    if stop_service(SERVICE) {
        print("\x1b[1;32m[OK]\x1b[0m " + SERVICE + " stopped");
    } else {
        print("\x1b[1;31m[FAIL]\x1b[0m Failed to stop " + SERVICE);
    }
}

fn do_restart() {
    print("Restarting " + SERVICE + "...");
    if restart_service(SERVICE) {
        print("\x1b[1;32m[OK]\x1b[0m " + SERVICE + " restarted");
    } else {
        print("\x1b[1;31m[FAIL]\x1b[0m Failed to restart " + SERVICE);
    }
}

fn do_status() {
    let status = service_status(SERVICE);
    let services = services();
    
    for svc in services {
        if svc.name == SERVICE {
            print("● " + SERVICE + " - Kernel Logger Daemon");
            if status == "running" {
                print("   \x1b[1;32mActive: running\x1b[0m");
                print("   PID: " + svc.pid);
                print("   Hart: " + svc.hart);
                print("   Started: " + svc.started_at + "ms ago");
            } else if status == "stopped" {
                print("   \x1b[1;31mActive: stopped\x1b[0m");
            } else {
                print("   \x1b[1;33mActive: " + status + "\x1b[0m");
            }
            return;
        }
    }
    print(SERVICE + ": service not found");
}

// Main entry point
if ARGS.len() < 1 {
    show_usage();
} else {
    let cmd = ARGS[0];
    if cmd == "start" {
        do_start();
    } else if cmd == "stop" {
        do_stop();
    } else if cmd == "restart" {
        do_restart();
    } else if cmd == "status" {
        do_status();
    } else {
        print("Unknown command: " + cmd);
        show_usage();
    }
}
</file>

<file path="mkfs/root/etc/init.d/startup">
// BAVY OS Startup Script
// This script runs during init
// Services are auto-started by the kernel, this script logs boot info

print("=== BAVY OS Startup ===");

let start_time = time_ms();
print("Boot time: " + start_time + "ms");

// Check core subsystems
if fs_available() {
    print("\x1b[1;32m[OK]\x1b[0m Filesystem mounted");
} else {
    print("\x1b[1;31m[FAIL]\x1b[0m Filesystem not available");
}

if net_available() {
    print("\x1b[1;32m[OK]\x1b[0m Network: " + get_ip());
} else {
    print("\x1b[1;33m[WARN]\x1b[0m Network not configured");
}

// Show service status
print("");
print("Services:");
let svcs = services();
for svc in svcs {
    if svc.status == "running" {
        print("  \x1b[1;32m●\x1b[0m " + svc.name + " (PID " + svc.pid + ", hart " + svc.hart + ")");
    } else {
        print("  \x1b[1;31m○\x1b[0m " + svc.name + " (stopped)");
    }
}

print("");
print("Startup complete. Use 'service --list' to manage services.");
</file>

<file path="mkfs/root/etc/init.d/sysmond">
// /etc/init.d/sysmond - System Monitor Daemon init script
// Usage: /etc/init.d/sysmond {start|stop|restart|status}

let SERVICE = "sysmond";

fn show_usage() {
    print("Usage: /etc/init.d/" + SERVICE + " {start|stop|restart|status}");
}

fn do_start() {
    let status = service_status(SERVICE);
    if status == "running" {
        print(SERVICE + " is already running");
        return;
    }
    
    print("Starting " + SERVICE + "...");
    if start_service(SERVICE) {
        print("\x1b[1;32m[OK]\x1b[0m " + SERVICE + " started");
    } else {
        print("\x1b[1;31m[FAIL]\x1b[0m Failed to start " + SERVICE);
    }
}

fn do_stop() {
    let status = service_status(SERVICE);
    if status != "running" {
        print(SERVICE + " is not running");
        return;
    }
    
    print("Stopping " + SERVICE + "...");
    if stop_service(SERVICE) {
        print("\x1b[1;32m[OK]\x1b[0m " + SERVICE + " stopped");
    } else {
        print("\x1b[1;31m[FAIL]\x1b[0m Failed to stop " + SERVICE);
    }
}

fn do_restart() {
    print("Restarting " + SERVICE + "...");
    if restart_service(SERVICE) {
        print("\x1b[1;32m[OK]\x1b[0m " + SERVICE + " restarted");
    } else {
        print("\x1b[1;31m[FAIL]\x1b[0m Failed to restart " + SERVICE);
    }
}

fn do_status() {
    let status = service_status(SERVICE);
    let services = services();
    
    for svc in services {
        if svc.name == SERVICE {
            print("● " + SERVICE + " - System Monitor Daemon");
            if status == "running" {
                print("   \x1b[1;32mActive: running\x1b[0m");
                print("   PID: " + svc.pid);
                print("   Hart: " + svc.hart);
                print("   Started: " + svc.started_at + "ms ago");
            } else if status == "stopped" {
                print("   \x1b[1;31mActive: stopped\x1b[0m");
            } else {
                print("   \x1b[1;33mActive: " + status + "\x1b[0m");
            }
            return;
        }
    }
    print(SERVICE + ": service not found");
}

// Main entry point
if ARGS.len() < 1 {
    show_usage();
} else {
    let cmd = ARGS[0];
    if cmd == "start" {
        do_start();
    } else if cmd == "stop" {
        do_stop();
    } else if cmd == "restart" {
        do_restart();
    } else if cmd == "status" {
        do_status();
    } else {
        print("Unknown command: " + cmd);
        show_usage();
    }
}
</file>

<file path="mkfs/root/home/README.md">
# BAVY OS JavaScript Runtime

BAVY OS includes a JavaScript runtime with ES6-style module imports for
accessing operating system functionality.

---

## Import Syntax

### Namespace Import
Import all module functions under a namespace:

```javascript
import * as fs from "os:fs"
import * as net from "os:net"
import * as sys from "os:sys"
import * as mem from "os:mem"

// Use as: fs.ls(), net.ip(), sys.time(), mem.total()
```

### Named Import
Import specific functions (functions become global):

```javascript
import { ls, read, write } from "os:fs"
import { ip, mac } from "os:net"

// Use directly: ls(), read("/path"), ip()
```

---

## os:fs — Filesystem Module

```javascript
import * as fs from "os:fs"
```

### `fs.ls()`
List all files in the filesystem.

**Returns:** `Array` of objects with:
- `name` (String) - Full path
- `size` (Integer) - Size in bytes
- `is_dir` (Boolean) - Directory flag

```javascript
import * as fs from "os:fs"
let files = fs.ls();
for (let f of files) {
    print(f.name + " - " + f.size + " bytes");
}
```

---

### `fs.read(path)`
Read file contents.

**Parameters:**
- `path` (String) - File path

**Returns:** `String` - File contents, or empty string if not found

```javascript
import * as fs from "os:fs"
let content = fs.read("/home/README.md");
print(content);
```

---

### `fs.write(path, content)`
Write content to a file.

**Parameters:**
- `path` (String) - File path
- `content` (String) - Content to write

**Returns:** `Boolean` - true if successful

```javascript
import * as fs from "os:fs"
if (fs.write("/home/notes.txt", "Hello!")) {
    print("Saved!");
}
```

---

### `fs.exists(path)`
Check if a file exists.

**Parameters:**
- `path` (String) - File path

**Returns:** `Boolean`

```javascript
import * as fs from "os:fs"
if (fs.exists("/home/config.txt")) {
    let cfg = fs.read("/home/config.txt");
}
```

---

### `fs.available()`
Check if filesystem is mounted.

**Returns:** `Boolean`

```javascript
import * as fs from "os:fs"
if (!fs.available()) {
    print("No filesystem!");
}
```

---

## os:net — Network Module

```javascript
import * as net from "os:net"
```

### `net.ip()`
Get the system's IP address.

**Returns:** `String` - IPv4 address (e.g., "10.0.2.15")

```javascript
import * as net from "os:net"
print("IP: " + net.ip());
```

---

### `net.mac()`
Get the MAC address.

**Returns:** `String` - MAC address (e.g., "52:54:00:12:34:56")

```javascript
import * as net from "os:net"
print("MAC: " + net.mac());
```

---

### `net.gateway()`
Get the default gateway.

**Returns:** `String` - Gateway IP address

```javascript
import * as net from "os:net"
print("Gateway: " + net.gateway());
```

---

### `net.dns()`
Get the DNS server address.

**Returns:** `String` - DNS server IP

```javascript
import * as net from "os:net"
print("DNS: " + net.dns());
```

---

### `net.prefix()`
Get the network prefix length.

**Returns:** `Integer` - Prefix length (e.g., 24 for /24)

```javascript
import * as net from "os:net"
print("Prefix: /" + net.prefix());
```

---

### `net.available()`
Check if network is initialized.

**Returns:** `Boolean`

```javascript
import * as net from "os:net"
if (net.available()) {
    print("Network is up!");
}
```

---

## os:sys — System Module

```javascript
import * as sys from "os:sys"
```

### `sys.time()`
Get milliseconds since boot.

**Returns:** `Integer` - Uptime in milliseconds

```javascript
import * as sys from "os:sys"
print("Uptime: " + (sys.time() / 1000) + " seconds");
```

---

### `sys.sleep(ms)`
Sleep for specified milliseconds.

**Parameters:**
- `ms` (Integer) - Milliseconds to sleep

```javascript
import * as sys from "os:sys"
print("Waiting...");
sys.sleep(1000);  // Sleep 1 second
print("Done!");
```

---

### `sys.cwd()`
Get current working directory.

**Returns:** `String` - Current directory path

```javascript
import * as sys from "os:sys"
print("Current dir: " + sys.cwd());
```

---

### `sys.version()`
Get kernel version string.

**Returns:** `String` - Version (e.g., "BAVY OS")

```javascript
import * as sys from "os:sys"
print(sys.version());
```

---

### `sys.arch()`
Get CPU architecture.

**Returns:** `String` - Architecture (e.g., "RISC-V 64-bit (RV64GC)")

```javascript
import * as sys from "os:sys"
print("Arch: " + sys.arch());
```

---

## os:mem — Memory Module

```javascript
import * as mem from "os:mem"
```

### `mem.total()`
Get total heap size.

**Returns:** `Integer` - Total bytes

```javascript
import * as mem from "os:mem"
print("Total: " + (mem.total() / 1024) + " KB");
```

---

### `mem.used()`
Get used heap memory.

**Returns:** `Integer` - Used bytes

```javascript
import * as mem from "os:mem"
print("Used: " + (mem.used() / 1024) + " KB");
```

---

### `mem.free()`
Get free heap memory.

**Returns:** `Integer` - Free bytes

```javascript
import * as mem from "os:mem"
print("Free: " + (mem.free() / 1024) + " KB");
```

---

### `mem.stats()`
Get memory statistics.

**Returns:** `Object` with:
- `used` (Integer) - Used bytes
- `free` (Integer) - Free bytes

```javascript
import * as mem from "os:mem"
let s = mem.stats();
print("Used: " + s.used + ", Free: " + s.free);
```

---

## Global Functions

These functions are always available without imports.

### Output

| Function | Description |
|----------|-------------|
| `print(value)` | Print with newline |
| `write(value)` | Print without newline |
| `debug(value)` | Debug output with type info |

### Parsing

| Function | Description |
|----------|-------------|
| `parse_int(str)` | Parse string to integer |
| `parse_float(str)` | Parse string to float |

### Type Checking

| Function | Description |
|----------|-------------|
| `type_of(value)` | Get type name |
| `is_string(value)` | Check if string |
| `is_int(value)` | Check if integer |
| `is_float(value)` | Check if float |
| `is_array(value)` | Check if array |

### String Utilities

| Function | Description |
|----------|-------------|
| `repeat(str, n)` | Repeat string n times |
| `pad_left(str, width, char)` | Left-pad string |
| `pad_right(str, width, char)` | Right-pad string |
| `join(array, sep)` | Join array with separator |

### Iteration

| Function | Description |
|----------|-------------|
| `range(end)` | Array [0, end) |
| `range(start, end)` | Array [start, end) |
| `range(start, end, step)` | Array with step |

---

## Data Types

| Type | Examples |
|------|----------|
| Integer | `42`, `-10`, `0` |
| Float | `3.14`, `-0.5` |
| String | `"hello"`, `'world'` |
| Boolean | `true`, `false` |
| Array | `[1, 2, 3]`, `[]` |
| Object | `#{key: "value"}` |

---

## Control Flow

### If/Else
```javascript
if condition {
    // ...
} else if other {
    // ...
} else {
    // ...
}
```

### For Loop
```javascript
for item in array {
    print(item);
}

for i in range(10) {
    print(i);
}
```

### While Loop
```javascript
let i = 0;
while i < 10 {
    print(i);
    i += 1;
}
```

---

## Functions

```javascript
fn greet(name) {
    print("Hello, " + name + "!");
}

fn add(a, b) {
    return a + b;
}

greet("World");
let sum = add(2, 3);
```

---

## Special Variable

### `ARGS`
Array of command-line arguments passed to the script.

```javascript
// If called as: myscript arg1 arg2
// ARGS = ["arg1", "arg2"]

for arg in ARGS {
    print("Argument: " + arg);
}
```

---

## Example Script

```javascript
// sysinfo.js - Display system information

import * as fs from "os:fs"
import * as net from "os:net"
import * as sys from "os:sys"
import * as mem from "os:mem"

print("=== System Info ===");
print("Kernel:  " + sys.version());
print("Arch:    " + sys.arch());
print("Uptime:  " + (sys.time() / 1000) + "s");

print("");
print("=== Memory ===");
let m = mem.stats();
print("Used: " + (m.used / 1024) + " KB");
print("Free: " + (m.free / 1024) + " KB");

print("");
print("=== Network ===");
if net.available() {
    print("IP:      " + net.ip());
    print("Gateway: " + net.gateway());
} else {
    print("Network offline");
}

print("");
print("=== Filesystem ===");
if fs.available() {
    let files = fs.ls();
    print("Files: " + files.len());
}
```
</file>

<file path="mkfs/root/usr/bin/ip">
// ip - Show network configuration
// Usage: ip [addr]

import * as net from "os:net"

let show_addr = ARGS.len() == 0 || ARGS[0] == "addr";

if show_addr {
    if !net.available() {
        print("\x1b[1;31m✗\x1b[0m Network not initialized");
    } else {
        print("");
        print("\x1b[1;34m┌─────────────────────────────────────────────────────────────┐\x1b[0m");
        print("\x1b[1;34m│\x1b[0m            \x1b[1;97mNetwork Interface: virtio0\x1b[0m                       \x1b[1;34m│\x1b[0m");
        print("\x1b[1;34m├─────────────────────────────────────────────────────────────┤\x1b[0m");
        
        let mac = net.mac();
        let mac_pad = " ".repeat(61 - 14 - mac.len());
        print("\x1b[1;34m│\x1b[0m  \x1b[1;33mlink/ether\x1b[0m  " + mac + mac_pad + "\x1b[1;34m│\x1b[0m");
        
        let ip = net.ip();
        let prefix = net.prefix().to_string();
        let inet_str = ip + "/" + prefix;
        let inet_pad = " ".repeat(61 - 14 - inet_str.len());
        print("\x1b[1;34m│\x1b[0m  \x1b[1;33minet\x1b[0m        " + inet_str + inet_pad + "\x1b[1;34m│\x1b[0m");
        
        let gw = net.gateway();
        let gw_pad = " ".repeat(61 - 15 - gw.len());
        print("\x1b[1;34m│\x1b[0m  \x1b[1;33mgateway\x1b[0m     " + gw + gw_pad + "\x1b[1;34m│\x1b[0m");
        
        print("\x1b[1;34m│\x1b[0m                                                             \x1b[1;34m│\x1b[0m");
        print("\x1b[1;34m│\x1b[0m  \x1b[1;32mState: UP\x1b[0m    \x1b[0;90mMTU: 1500    Type: VirtIO-Net\x1b[0m              \x1b[1;34m│\x1b[0m");
        print("\x1b[1;34m└─────────────────────────────────────────────────────────────┘\x1b[0m");
        print("");
    }
} else {
    print("Usage: ip addr");
}
</file>

<file path="mkfs/root/usr/bin/memstats">
// memstats - Show heap memory statistics
// Usage: memstats

import * as mem from "os:mem"

let total = mem.total();
let stats = mem.stats();
let used = stats.used;
let free = stats.free;

let total_kb = total / 1024;
let used_kb = used / 1024;
let free_kb = free / 1024;

let percent_used = if total > 0 { (used * 100) / total } else { 0 };

let bar_width = 30;
let filled = (percent_used * bar_width) / 100;

print("");
print("\x1b[1;36m┌─────────────────────────────────────────────────────────────┐\x1b[0m");
print("\x1b[1;36m│\x1b[0m              \x1b[1;97mHeap Memory Statistics\x1b[0m                         \x1b[1;36m│\x1b[0m");
print("\x1b[1;36m├─────────────────────────────────────────────────────────────┤\x1b[0m");

let total_str = total_kb.to_string() + " KiB";
let total_pad = " ".repeat(61 - 11 - total_str.len());
print("\x1b[1;36m│\x1b[0m  Total:   \x1b[1;97m" + total_str + "\x1b[0m" + total_pad + "\x1b[1;36m│\x1b[0m");

let used_str = used_kb.to_string() + " KiB";
let used_pad = " ".repeat(61 - 11 - used_str.len());
print("\x1b[1;36m│\x1b[0m  Used:    \x1b[1;33m" + used_str + "\x1b[0m" + used_pad + "\x1b[1;36m│\x1b[0m");

let free_str = free_kb.to_string() + " KiB";
let free_pad = " ".repeat(61 - 11 - free_str.len());
print("\x1b[1;36m│\x1b[0m  Free:    \x1b[1;32m" + free_str + "\x1b[0m" + free_pad + "\x1b[1;36m│\x1b[0m");

print("\x1b[1;36m│\x1b[0m                                                             \x1b[1;36m│\x1b[0m");

let bar = "";
let i = 0;
while i < bar_width {
    if i < filled {
        bar += "\x1b[1;32m█\x1b[0m";
    } else {
        bar += "\x1b[0;90m░\x1b[0m";
    }
    i += 1;
}
let pct_str = percent_used.to_string() + "%";
let pct_pad = " ".repeat(61 - 14 - 30 - pct_str.len());
print("\x1b[1;36m│\x1b[0m  Usage:   [" + bar + "] " + pct_str + pct_pad + "\x1b[1;36m│\x1b[0m");

print("\x1b[1;36m└───────────────────────────────────────────────────────────┘\x1b[0m");
print("");
</file>

<file path="mkfs/root/usr/bin/netstat">
// netstat - Show network statistics
// Usage: netstat

import * as net from "os:net"

if !net.available() {
    print("\x1b[1;31m✗\x1b[0m Network not initialized");
} else {
    print("");
    print("\x1b[1;35m┌─────────────────────────────────────────────────────────────┐\x1b[0m");
    print("\x1b[1;35m│\x1b[0m                   \x1b[1;97mNetwork Statistics\x1b[0m                        \x1b[1;35m│\x1b[0m");
    print("\x1b[1;35m├─────────────────────────────────────────────────────────────┤\x1b[0m");
    print("\x1b[1;35m│\x1b[0m  \x1b[1;33mDevice:\x1b[0m                                                    \x1b[1;35m│\x1b[0m");
    print("\x1b[1;35m│\x1b[0m    Type:     \x1b[1;97mVirtIO Network Device\x1b[0m                          \x1b[1;35m│\x1b[0m");
    print("\x1b[1;35m│\x1b[0m    Address:  \x1b[1;97m0x10001000\x1b[0m                                     \x1b[1;35m│\x1b[0m");
    print("\x1b[1;35m│\x1b[0m    Status:   \x1b[1;32m● ONLINE\x1b[0m                                       \x1b[1;35m│\x1b[0m");
    print("\x1b[1;35m│\x1b[0m                                                             \x1b[1;35m│\x1b[0m");
    print("\x1b[1;35m│\x1b[0m  \x1b[1;33mConfiguration:\x1b[0m                                             \x1b[1;35m│\x1b[0m");
    
    let mac = net.mac();
    let mac_pad = " ".repeat(61 - 14 - mac.len());
    print("\x1b[1;35m│\x1b[0m    MAC:      \x1b[1;97m" + mac + "\x1b[0m" + mac_pad + "\x1b[1;35m│\x1b[0m");
    
    let ip = net.ip();
    let prefix = net.prefix().to_string();
    let ip_str = ip + "/" + prefix;
    let ip_pad = " ".repeat(61 - 14 - ip_str.len());
    print("\x1b[1;35m│\x1b[0m    IP:       \x1b[1;97m" + ip_str + "\x1b[0m" + ip_pad + "\x1b[1;35m│\x1b[0m");
    
    let gw = net.gateway();
    let gw_pad = " ".repeat(61 - 14 - gw.len());
    print("\x1b[1;35m│\x1b[0m    Gateway:  \x1b[1;97m" + gw + "\x1b[0m" + gw_pad + "\x1b[1;35m│\x1b[0m");
    
    let dns = net.dns();
    let dns_pad = " ".repeat(61 - 14 - dns.len());
    print("\x1b[1;35m│\x1b[0m    DNS:      \x1b[1;97m" + dns + "\x1b[0m" + dns_pad + "\x1b[1;35m│\x1b[0m");
    
    print("\x1b[1;35m│\x1b[0m                                                             \x1b[1;35m│\x1b[0m");
    print("\x1b[1;35m│\x1b[0m  \x1b[1;33mProtocol Stack:\x1b[0m                                            \x1b[1;35m│\x1b[0m");
    print("\x1b[1;35m│\x1b[0m    \x1b[1;97msmoltcp\x1b[0m - Lightweight TCP/IP stack                       \x1b[1;35m│\x1b[0m");
    print("\x1b[1;35m│\x1b[0m    Protocols: ICMP, UDP, TCP, ARP                           \x1b[1;35m│\x1b[0m");
    print("\x1b[1;35m└─────────────────────────────────────────────────────────────┘\x1b[0m");
    print("");
}
</file>

<file path="mkfs/root/usr/bin/service">
// service - Linux-style service management command
// Usage: service <name> {start|stop|restart|status}
//        service --list

if ARGS.len() < 1 {
    print("Usage: service <name> {start|stop|restart|status}");
    print("       service --list");
    print("       service --status-all");
} else if ARGS[0] == "--list" || ARGS[0] == "-l" {
    // List all available services
    print("\x1b[1;36mAvailable services:\x1b[0m");
    let defs = service_defs();
    for def in defs {
        print("  " + def.name + " - " + def.description);
    }
} else if ARGS[0] == "--status-all" || ARGS[0] == "-a" {
    // Show status of all services
    print("\x1b[1;36mService Status:\x1b[0m");
    let svcs = services();
    for svc in svcs {
        let status_color = if svc.status == "running" {
            "\x1b[1;32m"
        } else if svc.status == "stopped" {
            "\x1b[1;31m"
        } else {
            "\x1b[1;33m"
        };
        print("  " + pad_right(svc.name, 12, " ") + status_color + svc.status + "\x1b[0m");
    }
} else if ARGS.len() < 2 {
    print("Usage: service " + ARGS[0] + " {start|stop|restart|status}");
} else {
    let name = ARGS[0];
    let cmd = ARGS[1];
    
    if cmd == "start" {
        print("Starting " + name + "...");
        if start_service(name) {
            print("\x1b[1;32m[OK]\x1b[0m");
        } else {
            print("\x1b[1;31m[FAIL]\x1b[0m Service not found or already running");
        }
    } else if cmd == "stop" {
        print("Stopping " + name + "...");
        if stop_service(name) {
            print("\x1b[1;32m[OK]\x1b[0m");
        } else {
            print("\x1b[1;31m[FAIL]\x1b[0m Service not found or not running");
        }
    } else if cmd == "restart" {
        print("Restarting " + name + "...");
        if restart_service(name) {
            print("\x1b[1;32m[OK]\x1b[0m");
        } else {
            print("\x1b[1;31m[FAIL]\x1b[0m");
        }
    } else if cmd == "status" {
        let status = service_status(name);
        let svcs = services();
        let found = false;
        
        for svc in svcs {
            if svc.name == name {
                found = true;
                print("● " + name);
                if status == "running" {
                    print("   \x1b[1;32mActive: running\x1b[0m");
                    print("   PID: " + svc.pid);
                    if svc.hart >= 0 {
                        print("   Hart: " + svc.hart);
                    }
                } else if status == "stopped" {
                    print("   \x1b[1;31mActive: stopped\x1b[0m");
                } else {
                    print("   \x1b[1;33mActive: " + status + "\x1b[0m");
                }
            }
        }
        
        if !found {
            print("Service '" + name + "' not found");
            print("Use 'service --list' to see available services");
        }
    } else {
        print("Unknown command: " + cmd);
        print("Valid commands: start, stop, restart, status");
    }
}
</file>

<file path="mkfs/root/usr/bin/wget">
// wget - Download files from the web
// Usage: wget <url> [options]
//
// Options:
//   -O <file>   Save to specified file (default: derived from URL)
//   -q          Quiet mode (suppress output)
//   -v          Verbose output
//
// Examples:
//   wget http://example.com/
//   wget http://example.com/file.txt -O output.txt
//   wget http://httpbin.org/get

import * as http from "os:http"
import * as fs from "os:fs"
import * as sys from "os:sys"

// Parse arguments
let url = "";
let output_file = "";
let quiet = false;
let verbose = false;

let i = 0;
while i < ARGS.len() {
    let arg = ARGS[i];
    if arg == "-O" && i + 1 < ARGS.len() {
        i += 1;
        output_file = ARGS[i];
    } else if arg == "-q" {
        quiet = true;
    } else if arg == "-v" {
        verbose = true;
    } else if arg.starts_with("-") {
        print("Unknown option: " + arg);
    } else if url == "" {
        url = arg;
    }
    i += 1;
}

if url == "" {
    print("Usage: wget <url> [options]");
    print("");
    print("Options:");
    print("  -O <file>   Save to specified file");
    print("  -q          Quiet mode");
    print("  -v          Verbose output");
    print("");
    print("Examples:");
    print("  wget http://example.com/");
    print("  wget http://httpbin.org/get");
} else {
    // Check network availability
    if !http.available() {
        print("\x1b[1;31mError:\x1b[0m Network not available");
    } else {
        if !quiet {
            print("--" + sys.time().to_string() + "--  " + url);
        }
        
        // Make the request
        let response = http.get(url);
        
        if response.ok {
            if verbose {
                print("HTTP request sent, awaiting response...");
            }
            
            let status = response.status;
            let status_text = response.statusText;
            
            if !quiet {
                print("HTTP/" + status.to_string() + " " + status_text);
            }
            
            if status >= 200 && status < 300 {
                // Success!
                let body = response.body;
                let content_length = body.len();
                
                if !quiet {
                    print("Length: " + content_length.to_string() + " bytes");
                }
                
                if output_file != "" {
                    // Save to file
                    let path = "";
                    if output_file.starts_with("/") {
                        path = output_file;
                    } else {
                        let cwd = sys.cwd();
                        if cwd == "/" {
                            path = "/" + output_file;
                        } else {
                            path = cwd + "/" + output_file;
                        }
                    }
                    
                    if fs.write(path, body) {
                        if !quiet {
                            print("Saving to: '" + path + "'");
                            print("");
                            print(path + " saved [" + content_length.to_string() + " bytes]");
                        }
                    } else {
                        print("\x1b[1;31mError:\x1b[0m Failed to write to " + path);
                    }
                } else {
                    // Print to stdout
                    if !quiet {
                        print("");
                    }
                    write(body);
                    if !body.ends_with("\n") {
                        print("");
                    }
                }
            } else if status >= 300 && status < 400 {
                // This shouldn't happen since http.get() now follows redirects automatically
                // But just in case the server returns a redirect we can't follow
                let location = "";
                if response.headers.contains("Location") {
                    location = response.headers.Location;
                }
                print("\x1b[1;33mRedirect:\x1b[0m " + location);
                print("(Redirect not followed - may be unsupported type)");
            } else {
                // Error
                print("\x1b[1;31mError:\x1b[0m HTTP " + status.to_string() + " " + status_text);
            }
        } else {
            // Request failed
            let error = "";
            if response.contains("error") {
                error = response.error;
            } else {
                error = "Unknown error";
            }
            print("\x1b[1;31mError:\x1b[0m " + error);
        }
    }
}
</file>

<file path="relay/src/main.rs">
//! P2P WebTransport Relay Server
//!
//! A central hub relay server that enables:
//! - Browser <-> Browser connectivity via WebTransport
//! - Browser <-> Server connectivity
//! - Server <-> Server connectivity
//! - Virtual network with DHCP-like IP assignment (10.0.2.x)
//! - External traffic proxy (DNS, ICMP) for VMs

mod hub;
mod peer;
mod protocol;
mod proxy;

use std::sync::Arc;
use std::time::Duration;

use anyhow::Result;
use clap::Parser;
use tokio::sync::mpsc;
use tracing::{info, warn};
use tracing_subscriber::EnvFilter;
use wtransport::{Endpoint, Identity, ServerConfig};

/// QUIC keep-alive interval in seconds.
/// Server sends PING frames at this interval to keep connections alive.
/// This is critical for browser tabs that go to background and can't send heartbeats.
const QUIC_KEEP_ALIVE_SECS: u64 = 15;

/// Maximum QUIC idle timeout in seconds.
/// Connection is closed if no activity for this duration.
const QUIC_MAX_IDLE_TIMEOUT_SECS: u64 = 180;

use crate::hub::{Hub, PeerMessage};
use crate::peer::PeerId;
use crate::protocol::{encode_data_frame, ControlMessage, MSG_TYPE_CONTROL};

#[derive(Parser, Debug)]
#[command(
    author,
    version,
    about = "P2P WebTransport Relay Server for RISC-V VM networking"
)]
struct Args {
    /// Port to listen on (UDP/QUIC)
    #[arg(short, long, default_value_t = 4433)]
    port: u16,

    /// Bind address
    #[arg(short, long, default_value = "0.0.0.0")]
    bind: String,

    /// Path to TLS certificate PEM file (optional). If not set, a self-signed
    /// certificate will be generated on startup.
    #[arg(long, env = "RELAY_CERT_PEM")]
    cert_pem: Option<String>,

    /// Path to TLS private key PEM file (optional). Must be provided when
    /// using --cert-pem/RELAY_CERT_PEM.
    #[arg(long, env = "RELAY_KEY_PEM")]
    key_pem: Option<String>,

    /// Heartbeat interval in seconds
    #[arg(long, default_value_t = 30)]
    heartbeat_interval: u64,

    /// Peer timeout in seconds (increased for browser backgrounding tolerance)
    #[arg(long, default_value_t = 150)]
    peer_timeout: u64,
}

/// Build the TLS identity either from provided PEM files (certificate + key) or
/// by generating a new self-signed certificate.
async fn build_identity(args: &Args) -> Result<Identity> {
    if let (Some(cert_pem), Some(key_pem)) = (&args.cert_pem, &args.key_pem) {
        info!(
            "Loading TLS identity from PEM files: cert='{}', key='{}'",
            cert_pem, key_pem
        );
        let identity = Identity::load_pemfiles(cert_pem, key_pem).await?;
        Ok(identity)
    } else if args.cert_pem.is_some() || args.key_pem.is_some() {
        anyhow::bail!(
            "Both --cert-pem/RELAY_CERT_PEM and --key-pem/RELAY_KEY_PEM must be set \
             to use a custom certificate"
        );
    } else {
        info!("No certificate/key provided; generating ephemeral self-signed identity");
        Ok(Identity::self_signed(["localhost", "127.0.0.1", "::1"])?)
    }
}

#[tokio::main]
async fn main() -> Result<()> {
    // Initialize logging
    tracing_subscriber::fmt()
        .with_env_filter(
            EnvFilter::try_from_default_env().unwrap_or_else(|_| EnvFilter::new("info")),
        )
        .init();

    let args = Args::parse();

    info!("Starting P2P WebTransport Relay Server...");
    info!("Virtual Network: 10.0.2.0/24, Gateway: 10.0.2.2");

    // Load a provided TLS identity or generate a self-signed one
    let identity = build_identity(&args).await?;
    let cert_hash = identity
        .certificate_chain()
        .as_slice()
        .first()
        .unwrap()
        .hash();
    // Format hash without colons for easy copy-paste
    let cert_hash_hex = format!("{}", cert_hash);
    info!("Certificate Hash: {}", cert_hash_hex);
    info!("Use this hash with --net-cert-hash when connecting");

    // Create the central hub
    let hub = Arc::new(Hub::new());

    // Initialize the external proxy
    if let Err(e) = hub.proxy().init().await {
        warn!("Failed to initialize external proxy: {}", e);
    }

    // Spawn the UDP response receiver for external proxy
    let hub_clone = hub.clone();
    tokio::spawn(async move {
        run_udp_proxy_receiver(hub_clone).await;
    });

    // Spawn the TCP response receiver for external proxy
    let hub_clone = hub.clone();
    tokio::spawn(async move {
        run_tcp_proxy_receiver(hub_clone).await;
    });

    // Spawn the peer cleanup task
    let hub_clone = hub.clone();
    let timeout = args.peer_timeout;
    tokio::spawn(async move {
        let mut interval = tokio::time::interval(Duration::from_secs(timeout / 3));
        loop {
            interval.tick().await;
            hub_clone.cleanup_expired_peers().await;
            hub_clone.log_stats().await;
        }
    });

    // Setup WebTransport server
    let socket_addr = format!("{}:{}", args.bind, args.port).parse()?;

    let config = ServerConfig::builder()
        .with_bind_address(socket_addr)
        .with_identity(identity)
        // CRITICAL: Server-side keep-alive to prevent connections from timing out
        // when browser tabs go to background and can't send heartbeats.
        // The server will send QUIC PING frames every QUIC_KEEP_ALIVE_SECS seconds.
        .keep_alive_interval(Some(Duration::from_secs(QUIC_KEEP_ALIVE_SECS)))
        // Maximum time a connection can be idle (no data or keep-alive)
        .max_idle_timeout(Some(Duration::from_secs(QUIC_MAX_IDLE_TIMEOUT_SECS)))
        .expect("Invalid idle timeout")
        .build();

    let endpoint = Endpoint::server(config)?;
    
    info!(
        "QUIC keep-alive: {}s, max idle timeout: {}s",
        QUIC_KEEP_ALIVE_SECS, QUIC_MAX_IDLE_TIMEOUT_SECS
    );

    info!("Listening on https://{}:{}", args.bind, args.port);

    // Accept incoming sessions
    loop {
        let incoming_session = endpoint.accept().await;
        let hub = hub.clone();

        tokio::spawn(async move {
            if let Err(e) = handle_connection(incoming_session, hub).await {
                warn!("Connection error: {}", e);
            }
        });
    }
}

/// Handle a single WebTransport connection
async fn handle_connection(
    incoming: wtransport::endpoint::IncomingSession,
    hub: Arc<Hub>,
) -> Result<()> {
    let request = incoming.await?;
    info!("New connection from {:?}", request.remote_address());

    let connection = request.accept().await?;
    info!("Session established with {:?}", connection.remote_address());

    // Create channel for sending to this peer
    let (tx, mut rx) = mpsc::channel::<PeerMessage>(256);

    // Wait for registration message
    let peer_id: PeerId;
    let assigned_ip: [u8; 4];

    loop {
        tokio::select! {
            result = connection.receive_datagram() => {
                match result {
                    Ok(datagram) => {
                        let data = datagram.to_vec();
                        if !data.is_empty() && data[0] == MSG_TYPE_CONTROL {
                            if let Ok(ControlMessage::Register { mac }) = ControlMessage::decode(&data) {
                                // Register the peer
                                match hub.register_peer(mac, tx.clone()).await {
                                    Some((id, ip)) => {
                                        peer_id = id;
                                        assigned_ip = ip;
                                        info!(
                                            "Peer {} registered: MAC={}, IP={}",
                                            peer_id,
                                            protocol::format_mac(&mac),
                                            protocol::format_ip(&ip)
                                        );
                                        break;
                                    }
                                    None => {
                                        let err = ControlMessage::Error {
                                            message: "IP pool exhausted".to_string(),
                                        };
                                        let _ = connection.send_datagram(err.encode());
                                        return Ok(());
                                    }
                                }
                            }
                        }
                    }
                    Err(e) => {
                        warn!("Connection closed during registration: {}", e);
                        return Ok(());
                    }
                }
            }
            _ = tokio::time::sleep(Duration::from_secs(30)) => {
                warn!("Registration timeout");
                return Ok(());
            }
        }
    }

    // Subscribe to broadcast channel
    let mut broadcast_rx = hub.subscribe();

    // Main message loop
    loop {
        tokio::select! {
            // Receive from client
            result = connection.receive_datagram() => {
                match result {
                    Ok(datagram) => {
                        let data = datagram.to_vec();
                        hub.touch_peer(peer_id).await;
                        hub.route_frame(peer_id, data).await;
                    }
                    Err(e) => {
                        info!("Peer {} disconnected: {}", peer_id, e);
                        break;
                    }
                }
            }

            // Send to client (from hub routing)
            Some(msg) = rx.recv() => {
                match msg {
                    PeerMessage::Send(data) => {
                        if let Err(e) = connection.send_datagram(data) {
                            warn!("Failed to send to peer {}: {}", peer_id, e);
                            break;
                        }
                    }
                    PeerMessage::Disconnect => {
                        info!("Peer {} kicked by hub", peer_id);
                        break;
                    }
                }
            }

            // Broadcast messages (from other peers)
            Ok((from_peer, data)) = broadcast_rx.recv() => {
                if from_peer != peer_id {
                    if let Err(e) = connection.send_datagram(data) {
                        warn!("Failed to broadcast to peer {}: {}", peer_id, e);
                        break;
                    }
                }
            }
        }
    }

    // Cleanup
    hub.unregister_peer(peer_id).await;
    info!(
        "Peer {} unregistered (IP {})",
        peer_id,
        protocol::format_ip(&assigned_ip)
    );

    Ok(())
}

/// Run the external proxy UDP receiver loop
async fn run_udp_proxy_receiver(hub: Arc<Hub>) {
    loop {
        let socket = hub.proxy().udp_socket().await;

        if let Some(socket) = socket {
            let mut buf = [0u8; 2048];
            loop {
                match socket.recv_from(&mut buf).await {
                    Ok((n, src_addr)) => {
                        if let Some(response_frame) =
                            hub.proxy().handle_incoming_udp(&buf, src_addr, n).await
                        {
                            // Need to send this response to the right peer
                            // The response frame contains the destination MAC/IP
                            // which we can use to route it
                            broadcast_response(&hub, &response_frame).await;
                        }
                    }
                    Err(e) => {
                        warn!("Proxy UDP recv error: {}", e);
                        break;
                    }
                }
            }
        }

        tokio::time::sleep(Duration::from_millis(100)).await;
    }
}

/// Run the external proxy TCP receiver loop
async fn run_tcp_proxy_receiver(hub: Arc<Hub>) {
    loop {
        // Poll for TCP responses from active connections
        while let Some(response_frame) = hub.proxy().poll_tcp_response().await {
            info!("TCP receiver: got {} byte frame from proxy, routing to peer", response_frame.len());
            // Route the response frame to the appropriate peer
            broadcast_response(&hub, &response_frame).await;
        }
        
        // Small delay to avoid busy-waiting
        tokio::time::sleep(Duration::from_millis(10)).await;
    }
}

/// Broadcast a proxy response to the appropriate peer
async fn broadcast_response(hub: &Hub, ethernet_frame: &[u8]) {
    if ethernet_frame.len() < 14 {
        return;
    }

    let dst_mac: [u8; 6] = ethernet_frame[0..6].try_into().unwrap();

    // Find the peer with this MAC
    let peers_arc = hub.peers();
    let peers = peers_arc.read().await;
    if let Some(peer) = peers.find_by_mac(&dst_mac) {
        let peer_id = peer.id;
        drop(peers);
        hub.send_to_peer(peer_id, encode_data_frame(ethernet_frame))
            .await;
    }
}
</file>

<file path="relay/src/peer.rs">
//! Peer state management and IP pool allocation for the relay hub.

use std::collections::HashMap;
use std::time::Instant;

use crate::protocol::{format_ip, format_mac, IP_POOL_END, IP_POOL_START};

/// Unique identifier for a connected peer
pub type PeerId = u64;

/// State of a connected peer
#[derive(Debug, Clone)]
pub struct Peer {
    /// Unique peer ID
    pub id: PeerId,
    /// MAC address of the peer's virtual NIC
    pub mac: [u8; 6],
    /// Assigned IP address
    pub ip: [u8; 4],
    /// Last activity timestamp (for heartbeat timeout)
    pub last_seen: Instant,
}

impl Peer {
    pub fn new(id: PeerId, mac: [u8; 6], ip: [u8; 4]) -> Self {
        Self {
            id,
            mac,
            ip,
            last_seen: Instant::now(),
        }
    }

    pub fn touch(&mut self) {
        self.last_seen = Instant::now();
    }

    pub fn is_expired(&self, timeout_secs: u64) -> bool {
        self.last_seen.elapsed().as_secs() > timeout_secs
    }
}

/// IP address pool manager
#[derive(Debug)]
pub struct IpPool {
    /// Base network (10.0.2.x)
    network_prefix: [u8; 3],
    /// Available host addresses (set of last octet values)
    available: Vec<u8>,
    /// Allocated addresses mapped to peer ID
    allocated: HashMap<u8, PeerId>,
}

impl IpPool {
    pub fn new() -> Self {
        // Initialize with all available addresses in the pool
        let available: Vec<u8> = (IP_POOL_START..=IP_POOL_END).collect();
        Self {
            network_prefix: [10, 0, 2],
            available,
            allocated: HashMap::new(),
        }
    }

    /// Allocate an IP address for a peer
    pub fn allocate(&mut self, peer_id: PeerId) -> Option<[u8; 4]> {
        let host = self.available.pop()?;
        self.allocated.insert(host, peer_id);
        Some([
            self.network_prefix[0],
            self.network_prefix[1],
            self.network_prefix[2],
            host,
        ])
    }

    /// Release an IP address back to the pool
    pub fn release(&mut self, ip: &[u8; 4]) {
        if ip[0] == self.network_prefix[0]
            && ip[1] == self.network_prefix[1]
            && ip[2] == self.network_prefix[2]
        {
            let host = ip[3];
            if self.allocated.remove(&host).is_some() {
                self.available.push(host);
            }
        }
    }

    /// Check if an IP is in our managed range
    pub fn is_internal(&self, ip: &[u8; 4]) -> bool {
        ip[0] == self.network_prefix[0]
            && ip[1] == self.network_prefix[1]
            && ip[2] == self.network_prefix[2]
    }
}

impl Default for IpPool {
    fn default() -> Self {
        Self::new()
    }
}

/// Manages all connected peers and their state
#[derive(Debug)]
pub struct PeerManager {
    /// Connected peers by ID
    peers: HashMap<PeerId, Peer>,
    /// MAC to peer ID mapping for fast lookup
    mac_to_peer: HashMap<[u8; 6], PeerId>,
    /// IP to peer ID mapping for routing
    ip_to_peer: HashMap<[u8; 4], PeerId>,
    /// IP address pool
    ip_pool: IpPool,
    /// Next peer ID
    next_id: PeerId,
    /// Heartbeat timeout in seconds
    heartbeat_timeout: u64,
}

impl PeerManager {
    pub fn new() -> Self {
        Self {
            peers: HashMap::new(),
            mac_to_peer: HashMap::new(),
            ip_to_peer: HashMap::new(),
            ip_pool: IpPool::new(),
            next_id: 1,
            // Increased timeout to tolerate browser tabs going to background
            // Browser tabs may not run JS timers reliably when backgrounded
            heartbeat_timeout: 120,
        }
    }

    /// Register a new peer with the given MAC address
    /// Returns the peer ID and assigned IP, or None if pool exhausted
    pub fn register(&mut self, mac: [u8; 6]) -> Option<(PeerId, [u8; 4])> {
        // Check if MAC already registered
        if let Some(&existing_id) = self.mac_to_peer.get(&mac) {
            // Return existing registration
            if let Some(peer) = self.peers.get(&existing_id) {
                return Some((existing_id, peer.ip));
            }
        }

        // Allocate new peer
        let id = self.next_id;
        self.next_id += 1;

        let ip = self.ip_pool.allocate(id)?;

        let peer = Peer::new(id, mac, ip);
        self.peers.insert(id, peer);
        self.mac_to_peer.insert(mac, id);
        self.ip_to_peer.insert(ip, id);

        tracing::info!(
            "Registered peer {} with MAC {} -> IP {}",
            id,
            format_mac(&mac),
            format_ip(&ip)
        );

        Some((id, ip))
    }

    /// Unregister a peer and release its resources
    pub fn unregister(&mut self, peer_id: PeerId) {
        if let Some(peer) = self.peers.remove(&peer_id) {
            self.mac_to_peer.remove(&peer.mac);
            self.ip_to_peer.remove(&peer.ip);
            self.ip_pool.release(&peer.ip);

            tracing::info!(
                "Unregistered peer {} (MAC {} / IP {})",
                peer_id,
                format_mac(&peer.mac),
                format_ip(&peer.ip)
            );
        }
    }

    /// Update last-seen timestamp for a peer
    pub fn touch(&mut self, peer_id: PeerId) {
        if let Some(peer) = self.peers.get_mut(&peer_id) {
            peer.touch();
        }
    }

    /// Find peer by MAC address
    pub fn find_by_mac(&self, mac: &[u8; 6]) -> Option<&Peer> {
        self.mac_to_peer.get(mac).and_then(|id| self.peers.get(id))
    }

    /// Get peer ID by IP address
    pub fn peer_id_by_ip(&self, ip: &[u8; 4]) -> Option<PeerId> {
        self.ip_to_peer.get(ip).copied()
    }

    /// Get all peers (for peer list message)
    pub fn all_peers(&self) -> Vec<&Peer> {
        self.peers.values().collect()
    }

    /// Check if an IP is internal to our virtual network
    pub fn is_internal_ip(&self, ip: &[u8; 4]) -> bool {
        self.ip_pool.is_internal(ip)
    }

    /// Remove expired peers and return their IDs
    pub fn cleanup_expired(&mut self) -> Vec<PeerId> {
        let expired: Vec<PeerId> = self
            .peers
            .iter()
            .filter(|(_, peer)| peer.is_expired(self.heartbeat_timeout))
            .map(|(&id, _)| id)
            .collect();

        for id in &expired {
            self.unregister(*id);
        }

        expired
    }

    /// Get the number of connected peers
    pub fn peer_count(&self) -> usize {
        self.peers.len()
    }
}

impl Default for PeerManager {
    fn default() -> Self {
        Self::new()
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_ip_pool_allocation() {
        let mut pool = IpPool::new();
        
        let ip1 = pool.allocate(1).unwrap();
        assert_eq!(ip1[0..3], [10, 0, 2]);
        assert!(ip1[3] >= IP_POOL_START && ip1[3] <= IP_POOL_END);

        let ip2 = pool.allocate(2).unwrap();
        assert_ne!(ip1, ip2);

        pool.release(&ip1);
        let ip3 = pool.allocate(3).unwrap();
        assert_eq!(ip1, ip3); // Should get the same IP back
    }

    #[test]
    fn test_peer_lookup() {
        let mut manager = PeerManager::new();
        
        let mac = [0x52, 0x54, 0x00, 0xab, 0xcd, 0xef];
        let (id, ip) = manager.register(mac).unwrap();

        assert!(manager.find_by_mac(&mac).is_some());
        assert_eq!(manager.peer_id_by_ip(&ip), Some(id));
    }
}
</file>

<file path="riscv-vm/src/decoder.rs">
use crate::Trap;

#[derive(Debug, Clone, Copy, PartialEq)]
#[repr(u8)]
pub enum Register {
    X0 = 0,
    X1 = 1,
    X2 = 2,
    X3 = 3,
    X4 = 4,
    X5 = 5,
    X6 = 6,
    X7 = 7,
    X8 = 8,
    X9 = 9,
    X10 = 10,
    X11 = 11,
    X12 = 12,
    X13 = 13,
    X14 = 14,
    X15 = 15,
    X16 = 16,
    X17 = 17,
    X18 = 18,
    X19 = 19,
    X20 = 20,
    X21 = 21,
    X22 = 22,
    X23 = 23,
    X24 = 24,
    X25 = 25,
    X26 = 26,
    X27 = 27,
    X28 = 28,
    X29 = 29,
    X30 = 30,
    X31 = 31,
}

impl Register {
    #[inline(always)]
    pub fn from_u32(v: u32) -> Self {
        // SAFETY: v & 0x1F is always in range 0..=31, matching our enum variants
        unsafe { std::mem::transmute((v & 0x1F) as u8) }
    }

    #[inline(always)]
    pub fn to_usize(&self) -> usize {
        *self as usize
    }
}

#[derive(Debug, Clone, Copy, PartialEq)]
pub enum Op {
    Lui {
        rd: Register,
        imm: i64,
    },
    Auipc {
        rd: Register,
        imm: i64,
    },
    Jal {
        rd: Register,
        imm: i64,
    },
    Jalr {
        rd: Register,
        rs1: Register,
        imm: i64,
    },
    Branch {
        rs1: Register,
        rs2: Register,
        imm: i64,
        funct3: u32,
    },
    Load {
        rd: Register,
        rs1: Register,
        imm: i64,
        funct3: u32,
    },
    Store {
        rs1: Register,
        rs2: Register,
        imm: i64,
        funct3: u32,
    },
    OpImm {
        rd: Register,
        rs1: Register,
        imm: i64,
        funct3: u32,
        funct7: u32,
    }, // I-type ALU (ADDI etc)
    Op {
        rd: Register,
        rs1: Register,
        rs2: Register,
        funct3: u32,
        funct7: u32,
    }, // R-type ALU
    OpImm32 {
        rd: Register,
        rs1: Register,
        imm: i64,
        funct3: u32,
        funct7: u32,
    }, // ADDIW etc
    Op32 {
        rd: Register,
        rs1: Register,
        rs2: Register,
        funct3: u32,
        funct7: u32,
    }, // ADDW etc
    System {
        rd: Register,
        rs1: Register,
        funct3: u32,
        imm: u32,
    }, // CSRs / Ecall (imm used for csr addr usually)
    Amo {
        rd: Register,
        rs1: Register,
        rs2: Register,
        funct3: u32,
        funct5: u32,
        aq: bool,
        rl: bool,
    }, // RV64A atomics (LR/SC/AMO*)
    Fence, // FENCE / FENCE.I
}

#[inline]
pub fn decode(insn: u32) -> Result<Op, Trap> {
    let opcode = insn & 0x7F;
    let rd = Register::from_u32((insn >> 7) & 0x1F);
    let funct3 = (insn >> 12) & 0x7;
    let rs1 = Register::from_u32((insn >> 15) & 0x1F);
    let rs2 = Register::from_u32((insn >> 20) & 0x1F);
    let funct7 = (insn >> 25) & 0x7F;

    // Sign extension helpers
    let imm_i = ((insn as i32) >> 20) as i64;
    let imm_s = (((insn as i32) >> 25) << 5) as i64 | (((insn >> 7) & 0x1F) as i64);
    // B-type: imm[12|10:5|4:1|11]
    let imm_b = {
        let bit31 = (insn >> 31) & 1;
        let bit30_25 = (insn >> 25) & 0x3F;
        let bit11_8 = (insn >> 8) & 0xF;
        let bit7 = (insn >> 7) & 1;
        let val = (bit31 << 12) | (bit7 << 11) | (bit30_25 << 5) | (bit11_8 << 1);
        // Sign extend from bit 12
        ((val as i32) << 19 >> 19) as i64
    };
    // U-type: imm[31:12]
    let imm_u = ((insn as i32) & 0xFFFFF000u32 as i32) as i64;
    // J-type: imm[20|10:1|11|19:12]
    let imm_j = {
        let bit31 = (insn >> 31) & 1;
        let bit30_21 = (insn >> 21) & 0x3FF;
        let bit20 = (insn >> 20) & 1;
        let bit19_12 = (insn >> 12) & 0xFF;
        let val = (bit31 << 20) | (bit19_12 << 12) | (bit20 << 11) | (bit30_21 << 1);
        ((val as i32) << 11 >> 11) as i64
    };

    match opcode {
        0x37 => Ok(Op::Lui { rd, imm: imm_u }),
        0x17 => Ok(Op::Auipc { rd, imm: imm_u }),
        0x6F => Ok(Op::Jal { rd, imm: imm_j }),
        0x67 => Ok(Op::Jalr {
            rd,
            rs1,
            imm: imm_i,
        }),
        0x63 => Ok(Op::Branch {
            rs1,
            rs2,
            imm: imm_b,
            funct3,
        }),
        0x03 => Ok(Op::Load {
            rd,
            rs1,
            imm: imm_i,
            funct3,
        }),
        0x23 => Ok(Op::Store {
            rs1,
            rs2,
            imm: imm_s,
            funct3,
        }),
        0x13 => Ok(Op::OpImm {
            rd,
            rs1,
            imm: imm_i,
            funct3,
            funct7,
        }),
        0x33 => Ok(Op::Op {
            rd,
            rs1,
            rs2,
            funct3,
            funct7,
        }),
        0x1B => Ok(Op::OpImm32 {
            rd,
            rs1,
            imm: imm_i,
            funct3,
            funct7,
        }),
        0x3B => Ok(Op::Op32 {
            rd,
            rs1,
            rs2,
            funct3,
            funct7,
        }),
        0x2F => {
            // A-extension (atomics)
            let funct5 = (insn >> 27) & 0x1F;
            let aq = ((insn >> 26) & 1) != 0;
            let rl = ((insn >> 25) & 1) != 0;
            Ok(Op::Amo {
                rd,
                rs1,
                rs2,
                funct3,
                funct5,
                aq,
                rl,
            })
        }
        0x73 => {
            let i_imm = (insn >> 20) & 0xFFF;
            Ok(Op::System {
                rd,
                rs1,
                funct3,
                imm: i_imm,
            })
        }
        0x0F => Ok(Op::Fence),

        _ => Err(Trap::IllegalInstruction(insn as u64)),
    }
}

// -------- Compressed (C) extension expansion ---------------------------------
//
// These helpers expand 16-bit compressed instructions into canonical 32-bit
// encodings, which are then fed through the normal `decode()` function.

#[inline(always)]
fn encode_i(imm: i32, rs1: u32, funct3: u32, rd: u32, opcode: u32) -> u32 {
    let imm12 = (imm as u32) & 0xFFF;
    (imm12 << 20) | (rs1 << 15) | (funct3 << 12) | (rd << 7) | opcode
}

#[inline(always)]
fn encode_u(imm: i32, rd: u32, opcode: u32) -> u32 {
    // U-type: imm[31:12] in bits[31:12], low 12 bits zero.
    let imm20 = ((imm as u32) >> 12) & 0xFFFFF;
    (imm20 << 12) | (rd << 7) | opcode
}

#[inline(always)]
fn encode_r(funct7: u32, rs2: u32, rs1: u32, funct3: u32, rd: u32, opcode: u32) -> u32 {
    (funct7 << 25) | (rs2 << 20) | (rs1 << 15) | (funct3 << 12) | (rd << 7) | opcode
}

#[inline(always)]
fn encode_s(imm: i32, rs2: u32, rs1: u32, funct3: u32, opcode: u32) -> u32 {
    let imm12 = (imm as u32) & 0xFFF;
    let imm11_5 = (imm12 >> 5) & 0x7F;
    let imm4_0 = imm12 & 0x1F;
    (imm11_5 << 25)
        | (rs2 << 20)
        | (rs1 << 15)
        | (funct3 << 12)
        | (imm4_0 << 7)
        | opcode
}

#[inline(always)]
fn encode_j(imm: i32, rd: u32) -> u32 {
    // J-type immediate, imm is already the signed byte offset.
    let imm20 = ((imm >> 20) & 0x1) as u32;
    let imm10_1 = ((imm >> 1) & 0x3FF) as u32;
    let imm11 = ((imm >> 11) & 0x1) as u32;
    let imm19_12 = ((imm >> 12) & 0xFF) as u32;
    (imm20 << 31) | (imm19_12 << 12) | (imm11 << 20) | (imm10_1 << 21) | (rd << 7) | 0x6F
}

#[inline(always)]
fn encode_b(imm: i32, rs2: u32, rs1: u32, funct3: u32, opcode: u32) -> u32 {
    // B-type immediate, imm is signed byte offset (multiple of 2).
    let imm13 = (imm as u32) & 0x1FFF;
    let imm12 = (imm13 >> 12) & 0x1;
    let imm10_5 = (imm13 >> 5) & 0x3F;
    let imm4_1 = (imm13 >> 1) & 0xF;
    let imm11 = (imm13 >> 11) & 0x1;
    (imm12 << 31)
        | (imm10_5 << 25)
        | (rs2 << 20)
        | (rs1 << 15)
        | (funct3 << 12)
        | (imm4_1 << 8)
        | (imm11 << 7)
        | opcode
}

#[inline(always)]
fn sext(value: u32, bits: u8) -> i32 {
    let shift = 32 - bits as i32;
    ((value << shift) as i32) >> shift
}

#[inline]
pub fn expand_compressed(insn: u16) -> Result<u32, Trap> {
    let opcode = insn & 0x3;
    let funct3 = (insn >> 13) & 0x7;

    match opcode {
        0b00 => expand_q0(insn, funct3),
        0b01 => expand_q1(insn, funct3),
        0b10 => expand_q2(insn, funct3),
        _ => Err(Trap::IllegalInstruction(insn as u64)),
    }
}

#[inline]
fn expand_q0(insn: u16, funct3: u16) -> Result<u32, Trap> {
    let insn_u = insn as u32;
    match funct3 {
        // C.ADDI4SPN -> ADDI rd', x2, nzuimm
        0b000 => {
            let nzuimm = (((insn_u >> 6) & 0x1) << 2)
                | (((insn_u >> 5) & 0x1) << 3)
                | (((insn_u >> 11) & 0x3) << 4)
                | (((insn_u >> 7) & 0xF) << 6);
            if nzuimm == 0 {
                return Err(Trap::IllegalInstruction(insn as u64));
            }
            let rd_prime = 8 + ((insn_u >> 2) & 0x7);
            Ok(encode_i(nzuimm as i32, 2, 0x0, rd_prime, 0x13))
        }
        // C.LW -> LW rd', uimm(rs1')
        0b010 => {
            let uimm =
                (((insn_u >> 6) & 0x1) << 2) | (((insn_u >> 10) & 0x7) << 3) | (((insn_u >> 5) & 0x1) << 6);
            let rd_prime = 8 + ((insn_u >> 2) & 0x7);
            let rs1_prime = 8 + ((insn_u >> 7) & 0x7);
            Ok(encode_i(uimm as i32, rs1_prime, 0x2, rd_prime, 0x03))
        }
        // C.LD -> LD rd', uimm(rs1')
        0b011 => {
            let uimm = (((insn_u >> 10) & 0x7) << 3) | (((insn_u >> 5) & 0x3) << 6);
            let rd_prime = 8 + ((insn_u >> 2) & 0x7);
            let rs1_prime = 8 + ((insn_u >> 7) & 0x7);
            Ok(encode_i(uimm as i32, rs1_prime, 0x3, rd_prime, 0x03))
        }
        // C.SW -> SW rs2', uimm(rs1')
        0b110 => {
            let uimm =
                (((insn_u >> 6) & 0x1) << 2) | (((insn_u >> 10) & 0x7) << 3) | (((insn_u >> 5) & 0x1) << 6);
            let rs2_prime = 8 + ((insn_u >> 2) & 0x7);
            let rs1_prime = 8 + ((insn_u >> 7) & 0x7);
            Ok(encode_s(uimm as i32, rs2_prime, rs1_prime, 0x2, 0x23))
        }
        // C.SD -> SD rs2', uimm(rs1')
        0b111 => {
            let uimm = (((insn_u >> 10) & 0x7) << 3) | (((insn_u >> 5) & 0x3) << 6);
            let rs2_prime = 8 + ((insn_u >> 2) & 0x7);
            let rs1_prime = 8 + ((insn_u >> 7) & 0x7);
            Ok(encode_s(uimm as i32, rs2_prime, rs1_prime, 0x3, 0x23))
        }
        _ => Err(Trap::IllegalInstruction(insn as u64)),
    }
}

#[inline]
fn expand_q1(insn: u16, funct3: u16) -> Result<u32, Trap> {
    let insn_u = insn as u32;
    match funct3 {
        // C.NOP / C.ADDI
        0b000 => {
            let rd = (insn_u >> 7) & 0x1F;
            let imm_bits = ((insn_u >> 2) & 0x1F) | (((insn_u >> 12) & 0x1) << 5);
            let imm = sext(imm_bits, 6);
            if rd == 0 {
                if imm == 0 {
                    // C.NOP
                    return Ok(encode_i(0, 0, 0x0, 0, 0x13));
                } else {
                    return Err(Trap::IllegalInstruction(insn as u64));
                }
            }
            Ok(encode_i(imm, rd, 0x0, rd, 0x13)) // ADDI rd, rd, imm
        }
        // RV64: C.ADDIW
        0b001 => {
            let rd = (insn_u >> 7) & 0x1F;
            let imm_bits = ((insn_u >> 2) & 0x1F) | (((insn_u >> 12) & 0x1) << 5);
            let imm = sext(imm_bits, 6);
            if rd == 0 {
                return Err(Trap::IllegalInstruction(insn as u64));
            }
            Ok(encode_i(imm, rd, 0x0, rd, 0x1B)) // ADDIW rd, rd, imm
        }
        // C.LI -> ADDI rd, x0, imm
        0b010 => {
            let rd = (insn_u >> 7) & 0x1F;
            let imm_bits = ((insn_u >> 2) & 0x1F) | (((insn_u >> 12) & 0x1) << 5);
            let imm = sext(imm_bits, 6);
            if rd == 0 {
                return Err(Trap::IllegalInstruction(insn as u64));
            }
            Ok(encode_i(imm, 0, 0x0, rd, 0x13))
        }
        // C.ADDI16SP / C.LUI
        0b011 => {
            let rd = (insn_u >> 7) & 0x1F;
            if rd == 2 {
                // C.ADDI16SP
                let mut nz = 0u32;
                nz |= ((insn_u >> 12) & 0x1) << 9;
                nz |= ((insn_u >> 3) & 0x3) << 7;
                nz |= ((insn_u >> 5) & 0x1) << 6;
                nz |= ((insn_u >> 2) & 0x1) << 5;
                nz |= ((insn_u >> 6) & 0x1) << 4;
                if nz == 0 {
                    return Err(Trap::IllegalInstruction(insn as u64));
                }
                let imm = sext(nz, 10);
                Ok(encode_i(imm, 2, 0x0, 2, 0x13)) // ADDI x2,x2,imm
            } else {
                // C.LUI -> LUI rd, imm
                let imm_bits = ((insn_u >> 2) & 0x1F) | (((insn_u >> 12) & 0x1) << 5);
                if rd == 0 || imm_bits == 0 {
                    return Err(Trap::IllegalInstruction(insn as u64));
                }
                let imm = sext(imm_bits, 6);
                Ok(encode_u(imm << 12, rd, 0x37))
            }
        }
        // C.SRLI / C.SRAI / C.ANDI / C.SUB/XOR/OR/AND
        0b100 => {
            let rs1_prime = 8 + ((insn_u >> 7) & 0x7);
            let rs2_prime = 8 + ((insn_u >> 2) & 0x7);
            let op = (insn_u >> 10) & 0x3;
            match op {
                // C.SRLI
                0b00 => {
                    let shamt_bits = ((insn_u >> 2) & 0x1F) | (((insn_u >> 12) & 0x1) << 5);
                    let shamt = shamt_bits & 0x3F; // RV64: 6-bit shamt
                    Ok(encode_i(shamt as i32, rs1_prime, 0x5, rs1_prime, 0x13)) // SRLI
                }
                // C.SRAI
                0b01 => {
                    let shamt_bits = ((insn_u >> 2) & 0x1F) | (((insn_u >> 12) & 0x1) << 5);
                    let shamt = shamt_bits & 0x3F;
                    // SRAI encoding: funct7=0b0100000, funct3=101
                    Ok(encode_i((0x20 << 6) | (shamt as i32), rs1_prime, 0x5, rs1_prime, 0x13))
                }
                // C.ANDI
                0b10 => {
                    let imm_bits = ((insn_u >> 2) & 0x1F) | (((insn_u >> 12) & 0x1) << 5);
                    let imm = sext(imm_bits, 6);
                    Ok(encode_i(imm, rs1_prime, 0x7, rs1_prime, 0x13))
                }
                // C.SUB / C.XOR / C.OR / C.AND (bit12=0) or C.SUBW / C.ADDW (bit12=1, RV64)
                0b11 => {
                    let bit12 = (insn_u >> 12) & 0x1;
                    let funct2 = (insn_u >> 5) & 0x3;
                    
                    if bit12 == 0 {
                        // C.SUB / C.XOR / C.OR / C.AND -> R-type with opcode 0x33
                        let (funct3, funct7) = match funct2 {
                            0b00 => (0x0, 0x20), // SUB
                            0b01 => (0x4, 0x00), // XOR
                            0b10 => (0x6, 0x00), // OR
                            0b11 => (0x7, 0x00), // AND
                            _ => unreachable!(),
                        };
                        Ok(
                            (funct7 << 25)
                                | (rs2_prime << 20)
                                | (rs1_prime << 15)
                                | (funct3 << 12)
                                | (rs1_prime << 7)
                                | 0x33,
                        )
                    } else {
                        // RV64C: C.SUBW / C.ADDW -> R-type with opcode 0x3B (Op32)
                        match funct2 {
                            0b00 => {
                                // C.SUBW -> SUBW rd', rd', rs2'
                                Ok(encode_r(0x20, rs2_prime, rs1_prime, 0x0, rs1_prime, 0x3B))
                            }
                            0b01 => {
                                // C.ADDW -> ADDW rd', rd', rs2'
                                Ok(encode_r(0x00, rs2_prime, rs1_prime, 0x0, rs1_prime, 0x3B))
                            }
                            // funct2 = 0b10, 0b11 are reserved in RV64C
                            _ => Err(Trap::IllegalInstruction(insn as u64)),
                        }
                    }
                }
                _ => Err(Trap::IllegalInstruction(insn as u64)),
            }
        }
        // C.J (unconditional jump)
        0b101 => {
            // C.J immediate: imm[11|4|9:8|10|6|7|3:1|5] with bit 0 implicitly 0
            let mut off = 0u32;
            off |= ((insn_u >> 12) & 0x1) << 11;
            off |= ((insn_u >> 11) & 0x1) << 4;
            off |= ((insn_u >> 9) & 0x3) << 8;
            off |= ((insn_u >> 8) & 0x1) << 10;
            off |= ((insn_u >> 7) & 0x1) << 6;
            off |= ((insn_u >> 6) & 0x1) << 7;
            off |= ((insn_u >> 3) & 0x7) << 1;
            off |= ((insn_u >> 2) & 0x1) << 5;
            // off already has bit 0 = 0 implicitly; sign-extend from bit 11
            let imm = sext(off, 12);
            Ok(encode_j(imm, 0)) // JAL x0, imm
        }
        // C.BEQZ
        0b110 => {
            let rs1_prime = 8 + ((insn_u >> 7) & 0x7);
            // C.BEQZ immediate: imm[8|4:3|7:6|2:1|5] with bit 0 implicitly 0
            let mut off = 0u32;
            off |= ((insn_u >> 12) & 0x1) << 8;
            off |= ((insn_u >> 10) & 0x3) << 3;
            off |= ((insn_u >> 5) & 0x3) << 6;
            off |= ((insn_u >> 3) & 0x3) << 1;
            off |= ((insn_u >> 2) & 0x1) << 5;
            // off already has bit 0 = 0 implicitly; sign-extend from bit 8
            let imm = sext(off, 9);
            Ok(encode_b(imm, 0, rs1_prime, 0x0, 0x63)) // BEQ rs1', x0, imm
        }
        // C.BNEZ
        0b111 => {
            let rs1_prime = 8 + ((insn_u >> 7) & 0x7);
            // C.BNEZ immediate: imm[8|4:3|7:6|2:1|5] with bit 0 implicitly 0
            let mut off = 0u32;
            off |= ((insn_u >> 12) & 0x1) << 8;
            off |= ((insn_u >> 10) & 0x3) << 3;
            off |= ((insn_u >> 5) & 0x3) << 6;
            off |= ((insn_u >> 3) & 0x3) << 1;
            off |= ((insn_u >> 2) & 0x1) << 5;
            // off already has bit 0 = 0 implicitly; sign-extend from bit 8
            let imm = sext(off, 9);
            Ok(encode_b(imm, 0, rs1_prime, 0x1, 0x63)) // BNE rs1', x0, imm
        }
        _ => Err(Trap::IllegalInstruction(insn as u64)),
    }
}

#[inline]
fn expand_q2(insn: u16, funct3: u16) -> Result<u32, Trap> {
    let insn_u = insn as u32;
    match funct3 {
        // C.SLLI
        0b000 => {
            let rd = (insn_u >> 7) & 0x1F;
            let imm_bits = ((insn_u >> 2) & 0x1F) | (((insn_u >> 12) & 0x1) << 5);
            let imm = imm_bits & 0x3F; // RV64: 6-bit shamt
            if rd == 0 {
                return Err(Trap::IllegalInstruction(insn as u64));
            }
            Ok(encode_i(imm as i32, rd, 0x1, rd, 0x13))
        }
        // C.LWSP
        0b010 => {
            let rd = (insn_u >> 7) & 0x1F;
            if rd == 0 {
                return Err(Trap::IllegalInstruction(insn as u64));
            }
            let uimm = (((insn_u >> 4) & 0x7) << 2)
                | (((insn_u >> 12) & 0x1) << 5)
                | (((insn_u >> 2) & 0x3) << 6);
            Ok(encode_i(uimm as i32, 2, 0x2, rd, 0x03))
        }
        // C.LDSP: LD rd, uimm(sp) - uimm[5|4:3|8:6] scaled by 8
        0b011 => {
            let rd = (insn_u >> 7) & 0x1F;
            if rd == 0 {
                return Err(Trap::IllegalInstruction(insn as u64));
            }
            // bit 12 -> uimm[5], bits [6:5] -> uimm[4:3], bits [4:2] -> uimm[8:6]
            let uimm = (((insn_u >> 12) & 0x1) << 5)
                | (((insn_u >> 5) & 0x3) << 3)
                | (((insn_u >> 2) & 0x7) << 6);
            Ok(encode_i(uimm as i32, 2, 0x3, rd, 0x03))
        }
        // C.JR / C.MV / C.EBREAK / C.JALR / C.ADD
        0b100 => {
            let rd = (insn_u >> 7) & 0x1F;
            let rs2 = (insn_u >> 2) & 0x1F;
            let bit12 = (insn_u >> 12) & 0x1;
            match (bit12, rs2, rd) {
                // C.JR: rs2=0, bit12=0, rd!=0
                (0, 0, rd) if rd != 0 => {
                    Ok(encode_i(0, rd, 0x0, 0, 0x67)) // JALR x0, rd, 0
                }
                // C.MV: bit12=0, rs2!=0, rd!=0
                (0, rs2, rd) if rs2 != 0 && rd != 0 => {
                    Ok(encode_r(0x00, rs2, 0, 0x0, rd, 0x33)) // ADD rd, x0, rs2
                }
                // C.EBREAK: bit12=1, rd=0, rs2=0
                (1, 0, 0) => Ok(0x0010_0073),
                // C.JALR: bit12=1, rs2=0, rd!=0
                (1, 0, rd) if rd != 0 => {
                    Ok(encode_i(0, rd, 0x0, 1, 0x67)) // JALR x1, rd, 0
                }
                // C.ADD: bit12=1, rs2!=0, rd!=0
                (1, rs2, rd) if rs2 != 0 && rd != 0 => {
                    Ok(encode_r(0x00, rs2, rd, 0x0, rd, 0x33)) // ADD rd, rd, rs2
                }
                _ => Err(Trap::IllegalInstruction(insn as u64)),
            }
        }
        // C.SWSP: SW rs2, uimm(sp) - uimm[5:2|7:6] scaled by 4
        0b110 => {
            let rs2 = (insn_u >> 2) & 0x1F;
            // bits [12:9] -> uimm[5:2], bits [8:7] -> uimm[7:6]
            let uimm = (((insn_u >> 9) & 0xF) << 2) | (((insn_u >> 7) & 0x3) << 6);
            Ok(encode_s(uimm as i32, rs2, 2, 0x2, 0x23))
        }
        // C.SDSP: SD rs2, uimm(sp) - uimm[5:3|8:6] scaled by 8
        0b111 => {
            let rs2 = (insn_u >> 2) & 0x1F;
            // bits [12:10] -> uimm[5:3], bits [9:7] -> uimm[8:6]
            let uimm = (((insn_u >> 10) & 0x7) << 3) | (((insn_u >> 7) & 0x7) << 6);
            Ok(encode_s(uimm as i32, rs2, 2, 0x3, 0x23))
        }
        _ => Err(Trap::IllegalInstruction(insn as u64)),
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn decode_lui_and_jal() {
        // LUI x2, 0x12345
        let lui_insn: u32 = 0x12345137;
        let op = decode(lui_insn).unwrap();
        match op {
            Op::Lui { rd, imm } => {
                assert_eq!(rd, Register::X2);
                assert_eq!(imm, 0x0000_0000_1234_5000);
            }
            _ => panic!("Expected LUI op"),
        }

        // JAL x1, 8 (matches cpu::tests::test_jal)
        let jal_insn: u32 = (4 << 21) | (1 << 7) | 0x6F;
        let op = decode(jal_insn).unwrap();
        match op {
            Op::Jal { rd, imm } => {
                assert_eq!(rd, Register::X1);
                assert_eq!(imm, 8);
            }
            _ => panic!("Expected JAL op"),
        }
    }

    #[test]
    fn decode_illegal_opcode() {
        // Opcode with bits[6:0] not matching any valid RV64I opcode we implement.
        let bad: u32 = 0x0000_0000;
        let res = decode(bad);
        match res {
            Err(Trap::IllegalInstruction(bits)) => assert_eq!(bits, bad as u64),
            _ => panic!("Expected IllegalInstruction trap"),
        }
    }

    #[test]
    fn expand_compressed_basic_integer_ops() {
        // These 16-bit encodings come from assembling with rv64imac:
        //   addi x8, x2, 16          # C.ADDI4SPN
        //   addi x11,x11,1           # C.ADDI
        //   addiw x12,x12,1          # C.ADDIW
        //   addi x13,x0,-1           # C.LI
        //   addi x2, x2, 16          # C.ADDI16SP
        //   lui  x14,1               # C.LUI
        let c_addi4spn: u16 = 0x0800;
        let c_addi: u16 = 0x0585;
        let c_addiw: u16 = 0x2605;
        let c_li: u16 = 0x56FD;
        let c_addi16sp: u16 = 0x0141;
        let c_lui: u16 = 0x6705;

        // C.ADDI4SPN -> ADDI x8, x2, 16
        let op = decode(expand_compressed(c_addi4spn).unwrap()).unwrap();
        match op {
            Op::OpImm { rd, rs1, imm, funct3, .. } => {
                assert_eq!(rd, Register::X8);
                assert_eq!(rs1, Register::X2);
                assert_eq!(imm, 16);
                assert_eq!(funct3, 0);
            }
            _ => panic!("Expected OpImm from C.ADDI4SPN"),
        }

        // C.ADDI -> ADDI x11, x11, 1
        let op = decode(expand_compressed(c_addi).unwrap()).unwrap();
        match op {
            Op::OpImm { rd, rs1, imm, .. } => {
                assert_eq!(rd, Register::X11);
                assert_eq!(rs1, Register::X11);
                assert_eq!(imm, 1);
            }
            _ => panic!("Expected OpImm from C.ADDI"),
        }

        // C.ADDIW -> ADDIW x12, x12, 1
        let op = decode(expand_compressed(c_addiw).unwrap()).unwrap();
        match op {
            Op::OpImm32 { rd, rs1, imm, .. } => {
                assert_eq!(rd, Register::X12);
                assert_eq!(rs1, Register::X12);
                assert_eq!(imm, 1);
            }
            _ => panic!("Expected OpImm32 from C.ADDIW"),
        }

        // C.LI -> ADDI x13, x0, -1
        let op = decode(expand_compressed(c_li).unwrap()).unwrap();
        match op {
            Op::OpImm { rd, rs1, imm, .. } => {
                assert_eq!(rd, Register::X13);
                assert_eq!(rs1, Register::X0);
                assert_eq!(imm, -1);
            }
            _ => panic!("Expected OpImm from C.LI"),
        }

        // C.ADDI16SP -> ADDI x2, x2, 16
        let op = decode(expand_compressed(c_addi16sp).unwrap()).unwrap();
        match op {
            Op::OpImm { rd, rs1, imm, .. } => {
                assert_eq!(rd, Register::X2);
                assert_eq!(rs1, Register::X2);
                assert_eq!(imm, 16);
            }
            _ => panic!("Expected OpImm from C.ADDI16SP"),
        }

        // C.LUI -> LUI x14, 1
        let op = decode(expand_compressed(c_lui).unwrap()).unwrap();
        match op {
            Op::Lui { rd, imm } => {
                assert_eq!(rd, Register::X14);
                assert_eq!(imm, 0x0000_0000_0000_1000);
            }
            _ => panic!("Expected Lui from C.LUI"),
        }
    }
}
</file>

<file path="riscv-vm/src/emulator.rs">
use crate::bus::{SystemBus, DRAM_BASE};
use crate::cpu::Cpu;
use crate::Trap;
use goblin::elf::{program_header::PT_LOAD, Elf};
use std::fs::File;
use std::io::{self, Read, Write};
use std::path::Path;
use std::sync::atomic::{AtomicU8, AtomicU64, Ordering};
use std::sync::Arc;
use std::thread::{self, JoinHandle};
use std::time::{Duration, Instant};

use serde::{Deserialize, Serialize};
use sha2::{Digest, Sha256};
use std::collections::HashMap;

#[cfg(not(target_arch = "wasm32"))]
use crate::console::Console;

/// Shared state between main thread and worker threads.
///
/// This struct is wrapped in Arc and shared across all threads.
/// All fields use atomics for lock-free synchronization.
///
/// Aligned to 64 bytes to prevent false sharing with adjacent data.
/// Combined flags into a single atomic for faster polling.
#[repr(align(64))]
pub struct SharedState {
    /// Combined flags: bit 0 = halt_requested, bit 1 = halted
    /// Using a single atomic reduces should_stop() from 2 loads to 1.
    flags: AtomicU8,
    /// Halt code (e.g., from TEST_FINISHER).
    halt_code: AtomicU64,
    /// Padding to prevent false sharing with adjacent data.
    _padding: [u8; 64 - std::mem::size_of::<AtomicU8>() - std::mem::size_of::<AtomicU64>()],
}

impl SharedState {
    /// Flag bit for halt_requested
    const HALT_REQUESTED: u8 = 0x01;
    /// Flag bit for halted
    const HALTED: u8 = 0x02;

    /// Create new shared state.
    pub fn new() -> Self {
        Self {
            flags: AtomicU8::new(0),
            halt_code: AtomicU64::new(0),
            _padding: [0; 64 - std::mem::size_of::<AtomicU8>() - std::mem::size_of::<AtomicU64>()],
        }
    }

    /// Request all threads to halt.
    pub fn request_halt(&self) {
        // Use Release ordering - ensures all prior writes are visible
        // before the halt flag becomes visible
        self.flags.fetch_or(Self::HALT_REQUESTED, Ordering::Release);
    }

    /// Check if halt has been requested.
    pub fn is_halt_requested(&self) -> bool {
        // Use Relaxed - we just need to eventually see the flag
        (self.flags.load(Ordering::Relaxed) & Self::HALT_REQUESTED) != 0
    }

    /// Signal that a thread has halted (e.g., due to trap).
    pub fn signal_halted(&self, code: u64) {
        self.halt_code.store(code, Ordering::Relaxed);
        // Use Release for the halted flag to ensure halt_code is visible
        self.flags.fetch_or(Self::HALTED, Ordering::Release);
    }

    /// Check if any thread has halted.
    pub fn is_halted(&self) -> bool {
        (self.flags.load(Ordering::Relaxed) & Self::HALTED) != 0
    }

    /// Get the halt code.
    pub fn halt_code(&self) -> u64 {
        // Use Acquire to ensure we see the halt_code written before halted was set
        self.halt_code.load(Ordering::Acquire)
    }

    /// Check if we should stop (either requested or already halted).
    /// 
    /// Performance note: This is called frequently, so we use Relaxed ordering
    /// and a single atomic load (combined flags). The flags will eventually
    /// become visible.
    #[inline(always)]
    pub fn should_stop(&self) -> bool {
        // Single atomic load instead of two - faster polling
        self.flags.load(Ordering::Relaxed) != 0
    }
}

impl Default for SharedState {
    fn default() -> Self {
        Self::new()
    }
}

/// Default DRAM size used when constructing an [`Emulator`] via [`Emulator::new`].
///
/// This is large enough for riscv-arch-test binaries and small kernels, while
/// still being reasonably light for host machines.
const DEFAULT_DRAM_MIB: usize = 128;

/// Default size of the signature region when only a base address is provided.
///
/// RISCOF test signatures are typically small; 4 KiB is a conservative
/// default and can be overridden via [`Emulator::set_signature_region`].
const DEFAULT_SIGNATURE_SIZE: u64 = 4 * 1024;

/// High-level emulator wrapper used by test harnesses (e.g. RISCOF backend).
///
/// This mirrors the sketch in `phase-6.md`:
///
/// ```ignore
/// let mut emu = Emulator::new();
/// emu.load_elf("test.elf")?;
/// emu.set_signature_addr(0x8001_0000);
/// while !emu.trapped() { emu.step()?; }
/// let sig = emu.read_signature()?;
/// ```
pub struct Emulator {
    /// CPU core (GPRs, CSRs, privilege mode, TLB, etc).
    pub cpu: Cpu,
    /// System bus with DRAM and all memory-mapped devices.
    pub bus: SystemBus,

    signature_addr: Option<u64>,
    signature_size: u64,

    trapped: bool,
    last_trap: Option<Trap>,

    /// Optional UART output callback invoked once per transmitted byte.
    ///
    /// This provides a deterministic, buffered integration point for hosts
    /// (CLI, web UI, tests) without requiring them to poll the UART FIFO.
    uart_callback: Option<Box<dyn FnMut(u8) + 'static>>,
}

impl Emulator {
    /// Create a new emulator instance with the default DRAM size and reset PC.
    ///
    /// The reset PC is initialised to the DRAM base (0x8000_0000) but will be
    /// overwritten by [`load_elf`] when an ELF image is loaded.
    pub fn new() -> Self {
        Self::with_memory(DEFAULT_DRAM_MIB * 1024 * 1024)
    }

    /// Create a new emulator instance with an explicit DRAM size in bytes.
    pub fn with_memory(dram_size_bytes: usize) -> Self {
        let dram_base = DRAM_BASE;
        let bus = SystemBus::new(dram_base, dram_size_bytes);
        let cpu = Cpu::new(dram_base, 0);  // hart_id = 0

        Self {
            cpu,
            bus,
            signature_addr: None,
            signature_size: 0,
            trapped: false,
            last_trap: None,
            uart_callback: None,
        }
    }

    /// Returns `true` once execution has terminated due to a trap or
    /// an explicit host-level stop condition.
    pub fn trapped(&self) -> bool {
        self.trapped
    }

    /// Returns the last architectural trap observed, if any.
    pub fn last_trap(&self) -> Option<&Trap> {
        self.last_trap.as_ref()
    }

    /// Register a UART output callback.
    ///
    /// The callback is invoked from [`step`] for each byte emitted by the
    /// emulated NS16550A UART. Hosts that prefer pull-based I/O can ignore
    /// this and call [`drain_uart_output`] instead.
    pub fn set_uart_callback<F>(&mut self, cb: F)
    where
        F: FnMut(u8) + 'static,
    {
        self.uart_callback = Some(Box::new(cb));
    }

    /// Push a single input byte into the UART RX FIFO.
    ///
    /// This models a host keystroke or serial input event in a buffered,
    /// deterministic way: given the same sequence of calls and instruction
    /// stream, the guest will see identical input ordering.
    pub fn push_key(&mut self, byte: u8) {
        self.bus.uart.push_input(byte);
    }

    /// Drain all pending UART output bytes into a vector.
    ///
    /// This is useful for tests or hosts that do not wish to use the callback
    /// interface.
    pub fn drain_uart_output(&mut self) -> Vec<u8> {
        let mut out = Vec::new();
        while let Some(b) = self.bus.uart.pop_output() {
            out.push(b);
        }
        out
    }

    /// Execute a single instruction.
    ///
    /// On success, returns `Ok(())`. On architectural traps, this records the
    /// trap in [`last_trap`] and sets [`trapped`] before returning `Err(trap)`.
    pub fn step(&mut self) -> Result<(), Trap> {
        match self.cpu.step(&self.bus) {
            Ok(()) => {
                // Deliver UART bytes to host callback if registered.
                if let Some(cb) = self.uart_callback.as_mut() {
                    while let Some(byte) = self.bus.uart.pop_output() {
                        cb(byte);
                    }
                }

                Ok(())
            }
            Err(trap) => {
                self.trapped = true;
                self.last_trap = Some(trap.clone());
                Err(trap)
            }
        }
    }

    /// Load an ELF image from disk into DRAM and update the CPU's PC to the
    /// ELF entry point.
    ///
    /// Returns the resolved entry PC on success.
    pub fn load_elf<P: AsRef<Path>>(
        &mut self,
        path: P,
    ) -> Result<u64, Box<dyn std::error::Error>> {
        let mut file = File::open(path)?;
        let mut buffer = Vec::new();
        file.read_to_end(&mut buffer)?;

        let entry_pc = load_elf_into_dram(&buffer, &mut self.bus)?;
        self.cpu.pc = entry_pc;
        Ok(entry_pc)
    }

    /// Configure the signature region used by `read_signature`.
    ///
    /// - `base` is the physical start address of the signature buffer.
    /// - `size` is the number of bytes to read.
    pub fn set_signature_region(&mut self, base: u64, size: u64) {
        self.signature_addr = Some(base);
        self.signature_size = size;
    }

    /// Convenience helper matching the `phase-6.md` sketch.
    ///
    /// This sets the base address and uses a default size of 4 KiB unless a
    /// region size has already been configured via [`set_signature_region`].
    pub fn set_signature_addr(&mut self, base: u64) {
        self.signature_addr = Some(base);
        if self.signature_size == 0 {
            self.signature_size = DEFAULT_SIGNATURE_SIZE;
        }
    }

    /// Read the configured signature region from DRAM.
    ///
    /// Returns an owned `Vec<u8>` which callers can hex-encode or compare
    /// against reference signatures.
    pub fn read_signature(&self) -> Result<Vec<u8>, String> {
        let base = self
            .signature_addr
            .ok_or_else(|| "signature address not configured".to_string())?;
        if self.signature_size == 0 {
            return Err("signature size is zero; call set_signature_region first".to_string());
        }

        let dram_base = self.bus.dram_base();
        let dram_size = self.bus.dram_size() as u64;

        if base < dram_base || base >= dram_base + dram_size {
            return Err(format!(
                "signature base 0x{base:016x} lies outside DRAM (0x{dram_base:016x}..0x{:016x})",
                dram_base + dram_size
            ));
        }

        let offset = (base - dram_base) as usize;
        let end = offset
            .checked_add(self.signature_size as usize)
            .ok_or_else(|| "signature range overflow".to_string())?;

        if end > self.bus.dram_size() {
            return Err("signature range extends beyond DRAM".to_string());
        }

        // SAFETY: bounds checked above.
        self.bus.dram.read_range(offset, self.signature_size as usize)
            .map_err(|e| format!("failed to read signature: {}", e))
    }
}

const SNAPSHOT_VERSION: &str = "2.0";

/// Serializable CPU state used in snapshots.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CpuSnapshot {
    pub pc: u64,
    pub mode: crate::csr::Mode,
    pub regs: [u64; 32],
    pub csrs: HashMap<u16, u64>,
}

/// Serializable CLINT state.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ClintSnapshot {
    pub msip: Vec<u32>,
    pub mtime: u64,
    pub mtimecmp: Vec<u64>,
}

/// Serializable PLIC state.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PlicSnapshot {
    pub priority: Vec<u32>,
    pub pending: u32,
    pub enable: Vec<u32>,
    pub threshold: Vec<u32>,
    pub active: Vec<u32>,
}

/// Serializable UART state.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct UartSnapshot {
    pub rx_fifo: Vec<u8>,
    pub tx_fifo: Vec<u8>,
    pub ier: u8,
    pub iir: u8,
    pub fcr: u8,
    pub lcr: u8,
    pub mcr: u8,
    pub lsr: u8,
    pub msr: u8,
    pub scr: u8,
    pub dll: u8,
    pub dlm: u8,
}

/// Serializable device state bundle.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DeviceSnapshot {
    pub clint: ClintSnapshot,
    pub plic: PlicSnapshot,
    pub uart: UartSnapshot,
}

/// Memory region snapshot (currently we only snapshot DRAM as a single region).
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MemRegionSnapshot {
    pub base: u64,
    pub size: u64,
    pub hash: String,
    pub data: Option<Vec<u8>>,
}

/// Full emulator snapshot including CPU, devices and DRAM.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Snapshot {
    pub version: String,
    pub cpu: CpuSnapshot,
    pub devices: DeviceSnapshot,
    pub memory: Vec<MemRegionSnapshot>,
}

impl Emulator {
    /// Capture a complete, deterministic snapshot of the current emulator state.
    pub fn snapshot(&self) -> Snapshot {
        let cpu = CpuSnapshot {
            pc: self.cpu.pc,
            mode: self.cpu.mode,
            regs: self.cpu.regs,
            csrs: self.cpu.export_csrs(),
        };

        let clint = ClintSnapshot {
            msip: self.bus.clint.get_msip_array().to_vec(),
            mtime: self.bus.clint.mtime(),
            mtimecmp: self.bus.clint.get_mtimecmp_array().to_vec(),
        };

        let plic = PlicSnapshot {
            priority: self.bus.plic.get_priority(),
            pending: self.bus.plic.get_pending(),
            enable: self.bus.plic.get_enable(),
            threshold: self.bus.plic.get_threshold(),
            active: self.bus.plic.get_active(),
        };

        let (ier, iir, fcr, lcr, mcr, lsr, msr, scr, dll, dlm) = self.bus.uart.get_registers();
        let uart = UartSnapshot {
            rx_fifo: self.bus.uart.get_input(),
            tx_fifo: self.bus.uart.get_output(),
            ier,
            iir,
            fcr,
            lcr,
            mcr,
            lsr,
            msr,
            scr,
            dll,
            dlm,
        };

        let dram_data = self.bus.dram.get_data();
        let mut hasher = Sha256::new();
        hasher.update(&dram_data);
        let hash = hex::encode(hasher.finalize());

        let region = MemRegionSnapshot {
            base: self.bus.dram.base,
            size: self.bus.dram.size() as u64,
            hash,
            data: Some(dram_data),
        };

        Snapshot {
            version: SNAPSHOT_VERSION.to_string(),
            cpu,
            devices: DeviceSnapshot { clint, plic, uart },
            memory: vec![region],
        }
    }

    /// Restore emulator state from a previously captured snapshot.
    pub fn apply_snapshot(&mut self, snapshot: &Snapshot) -> Result<(), String> {
        if snapshot.version != SNAPSHOT_VERSION {
            return Err(format!(
                "snapshot version mismatch: expected {}, found {}",
                SNAPSHOT_VERSION, snapshot.version
            ));
        }

        // Restore CPU core.
        self.cpu.pc = snapshot.cpu.pc;
        self.cpu.mode = snapshot.cpu.mode;
        self.cpu.regs = snapshot.cpu.regs;
        self.cpu.import_csrs(&snapshot.cpu.csrs);
        self.trapped = false;
        self.last_trap = None;

        // Restore CLINT.
        self.bus.clint.set_msip_array(&snapshot.devices.clint.msip);
        self.bus.clint.set_mtime(snapshot.devices.clint.mtime);
        self.bus.clint.set_mtimecmp_array(&snapshot.devices.clint.mtimecmp);

        // Restore PLIC.
        self.bus.plic.set_priority(&snapshot.devices.plic.priority);
        self.bus.plic.set_pending(snapshot.devices.plic.pending);
        self.bus.plic.set_enable(&snapshot.devices.plic.enable);
        self.bus.plic.set_threshold(&snapshot.devices.plic.threshold);
        self.bus.plic.set_active(&snapshot.devices.plic.active);

        // Restore UART.
        self.bus.uart.set_input(&snapshot.devices.uart.rx_fifo);
        self.bus.uart.set_output(&snapshot.devices.uart.tx_fifo);
        self.bus.uart.set_registers(
            snapshot.devices.uart.ier,
            snapshot.devices.uart.iir,
            snapshot.devices.uart.fcr,
            snapshot.devices.uart.lcr,
            snapshot.devices.uart.mcr,
            snapshot.devices.uart.lsr,
            snapshot.devices.uart.msr,
            snapshot.devices.uart.scr,
            snapshot.devices.uart.dll,
            snapshot.devices.uart.dlm,
        );

        // Restore DRAM.
        let region = snapshot
            .memory
            .get(0)
            .ok_or_else(|| "snapshot missing primary memory region".to_string())?;

        let data = region
            .data
            .as_ref()
            .ok_or_else(|| "snapshot memory region has no inline data".to_string())?;

        if self.bus.dram.base != region.base {
            return Err(format!(
                "snapshot DRAM base mismatch: emulator=0x{:x}, snapshot=0x{:x}",
                self.bus.dram.base, region.base
            ));
        }
        if self.bus.dram.size() != data.len() {
            return Err(format!(
                "snapshot DRAM size mismatch: emulator={} bytes, snapshot={} bytes",
                self.bus.dram.size(),
                data.len()
            ));
        }

        let mut hasher = Sha256::new();
        hasher.update(data);
        let current_hash = hex::encode(hasher.finalize());
        if current_hash != region.hash {
            return Err(format!(
                "snapshot DRAM hash mismatch for base 0x{:x}",
                region.base
            ));
        }

        self.bus.dram.set_data(data)
            .map_err(|e| format!("failed to restore DRAM: {}", e))?;

        Ok(())
    }

    /// Construct a new emulator instance from a snapshot.
    pub fn from_snapshot(snapshot: Snapshot) -> Result<Self, String> {
        let region = snapshot
            .memory
            .get(0)
            .ok_or_else(|| "snapshot missing primary memory region".to_string())?;
        let dram_size = region
            .size
            .try_into()
            .map_err(|_| "snapshot DRAM size does not fit in usize".to_string())?;

        let mut emu = Emulator::with_memory(dram_size);
        emu.apply_snapshot(&snapshot)?;
        Ok(emu)
    }

    /// Save a snapshot to disk using bincode.
    pub fn save_snapshot_to_path<P: AsRef<Path>>(
        &self,
        path: P,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let snap = self.snapshot();
        let mut file = File::create(path)?;
        bincode::serialize_into(&mut file, &snap)?;
        file.flush()?;
        Ok(())
    }

    /// Load a snapshot from disk and construct a new emulator instance.
    pub fn load_snapshot_from_path<P: AsRef<Path>>(
        path: P,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        let mut file = File::open(path)?;
        let snapshot: Snapshot = bincode::deserialize_from(&mut file)?;
        let emu = Emulator::from_snapshot(snapshot)
            .map_err(|e| std::io::Error::new(std::io::ErrorKind::Other, e))?;
        Ok(emu)
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::bus::Bus;

    // --- Memory layout tests (Task 10.1/10.4) ---

    #[test]
    fn measure_shared_state_size() {
        use crate::cpu::Cpu;
        use crate::bus::SystemBus;
        use crate::clint::Clint;
        use crate::plic::Plic;

        println!("=== Phase 10 Memory Layout Analysis ===");
        println!("Cpu size: {} bytes", std::mem::size_of::<Cpu>());
        println!("Cpu align: {} bytes", std::mem::align_of::<Cpu>());
        println!("SharedState size: {} bytes", std::mem::size_of::<SharedState>());
        println!("SharedState align: {} bytes", std::mem::align_of::<SharedState>());
        println!("SystemBus size: {} bytes", std::mem::size_of::<SystemBus>());
        println!("Clint size: {} bytes", std::mem::size_of::<Clint>());
        println!("Plic size: {} bytes", std::mem::size_of::<Plic>());
    }

    #[test]
    fn test_shared_state_alignment() {
        // SharedState should be cache-line aligned (64 bytes)
        assert_eq!(
            std::mem::align_of::<SharedState>(),
            64,
            "SharedState should be aligned to 64 bytes"
        );

        // Size should be exactly 64 bytes (one cache line)
        assert_eq!(
            std::mem::size_of::<SharedState>(),
            64,
            "SharedState should be exactly 64 bytes (one cache line)"
        );
    }

    #[test]
    fn test_shared_state_should_stop() {
        let state = SharedState::new();

        // Initially not stopped
        assert!(!state.should_stop());
        assert!(!state.is_halt_requested());
        assert!(!state.is_halted());

        // Request halt
        state.request_halt();
        assert!(state.should_stop());
        assert!(state.is_halt_requested());
        assert!(!state.is_halted());

        // Reset for next test (create new instance)
        let state2 = SharedState::new();
        assert!(!state2.should_stop());

        // Signal halted
        state2.signal_halted(42);
        assert!(state2.should_stop());
        assert!(!state2.is_halt_requested());
        assert!(state2.is_halted());
        assert_eq!(state2.halt_code(), 42);
    }

    #[test]
    fn test_shared_state_concurrent() {
        use std::sync::Arc;
        use std::thread;

        let state = Arc::new(SharedState::new());
        let mut handles = vec![];

        // Spawn multiple threads polling should_stop
        for _ in 0..4 {
            let state_clone = Arc::clone(&state);
            let handle = thread::spawn(move || {
                for _ in 0..100_000 {
                    let _ = state_clone.should_stop();
                }
            });
            handles.push(handle);
        }

        // All threads should complete without panic
        for handle in handles {
            handle.join().unwrap();
        }
    }

    #[test]
    fn snapshot_roundtrip_preserves_state() {
        let mut emu = Emulator::with_memory(1024 * 1024);

        // Simple CPU state.
        emu.cpu.pc = DRAM_BASE + 0x1000;
        emu.cpu.write_reg(crate::decoder::Register::X5, 0xdead_beef_dead_beef);

        // Touch DRAM and devices.
        let addr = emu.bus.dram_base() + 0x80;
        emu.bus.write64(addr, 0x0123_4567_89ab_cdef).unwrap();
        emu.bus.clint.set_mtime(1234);
        {
            let mut mtimecmp = emu.bus.clint.get_mtimecmp_array();
            mtimecmp[0] = 5678;
            emu.bus.clint.set_mtimecmp_array(&mtimecmp);
        }
        emu.bus.uart.push_input(b'A');

        let snap = emu.snapshot();
        let bytes = bincode::serialize(&snap).unwrap();
        let snap2: Snapshot = bincode::deserialize(&bytes).unwrap();

        let emu2 = Emulator::from_snapshot(snap2).unwrap();

        assert_eq!(emu.cpu.pc, emu2.cpu.pc);
        assert_eq!(
            emu.cpu.read_reg(crate::decoder::Register::X5),
            emu2.cpu.read_reg(crate::decoder::Register::X5)
        );
        assert_eq!(emu.bus.dram.get_data(), emu2.bus.dram.get_data());
        assert_eq!(emu.bus.clint.mtime(), emu2.bus.clint.mtime());
        assert_eq!(emu.bus.clint.get_mtimecmp_array(), emu2.bus.clint.get_mtimecmp_array());
        assert_eq!(emu.bus.uart.get_input(), emu2.bus.uart.get_input());
    }
}

fn load_elf_into_dram(
    buffer: &[u8],
    bus: &mut SystemBus,
) -> Result<u64, Box<dyn std::error::Error>> {
    let elf = Elf::parse(buffer)?;
    let base = bus.dram_base();
    let dram_end = base + bus.dram_size() as u64;

    for ph in &elf.program_headers {
        if ph.p_type != PT_LOAD || ph.p_memsz == 0 {
            continue;
        }

        let file_size = ph.p_filesz as usize;
        let mem_size = ph.p_memsz as usize;
        let file_offset = ph.p_offset as usize;
        if file_offset + file_size > buffer.len() {
            return Err(format!(
                "ELF segment exceeds file bounds (offset 0x{:x})",
                file_offset
            )
            .into());
        }

        let target_addr = if ph.p_paddr != 0 {
            ph.p_paddr
        } else {
            ph.p_vaddr
        };
        if target_addr < base {
            return Err(format!(
                "Segment start 0x{:x} lies below DRAM base 0x{:x}",
                target_addr, base
            )
            .into());
        }
        let seg_end = target_addr
            .checked_add(mem_size as u64)
            .ok_or_else(|| "Segment end overflow".to_string())?;
        if seg_end > dram_end {
            return Err(format!(
                "Segment 0x{:x}-0x{:x} exceeds DRAM (end 0x{:x})",
                target_addr, seg_end, dram_end
            )
            .into());
        }

        let dram_offset = (target_addr - base) as u64;
        if file_size > 0 {
            let end = file_offset + file_size;
            bus.dram
                .load(&buffer[file_offset..end], dram_offset)
                .map_err(|e| format!("Failed to load segment: {}", e))?;
        }
        if mem_size > file_size {
            let zero_start = dram_offset as usize + file_size;
            bus.dram
                .zero_range(zero_start, mem_size - file_size)
                .map_err(|e| format!("Failed to zero bss: {}", e))?;
        }
        log::debug!(
            "Loaded segment: addr=0x{:x}, filesz=0x{:x}, memsz=0x{:x}",
            target_addr,
            file_size,
            mem_size
        );
    }

    Ok(elf.entry)
}

// ============================================================================
// NativeVm - Multi-threaded VM for native execution
// ============================================================================

/// Reason for halting batch execution.
#[cfg(not(target_arch = "wasm32"))]
enum HaltReason {
    /// VM shutdown requested (e.g., via TEST_FINISHER)
    Shutdown(u64),
    /// Fatal emulator error (message, PC)
    Fatal(String, u64),
}

#[cfg(not(target_arch = "wasm32"))]
/// Native multi-threaded VM.
///
/// Manages one thread per hart, with hart 0 running on the main thread
/// for I/O coordination.
pub struct NativeVm {
    /// Shared bus (thread-safe after Phase 2).
    bus: Arc<SystemBus>,
    /// Thread handles for worker threads (harts 1+).
    handles: Vec<JoinHandle<()>>,
    /// Primary hart CPU (runs on main thread for I/O).
    primary_cpu: Option<Cpu>,
    /// Shared state for coordination.
    pub shared: Arc<SharedState>,
    /// Number of harts.
    num_harts: usize,
    /// Kernel entry point.
    entry_pc: u64,
}

#[cfg(not(target_arch = "wasm32"))]
impl NativeVm {
    /// Create a new VM with the given kernel.
    ///
    /// # Arguments
    /// * `kernel` - Kernel binary (ELF or raw)
    /// * `num_harts` - Number of harts (CPUs) to create
    pub fn new(kernel: &[u8], num_harts: usize) -> Result<Self, String> {
        const DRAM_SIZE: usize = 512 * 1024 * 1024;
        let bus = SystemBus::new(DRAM_BASE, DRAM_SIZE);
        
        // Set hart count in CLINT so kernel can read it
        bus.set_num_harts(num_harts);

        // Load kernel (ELF or raw)
        let entry_pc = if kernel.starts_with(b"\x7FELF") {
            load_elf_native(kernel, &bus)?
        } else {
            bus.dram
                .load(kernel, 0)
                .map_err(|e| format!("Failed to load kernel: {:?}", e))?;
            DRAM_BASE
        };

        let bus = Arc::new(bus);
        let shared = Arc::new(SharedState::new());

        // Create primary CPU (hart 0)
        let primary_cpu = Some(Cpu::new(entry_pc, 0));

        println!("[VM] Created with {} harts, entry=0x{:x}", num_harts, entry_pc);

        Ok(Self {
            bus,
            handles: Vec::new(),
            primary_cpu,
            shared,
            num_harts,
            entry_pc,
        })
    }

    /// Create a VM with auto-detected hart count.
    /// Uses half the available CPU cores on the host.
    pub fn new_auto(kernel: &[u8]) -> Result<Self, String> {
        let cpus = std::thread::available_parallelism()
            .map(|n| n.get())
            .unwrap_or(2);
        let num_harts = (cpus / 2).max(1); // Use half the CPUs, ensure at least 1
        Self::new(kernel, num_harts)
    }

    /// Load a disk image and attach as VirtIO block device.
    pub fn load_disk(&mut self, disk: Vec<u8>) {
        use crate::virtio::VirtioBlock;

        // Need to get mutable access to bus - this requires unsafe or RefCell
        // For now, load disk before creating workers
        if let Some(bus) = Arc::get_mut(&mut self.bus) {
            let vblk = VirtioBlock::new(disk);
            bus.virtio_devices.push(Box::new(vblk));
            println!("[VM] Loaded disk image");
        } else {
            eprintln!("[VM] Cannot load disk: workers already running");
        }
    }

    /// Connect to a WebTransport relay for networking.
    ///
    /// Must be called before `run()` / `start_workers()`.
    /// The network backend is automatically wrapped in `AsyncNetworkBackend`
    /// for non-blocking I/O and better performance.
    #[cfg(not(target_arch = "wasm32"))]
    pub fn connect_webtransport(&mut self, url: &str, cert_hash: Option<String>) {
        use crate::net_async::AsyncNetworkBackend;
        use crate::net_webtransport::WebTransportBackend;
        use crate::virtio::VirtioNet;

        if let Some(bus) = Arc::get_mut(&mut self.bus) {
            // Create the WebTransport backend
            let backend = WebTransportBackend::new(url, cert_hash);
            // Wrap in async backend for non-blocking I/O
            let async_backend = AsyncNetworkBackend::new(Box::new(backend));
            let vnet = VirtioNet::new(Box::new(async_backend));
            bus.virtio_devices.push(Box::new(vnet));
            println!("[VM] WebTransport network configured (async): {}", url);
        } else {
            eprintln!("[VM] Cannot configure network: workers already running");
        }
    }

    /// Get the number of harts.
    pub fn num_harts(&self) -> usize {
        self.num_harts
    }

    /// Get the kernel entry point.
    pub fn entry_pc(&self) -> u64 {
        self.entry_pc
    }

    /// Get a reference to the shared bus.
    pub fn bus(&self) -> &Arc<SystemBus> {
        &self.bus
    }

    /// Start worker threads for secondary harts.
    ///
    /// This spawns threads for harts 1, 2, ..., N-1.
    /// Hart 0 runs on the main thread (in `run()`).
    pub fn start_workers(&mut self) {
        for hart_id in 1..self.num_harts {
            let bus = Arc::clone(&self.bus);
            let shared = Arc::clone(&self.shared);
            let entry_pc = self.entry_pc;

            let handle = thread::Builder::new()
                .name(format!("hart-{}", hart_id))
                .spawn(move || {
                    hart_thread(hart_id, entry_pc, bus, shared);
                })
                .expect("Failed to spawn hart thread");

            self.handles.push(handle);
            println!("[VM] Started thread for hart {}", hart_id);
        }
    }

    /// Check if workers have been started.
    pub fn workers_started(&self) -> bool {
        !self.handles.is_empty() || self.num_harts == 1
    }

    /// Run the VM until halted.
    ///
    /// This runs hart 0 on the main thread while secondary harts
    /// run on worker threads.
    pub fn run(&mut self) {
        // Start worker threads if not already started
        if !self.workers_started() {
            self.start_workers();
        }

        let mut cpu = self.primary_cpu.take().expect("CPU already taken");
        let mut step_count: u64 = 0;
        let start_time = Instant::now();

        // Initialize console for non-blocking input
        let console = Console::new();
        let mut escaped = false;

        // Performance metrics
        let mut last_report_time = Instant::now();
        let mut last_report_steps: u64 = 0;
        let report_interval = Duration::from_secs(5);

        println!("[VM] Running hart 0 on main thread...");

        // Batch execution parameters
        // Execute instructions in batches to reduce loop overhead
        const BATCH_SIZE: u64 = 256;
        // VirtIO poll interval - with async backend, polling is non-blocking
        // so we can poll more frequently for better network latency
        const VIRTIO_POLL_INTERVAL: u64 = 4096;
        // Console poll interval - console I/O has more overhead
        const CONSOLE_POLL_INTERVAL: u64 = 16384;

        loop {
            // Check halt before batch
            if self.shared.should_stop() {
                break;
            }

            // Execute a batch of instructions
            let (batch_steps, halt_reason) = self.execute_batch(&mut cpu, BATCH_SIZE);
            step_count += batch_steps;

            // Handle halt reason from batch
            if let Some(reason) = halt_reason {
                match reason {
                    HaltReason::Shutdown(code) => {
                        println!("[VM] Shutdown requested (code: {:#x})", code);
                        self.shared.signal_halted(code);
                        break;
                    }
                    HaltReason::Fatal(msg, pc) => {
                        eprintln!("[VM] Fatal error: {} at PC=0x{:x}", msg, pc);
                        self.shared.signal_halted(0xDEAD);
                        break;
                    }
                }
            }

            // Poll VirtIO more frequently (non-blocking with async backend)
            if step_count % VIRTIO_POLL_INTERVAL == 0 {
                self.bus.poll_virtio();
            }

            // Poll console less frequently (has more overhead)
            if step_count % CONSOLE_POLL_INTERVAL == 0 {
                self.pump_console(&console, &mut escaped);

                // Periodic performance report (debug mode)
                if log::log_enabled!(log::Level::Debug) {
                    let now = Instant::now();
                    if now.duration_since(last_report_time) >= report_interval {
                        let delta_steps = step_count - last_report_steps;
                        let delta_time = now.duration_since(last_report_time).as_secs_f64();
                        let current_ips = if delta_time > 0.0 {
                            delta_steps as f64 / delta_time
                        } else {
                            0.0
                        };
                        log::debug!(
                            "[Hart 0] {} steps, {:.2}M IPS (current), PC=0x{:x}",
                            step_count,
                            current_ips / 1_000_000.0,
                            cpu.pc
                        );
                        last_report_time = now;
                        last_report_steps = step_count;
                    }
                }
            }
        }

        // Clean up
        self.shutdown();

        // Report statistics
        let elapsed = start_time.elapsed().as_secs_f64();
        let ips = if elapsed > 0.0 {
            step_count as f64 / elapsed
        } else {
            0.0
        };
        println!(
            "[VM] Hart 0 halted after {} steps ({:.2}M IPS)",
            step_count,
            ips / 1_000_000.0
        );
    }

    /// Execute a batch of instructions.
    ///
    /// Returns the number of steps executed and an optional halt reason.
    /// This reduces per-instruction overhead by checking conditions less frequently.
    fn execute_batch(&self, cpu: &mut Cpu, max_steps: u64) -> (u64, Option<HaltReason>) {
        let mut count = 0u64;

        for _ in 0..max_steps {
            match cpu.step(&*self.bus) {
                Ok(()) => {
                    count += 1;
                }
                Err(Trap::RequestedTrap(code)) => {
                    return (count, Some(HaltReason::Shutdown(code)));
                }
                Err(Trap::Fatal(msg)) => {
                    return (count, Some(HaltReason::Fatal(msg, cpu.pc)));
                }
                Err(_trap) => {
                    // Architectural traps handled by CPU
                    count += 1;
                }
            }
        }

        (count, None)
    }

    /// Pump console I/O.
    /// 
    /// Handles UART output to stdout and console input to UART.
    /// Supports Ctrl-A escape sequences:
    /// - Ctrl-A x: terminate VM
    /// - Ctrl-A Ctrl-A: send literal Ctrl-A
    fn pump_console(&self, console: &Console, escaped: &mut bool) {
        // Output to stdout - drain all at once to reduce lock contention
        let output = self.bus.uart.drain_output();
        if !output.is_empty() {
            for byte in output {
                // In raw terminal mode, \n alone doesn't return cursor to column 0.
                // We need to emit \r\n for proper line breaks.
                if byte == b'\n' {
                    print!("\r\n");
                } else {
                    print!("{}", byte as char);
                }
            }
            io::stdout().flush().ok();
        }

        // Input from console (non-blocking)
        for byte in console.read_available() {
            if *escaped {
                if byte == b'x' {
                    // Ctrl-A x: terminate
                    println!("\r\n[VM] Terminated by user (Ctrl-A x)");
                    self.shared.request_halt();
                    return;
                } else if byte == 1 {
                    // Ctrl-A Ctrl-A: send literal Ctrl-A
                    self.bus.uart.push_input(1);
                } else {
                    // Ctrl-A then something else: send that something
                    self.bus.uart.push_input(byte);
                }
                *escaped = false;
            } else {
                if byte == 1 {
                    // Ctrl-A: start escape sequence
                    *escaped = true;
                } else {
                    self.bus.uart.push_input(byte);
                }
            }
        }
    }

    /// Request shutdown and wait for workers.
    fn shutdown(&mut self) {
        println!("[VM] Shutting down...");

        // Signal halt to all workers
        self.shared.request_halt();

        // Wait for all workers to exit
        for handle in self.handles.drain(..) {
            if let Err(e) = handle.join() {
                eprintln!("[VM] Worker thread panicked: {:?}", e);
            }
        }

        println!("[VM] All threads stopped");
    }
}

#[cfg(not(target_arch = "wasm32"))]
impl Drop for NativeVm {
    fn drop(&mut self) {
        // Ensure threads are cleaned up
        self.shared.request_halt();
        for handle in self.handles.drain(..) {
            handle.join().ok();
        }
    }
}

/// Load ELF kernel into DRAM (for NativeVm).
///
/// Takes a shared reference to the bus since SystemBus uses interior
/// mutability for DRAM access.
#[cfg(not(target_arch = "wasm32"))]
fn load_elf_native(buffer: &[u8], bus: &SystemBus) -> Result<u64, String> {
    let elf = Elf::parse(buffer).map_err(|e| format!("ELF parse error: {}", e))?;
    let base = bus.dram.base;
    let dram_size = bus.dram.size();
    let dram_end = base + dram_size as u64;

    for ph in &elf.program_headers {
        if ph.p_type != PT_LOAD || ph.p_memsz == 0 {
            continue;
        }

        let file_size = ph.p_filesz as usize;
        let mem_size = ph.p_memsz as usize;
        let file_offset = ph.p_offset as usize;

        if file_offset + file_size > buffer.len() {
            return Err("Segment exceeds file bounds".to_string());
        }

        let target_addr = if ph.p_paddr != 0 {
            ph.p_paddr
        } else {
            ph.p_vaddr
        };

        if target_addr < base || target_addr + mem_size as u64 > dram_end {
            return Err(format!("Segment 0x{:x} out of DRAM range", target_addr));
        }

        let dram_offset = target_addr - base;

        if file_size > 0 {
            bus.dram
                .load(&buffer[file_offset..file_offset + file_size], dram_offset)
                .map_err(|e| format!("Failed to load segment: {:?}", e))?;
        }

        if mem_size > file_size {
            bus.dram
                .zero_range((dram_offset as usize) + file_size, mem_size - file_size)
                .map_err(|e| format!("Failed to zero BSS: {:?}", e))?;
        }
    }

    Ok(elf.entry)
}

/// Hart thread entry point.
///
/// This function runs on a dedicated thread for each secondary hart.
/// It executes CPU instructions until halted.
#[cfg(not(target_arch = "wasm32"))]
fn hart_thread(hart_id: usize, entry_pc: u64, bus: Arc<SystemBus>, shared: Arc<SharedState>) {
    let mut cpu = Cpu::new(entry_pc, hart_id as u64);
    let mut step_count: u64 = 0;
    let start_time = Instant::now();

    // Performance metrics
    let mut last_report_time = Instant::now();
    let mut last_report_steps: u64 = 0;
    let report_interval = Duration::from_secs(5);

    println!("[Hart {}] Started at PC=0x{:x}", hart_id, entry_pc);

    // Batch execution parameters
    const BATCH_SIZE: u64 = 256;
    // Yield interval - allow other threads to run
    // Higher value = better throughput but potentially less fair scheduling
    const YIELD_INTERVAL: u64 = 4_000_000;

    loop {
        // Check halt before batch
        if shared.should_stop() {
            break;
        }

        // Execute a batch of instructions
        let (batch_steps, halt_reason) = execute_batch_worker(&mut cpu, &bus, BATCH_SIZE);
        step_count += batch_steps;

        // Handle halt reason from batch
        if let Some(reason) = halt_reason {
            match reason {
                HaltReason::Shutdown(code) => {
                    println!(
                        "[Hart {}] Shutdown requested (code: {:#x})",
                        hart_id, code
                    );
                    shared.signal_halted(code);
                    break;
                }
                HaltReason::Fatal(msg, pc) => {
                    eprintln!("[Hart {}] Fatal: {} at PC=0x{:x}", hart_id, msg, pc);
                    shared.signal_halted(0xDEAD);
                    break;
                }
            }
        }

        // Yield occasionally to prevent CPU hogging and reduce contention
        if step_count % YIELD_INTERVAL == 0 {
            thread::yield_now();

            // Periodic performance report (debug mode)
            if log::log_enabled!(log::Level::Debug) {
                let now = Instant::now();
                if now.duration_since(last_report_time) >= report_interval {
                    let delta_steps = step_count - last_report_steps;
                    let delta_time = now.duration_since(last_report_time).as_secs_f64();
                    let current_ips = if delta_time > 0.0 {
                        delta_steps as f64 / delta_time
                    } else {
                        0.0
                    };
                    log::debug!(
                        "[Hart {}] {} steps, {:.2}M IPS (current), PC=0x{:x}",
                        hart_id,
                        step_count,
                        current_ips / 1_000_000.0,
                        cpu.pc
                    );
                    last_report_time = now;
                    last_report_steps = step_count;
                }
            }
        }
    }

    // Report statistics
    let elapsed = start_time.elapsed().as_secs_f64();
    let ips = if elapsed > 0.0 {
        step_count as f64 / elapsed
    } else {
        0.0
    };
    println!(
        "[Hart {}] Exited after {} steps ({:.2}M IPS)",
        hart_id,
        step_count,
        ips / 1_000_000.0
    );
}

/// Execute a batch of instructions for worker threads.
///
/// Similar to NativeVm::execute_batch but takes bus reference directly.
#[cfg(not(target_arch = "wasm32"))]
fn execute_batch_worker(cpu: &mut Cpu, bus: &SystemBus, max_steps: u64) -> (u64, Option<HaltReason>) {
    let mut count = 0u64;

    for _ in 0..max_steps {
        match cpu.step(bus) {
            Ok(()) => {
                count += 1;
            }
            Err(Trap::RequestedTrap(code)) => {
                return (count, Some(HaltReason::Shutdown(code)));
            }
            Err(Trap::Fatal(msg)) => {
                return (count, Some(HaltReason::Fatal(msg, cpu.pc)));
            }
            Err(_trap) => {
                // Architectural traps handled by CPU
                count += 1;
            }
        }
    }

    (count, None)
}
</file>

<file path="riscv-vm/src/net.rs">
//! Network backend abstraction for VirtIO networking.
//!
//! This module defines the `NetworkBackend` trait that abstracts packet I/O
//! to support both Host (TAP) and WASM (WebSocket) environments.

use std::time::Duration;

/// Trait for network backends that provide packet I/O.
/// 
/// Implementations must be `Send` to allow the backend to be used
/// across thread boundaries (e.g., when the VM runs in a separate thread).
pub trait NetworkBackend: Send {
    /// Initialize the backend (e.g., open TAP device or connect WebSocket).
    fn init(&mut self) -> Result<(), String>;
    
    /// Poll for an incoming packet. Returns None if no packet is available.
    /// This should be non-blocking.
    fn recv(&mut self) -> Result<Option<Vec<u8>>, String>;
    
    /// Send a packet.
    fn send(&self, buf: &[u8]) -> Result<(), String>;
    
    /// Get the MAC address of the backend (if available).
    /// Returns a default MAC if the backend doesn't have one.
    fn mac_address(&self) -> [u8; 6] {
        // Default MAC: locally administered, unicast
        [0x52, 0x54, 0x00, 0x12, 0x34, 0x56]
    }
    
    /// Check if an IP has been assigned by the network controller (e.g., relay server).
    /// Returns None if no IP has been assigned yet.
    fn get_assigned_ip(&self) -> Option<[u8; 4]> {
        None
    }

    /// Receive with timeout (for async wrapper).
    ///
    /// Waits up to `timeout` for an incoming packet. Returns `Ok(Some(packet))`
    /// if a packet is received, `Ok(None)` if the timeout expires, or an error.
    ///
    /// Default implementation ignores the timeout and just calls `recv()`.
    /// Backends that support blocking with timeout should override this.
    fn receive_timeout(&mut self, _timeout: Duration) -> Result<Option<Vec<u8>>, String> {
        self.recv()
    }
}

/// A no-op network backend for testing purposes.
/// 
/// This backend discards all sent packets and never receives any packets.
pub struct DummyBackend {
    initialized: bool,
    mac: [u8; 6],
}

impl DummyBackend {
    pub fn new() -> Self {
        Self {
            initialized: false,
            mac: [0x52, 0x54, 0x00, 0x12, 0x34, 0x56],
        }
    }
    
    /// Create a dummy backend with a custom MAC address.
    pub fn with_mac(mac: [u8; 6]) -> Self {
        Self {
            initialized: false,
            mac,
        }
    }
}

impl Default for DummyBackend {
    fn default() -> Self {
        Self::new()
    }
}

impl NetworkBackend for DummyBackend {
    fn init(&mut self) -> Result<(), String> {
        self.initialized = true;
        log::debug!("[DummyBackend] Initialized (no-op)");
        Ok(())
    }
    
    fn recv(&mut self) -> Result<Option<Vec<u8>>, String> {
        // No packets ever available
        Ok(None)
    }
    
    fn send(&self, buf: &[u8]) -> Result<(), String> {
        // Discard packet, but log it for debugging
        log::trace!("[DummyBackend] Discarding {} byte packet", buf.len());
        Ok(())
    }
    
    fn mac_address(&self) -> [u8; 6] {
        self.mac
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    
    #[test]
    fn test_dummy_backend_init() {
        let mut backend = DummyBackend::new();
        assert!(backend.init().is_ok());
    }
    
    #[test]
    fn test_dummy_backend_recv_returns_none() {
        let mut backend = DummyBackend::new();
        backend.init().unwrap();
        assert!(backend.recv().unwrap().is_none());
    }
    
    #[test]
    fn test_dummy_backend_send_succeeds() {
        let backend = DummyBackend::new();
        assert!(backend.send(&[1, 2, 3, 4]).is_ok());
    }
    
    #[test]
    fn test_dummy_backend_mac_address() {
        let backend = DummyBackend::new();
        let mac = backend.mac_address();
        // Check locally administered bit is set (second bit of first byte)
        assert_eq!(mac[0] & 0x02, 0x02);
    }
    
    #[test]
    fn test_dummy_backend_custom_mac() {
        let custom_mac = [0xAA, 0xBB, 0xCC, 0xDD, 0xEE, 0xFF];
        let backend = DummyBackend::with_mac(custom_mac);
        assert_eq!(backend.mac_address(), custom_mac);
    }
}
</file>

<file path="riscv-vm/src/plic.rs">
use crate::clint::MAX_HARTS;
use crate::dram::MemoryError;
use std::sync::atomic::{AtomicU32, Ordering};
use std::sync::Mutex;

pub const PLIC_BASE: u64 = 0x0C00_0000;
pub const PLIC_SIZE: u64 = 0x400_0000;

pub const UART_IRQ: u32 = 10;
pub const VIRTIO0_IRQ: u32 = 1;

const NUM_SOURCES: usize = 32;
/// Number of interrupt contexts.
/// Each hart has 2 contexts: M-mode (2*N) and S-mode (2*N+1).
const NUM_CONTEXTS: usize = 2 * MAX_HARTS;  // 2 contexts per hart (M-mode and S-mode)

/// Internal mutable state for PLIC, protected by Mutex
struct PlicState {
    priority: [u32; NUM_SOURCES],
    pending: u32, // Level-triggered mirror of device IRQ lines (bit per source)
    enable: [u32; NUM_CONTEXTS],
    threshold: [u32; NUM_CONTEXTS],
    active: [u32; NUM_CONTEXTS], // Per-context in-flight IRQs (claimed but not completed)
    debug: bool,
}

pub struct Plic {
    /// Authoritative state protected by Mutex
    state: Mutex<PlicState>,
    
    // ============================================================
    // Atomic Caches - Updated on writes, used for fast polling
    // ============================================================
    
    /// Cache of pending interrupt bits (mirrors state.pending)
    pending_cache: AtomicU32,
    
    /// Cache of enable bits per context (mirrors state.enable)
    enable_cache: [AtomicU32; NUM_CONTEXTS],
    
    /// Cache of threshold per context (mirrors state.threshold)
    threshold_cache: [AtomicU32; NUM_CONTEXTS],
    
    /// Cache of priority per source (mirrors state.priority)
    /// Note: Only need cache for sources 0-31
    priority_cache: [AtomicU32; NUM_SOURCES],
}

impl Plic {
    /// Get the M-mode context ID for a given hart.
    #[inline]
    pub fn m_context(hart_id: usize) -> usize {
        hart_id * 2
    }
    
    /// Get the S-mode context ID for a given hart.
    #[inline]
    pub fn s_context(hart_id: usize) -> usize {
        hart_id * 2 + 1
    }

    pub fn new() -> Self {
        // Create atomic arrays using const initialization
        const ZERO: AtomicU32 = AtomicU32::new(0);
        
        Self {
            state: Mutex::new(PlicState {
                priority: [0; NUM_SOURCES],
                pending: 0,
                enable: [0; NUM_CONTEXTS],
                threshold: [0; NUM_CONTEXTS],
                active: [0; NUM_CONTEXTS],
                debug: false,
            }),
            
            // Initialize caches to match initial state
            pending_cache: AtomicU32::new(0),
            enable_cache: [ZERO; NUM_CONTEXTS],
            threshold_cache: [ZERO; NUM_CONTEXTS],
            priority_cache: [ZERO; NUM_SOURCES],
        }
    }

    // ============================================================
    // Cache Sync Methods
    // ============================================================

    /// Sync all caches from authoritative state.
    /// 
    /// This should be called while holding the PlicState lock.
    /// Takes a reference to the state to avoid double-locking.
    fn sync_caches_from(&self, state: &PlicState) {
        // Sync pending
        self.pending_cache.store(state.pending, Ordering::Release);
        
        // Sync enable for all contexts
        for (i, &val) in state.enable.iter().enumerate() {
            self.enable_cache[i].store(val, Ordering::Release);
        }
        
        // Sync threshold for all contexts
        for (i, &val) in state.threshold.iter().enumerate() {
            self.threshold_cache[i].store(val, Ordering::Release);
        }
        
        // Sync priority for all sources
        for (i, &val) in state.priority.iter().enumerate() {
            self.priority_cache[i].store(val, Ordering::Release);
        }
    }

    /// Sync only the pending cache.
    #[inline]
    fn sync_pending_cache(&self, state: &PlicState) {
        self.pending_cache.store(state.pending, Ordering::Release);
    }
    
    /// Sync only the enable cache for a specific context.
    #[inline]
    fn sync_enable_cache(&self, state: &PlicState, ctx: usize) {
        if ctx < NUM_CONTEXTS {
            self.enable_cache[ctx].store(state.enable[ctx], Ordering::Release);
        }
    }
    
    /// Sync only the threshold cache for a specific context.
    #[inline]
    fn sync_threshold_cache(&self, state: &PlicState, ctx: usize) {
        if ctx < NUM_CONTEXTS {
            self.threshold_cache[ctx].store(state.threshold[ctx], Ordering::Release);
        }
    }
    
    /// Sync only the priority cache for a specific source.
    #[inline]
    fn sync_priority_cache(&self, state: &PlicState, source: usize) {
        if source < NUM_SOURCES {
            self.priority_cache[source].store(state.priority[source], Ordering::Release);
        }
    }

    /// Force sync all caches from Mutex state.
    /// 
    /// This acquires the lock and syncs all caches.
    /// Mainly useful for testing and initialization.
    pub fn sync_caches(&self) {
        let state = self.state.lock().unwrap();
        self.sync_caches_from(&state);
    }

    // ============================================================
    // Cache Accessor Methods (lock-free)
    // ============================================================

    /// Get pending bits from cache (lock-free)
    #[inline]
    pub fn pending_cached(&self) -> u32 {
        self.pending_cache.load(Ordering::Relaxed)
    }
    
    /// Get enable bits for a context from cache (lock-free)
    #[inline]
    pub fn enable_cached(&self, ctx: usize) -> u32 {
        if ctx < NUM_CONTEXTS {
            self.enable_cache[ctx].load(Ordering::Relaxed)
        } else {
            0
        }
    }
    
    /// Get threshold for a context from cache (lock-free)
    #[inline]
    pub fn threshold_cached(&self, ctx: usize) -> u32 {
        if ctx < NUM_CONTEXTS {
            self.threshold_cache[ctx].load(Ordering::Relaxed)
        } else {
            0
        }
    }
    
    /// Get priority for a source from cache (lock-free)
    #[inline]
    pub fn priority_cached(&self, source: usize) -> u32 {
        if source < NUM_SOURCES {
            self.priority_cache[source].load(Ordering::Relaxed)
        } else {
            0
        }
    }

    // ============================================================
    // Fast Interrupt Check (lock-free)
    // ============================================================

    /// Fast lock-free check for pending interrupts.
    /// 
    /// This uses atomic caches and is suitable for polling.
    /// Returns true if ANY interrupt might be pending; the caller should
    /// use claim_interrupt_for() to get the actual interrupt ID.
    /// 
    /// Note: May return false positives (cache slightly stale) but not false negatives
    /// when used correctly (caches synced on writes).
    #[inline]
    pub fn is_interrupt_pending_for_fast(&self, ctx: usize) -> bool {
        if ctx >= NUM_CONTEXTS {
            return false;
        }
        
        // Load cached values (lock-free)
        let pending = self.pending_cache.load(Ordering::Relaxed);
        let enable = self.enable_cache[ctx].load(Ordering::Relaxed);
        let threshold = self.threshold_cache[ctx].load(Ordering::Relaxed);
        
        // Quick check: any enabled source pending?
        let candidates = pending & enable;
        if candidates == 0 {
            return false;
        }
        
        // Check if any candidate has priority > threshold
        // This is a bit more expensive but still lock-free
        for source in 1..NUM_SOURCES {
            if (candidates & (1 << source)) != 0 {
                let priority = self.priority_cache[source].load(Ordering::Relaxed);
                if priority > threshold {
                    return true;
                }
            }
        }
        
        false
    }

    /// Ultra-fast pending check - only checks pending & enable.
    /// 
    /// This may return true when priority <= threshold, but is faster.
    /// Use when you want to minimize polling overhead and can tolerate
    /// occasional unnecessary claim attempts.
    #[inline]
    pub fn has_pending_candidate(&self, ctx: usize) -> bool {
        if ctx >= NUM_CONTEXTS {
            return false;
        }
        let pending = self.pending_cache.load(Ordering::Relaxed);
        let enable = self.enable_cache[ctx].load(Ordering::Relaxed);
        (pending & enable) != 0
    }

    // ============================================================
    // Source Level Control
    // ============================================================

    pub fn update_pending(&self, source: u32) {
        let mut state = self.state.lock().unwrap();
        // Backward compatibility helper: set as pending (edge → level).
        // Bus.refresh_irqs() may later clear this if device line is low.
        if source < 32 {
            if state.debug {
                 eprintln!("[PLIC] Update Pending source={}", source);
            }
            state.pending |= 1 << source;
            // Sync pending cache
            self.sync_pending_cache(&state);
        }
    }

    // New: level-triggered source line setter
    pub fn set_source_level(&self, source: u32, level: bool) {
        let mut state = self.state.lock().unwrap();
        if source >= 32 {
            return;
        }
        let was_pending = (state.pending & (1 << source)) != 0;
        if level {
            if state.debug && !was_pending {
                 eprintln!("[PLIC] IRQ Line High: source={} enable[0]=0x{:x} enable[1]=0x{:x} prio={}", 
                          source, state.enable[0], state.enable[1], state.priority[source as usize]);
            }
            state.pending |= 1 << source;
        } else {
            state.pending &= !(1 << source);
        }
        // Sync pending cache
        self.sync_pending_cache(&state);
    }

    // ============================================================
    // Snapshot support methods
    // ============================================================

    /// Get priority array for snapshot
    pub fn get_priority(&self) -> Vec<u32> {
        let state = self.state.lock().unwrap();
        state.priority.to_vec()
    }

    /// Get pending bits for snapshot
    pub fn get_pending(&self) -> u32 {
        let state = self.state.lock().unwrap();
        state.pending
    }

    /// Get enable array for snapshot
    pub fn get_enable(&self) -> Vec<u32> {
        let state = self.state.lock().unwrap();
        state.enable.to_vec()
    }

    /// Get threshold array for snapshot
    pub fn get_threshold(&self) -> Vec<u32> {
        let state = self.state.lock().unwrap();
        state.threshold.to_vec()
    }

    /// Get active array for snapshot
    pub fn get_active(&self) -> Vec<u32> {
        let state = self.state.lock().unwrap();
        state.active.to_vec()
    }

    /// Restore priority from snapshot
    pub fn set_priority(&self, values: &[u32]) {
        let mut state = self.state.lock().unwrap();
        for (i, &val) in values.iter().enumerate() {
            if i < state.priority.len() {
                state.priority[i] = val;
            }
        }
        // Sync all priority caches
        for i in 0..NUM_SOURCES.min(values.len()) {
            self.priority_cache[i].store(state.priority[i], Ordering::Release);
        }
    }

    /// Restore pending bits from snapshot  
    pub fn set_pending(&self, value: u32) {
        let mut state = self.state.lock().unwrap();
        state.pending = value;
        self.sync_pending_cache(&state);
    }

    /// Restore enable from snapshot
    pub fn set_enable(&self, values: &[u32]) {
        let mut state = self.state.lock().unwrap();
        for (i, &val) in values.iter().enumerate() {
            if i < state.enable.len() {
                state.enable[i] = val;
            }
        }
        // Sync all enable caches
        for i in 0..NUM_CONTEXTS.min(values.len()) {
            self.enable_cache[i].store(state.enable[i], Ordering::Release);
        }
    }

    /// Restore threshold from snapshot
    pub fn set_threshold(&self, values: &[u32]) {
        let mut state = self.state.lock().unwrap();
        for (i, &val) in values.iter().enumerate() {
            if i < state.threshold.len() {
                state.threshold[i] = val;
            }
        }
        // Sync all threshold caches
        for i in 0..NUM_CONTEXTS.min(values.len()) {
            self.threshold_cache[i].store(state.threshold[i], Ordering::Release);
        }
    }

    /// Restore active from snapshot
    pub fn set_active(&self, values: &[u32]) {
        let mut state = self.state.lock().unwrap();
        for (i, &val) in values.iter().enumerate() {
            if i < state.active.len() {
                state.active[i] = val;
            }
        }
        // Note: active is not cached, so no sync needed
    }

    // ============================================================
    // MMIO Load/Store
    // ============================================================

    pub fn load(&self, offset: u64, size: u64) -> Result<u64, MemoryError> {
        let mut state = self.state.lock().unwrap();
        if size != 4 {
            return Ok(0); 
        }

        // Priority registers: 0x000000 .. 0x0000FC (4 bytes each)
        if offset < 0x001000 {
            let idx = (offset >> 2) as usize;
            if idx < NUM_SOURCES {
                return Ok(state.priority[idx] as u64);
            }
        }
        // Pending bits: 0x001000
        if offset == 0x001000 {
            return Ok(state.pending as u64);
        }
        // Enable per context: 0x002000 + 0x80 * context
        if offset >= 0x002000 && offset < 0x002000 + 0x80 * (NUM_CONTEXTS as u64) {
            let ctx = ((offset - 0x002000) / 0x80) as usize;
            let inner = (offset - 0x002000) % 0x80;
            if ctx < NUM_CONTEXTS && inner == 0 {
                return Ok(state.enable[ctx] as u64);
            }
        }
        // Context registers: threshold @ 0x200000 + 0x1000 * ctx, claim @ +4
        if offset >= 0x200000 {
            let ctx = ((offset - 0x200000) / 0x1000) as usize;
            if ctx < NUM_CONTEXTS {
                let base = 0x200000 + (0x1000 * ctx as u64);
                if offset == base {
                    return Ok(state.threshold[ctx] as u64);
                }
                if offset == base + 4 {
                    let claim = Self::claim_interrupt_for_internal(&mut state, ctx);
                    if Self::debug_trace() {
                        eprintln!("[PLIC] SCLAIM ctx={} -> {}", ctx, claim);
                    }
                    return Ok(claim as u64);
                }
            }
        }

        Ok(0)
    }

    fn debug_trace() -> bool {
        // Helper to check if trace logging is enabled without importing log everywhere if not needed
        // or just use std::env
        std::env::var("RUST_LOG").map(|s| s.contains("trace")).unwrap_or(false)
    }

    pub fn store(&self, offset: u64, size: u64, value: u64) -> Result<(), MemoryError> {
        let mut state = self.state.lock().unwrap();
        if size != 4 {
            return Ok(());
        }
        let val = value as u32;

        // ============================================================
        // Priority registers: 0x000000 .. 0x0000FC (4 bytes each)
        // ============================================================
        if offset < 0x001000 {
            let idx = (offset >> 2) as usize;
            if idx < NUM_SOURCES {
                state.priority[idx] = val;
                // Sync priority cache for this source
                self.sync_priority_cache(&state, idx);
            }
            return Ok(());
        }

        // ============================================================
        // Pending bits: 0x001000 (read-only to software)
        // ============================================================
        if offset == 0x001000 {
            // Pending is read-only - ignore writes
            return Ok(());
        }

        // ============================================================
        // Enable per context: 0x002000 + 0x80 * context
        // ============================================================
        if offset >= 0x002000 && offset < 0x002000 + 0x80 * (NUM_CONTEXTS as u64) {
            let ctx = ((offset - 0x002000) / 0x80) as usize;
            let inner = (offset - 0x002000) % 0x80;
            if ctx < NUM_CONTEXTS && inner == 0 {
                state.enable[ctx] = val;
                // Sync enable cache for this context
                self.sync_enable_cache(&state, ctx);
            }
            return Ok(());
        }

        // ============================================================
        // Context registers: threshold @ 0x200000 + 0x1000 * ctx
        //                    claim/complete @ 0x200000 + 0x1000 * ctx + 4
        // ============================================================
        if offset >= 0x200000 {
            let ctx = ((offset - 0x200000) / 0x1000) as usize;
            if ctx < NUM_CONTEXTS {
                let base = 0x200000 + (0x1000 * ctx as u64);
                
                if offset == base {
                    // Threshold write
                    state.threshold[ctx] = val;
                    // Sync threshold cache for this context
                    self.sync_threshold_cache(&state, ctx);
                    return Ok(());
                }
                
                if offset == base + 4 {
                    // Completion write: value is the source ID to complete
                    let id = (val & 0xffff) as u32;
                    if id > 0 && (id as usize) < NUM_SOURCES {
                        state.active[ctx] &= !(1 << id);
                        // No cache sync needed - active is not cached
                    }
                    return Ok(());
                }
            }
            return Ok(());
        }

        Ok(())
    }

    fn eligible_for_context(state: &PlicState, source: usize, ctx: usize) -> bool {
        let pending = ((state.pending >> source) & 1) == 1;
        let enabled = ((state.enable[ctx] >> source) & 1) == 1;
        let over_threshold = state.priority[source] > state.threshold[ctx];
        let not_active = ((state.active[ctx] >> source) & 1) == 0;
        pending && enabled && over_threshold && not_active
    }

    fn claim_interrupt_for_internal(state: &mut PlicState, ctx: usize) -> u32 {
        let mut max_prio = 0;
        let mut max_id = 0;

        for i in 1..NUM_SOURCES {
            if Self::eligible_for_context(state, i, ctx) {
                let prio = state.priority[i];
                if prio > max_prio {
                    max_prio = prio;
                    max_id = i as u32;
                }
            }
        }

        if max_id != 0 {
            // eprintln!("[PLIC] Claimed IRQ {} for context {} (prio {})", max_id, ctx, max_prio);
            // Mark in-flight for this context until completed.
            state.active[ctx] |= 1 << max_id;
        }
        max_id
    }

    pub fn claim_interrupt_for(&self, ctx: usize) -> u32 {
        let mut state = self.state.lock().unwrap();
        Self::claim_interrupt_for_internal(&mut state, ctx)
    }
    
    pub fn is_interrupt_pending(&self) -> bool {
        // For current single-hart flow, report S-mode context (1) if available, else context 0.
        let ctx = if NUM_CONTEXTS > 1 { 1 } else { 0 };
        self.is_interrupt_pending_for(ctx)
    }

    /// Accurate check using Mutex (for claim/complete path).
    /// 
    /// Use this when you need guaranteed correctness, such as
    /// before attempting a claim operation.
    pub fn is_interrupt_pending_for(&self, ctx: usize) -> bool {
        let state = self.state.lock().unwrap();
        if ctx >= NUM_CONTEXTS {
            return false;
        }
        for i in 1..NUM_SOURCES {
            if Self::eligible_for_context(&state, i, ctx) {
                if state.debug {
                    eprintln!("[PLIC] Interrupt pending for ctx={} source={}", ctx, i);
                }
                return true;
            }
        }
        // Debug: show why no interrupt
        if state.debug && state.pending != 0 {
            for i in 1..NUM_SOURCES {
                let pending = ((state.pending >> i) & 1) == 1;
                let enabled = ((state.enable[ctx] >> i) & 1) == 1;
                let over_threshold = state.priority[i] > state.threshold[ctx];
                let not_active = ((state.active[ctx] >> i) & 1) == 0;
                if pending {
                    eprintln!("[PLIC] Source {} pending but not eligible for ctx={}: enabled={} over_threshold={} (prio={} > thresh={}) not_active={}", 
                             i, ctx, enabled, over_threshold, state.priority[i], state.threshold[ctx], not_active);
                }
            }
        }
        false
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_context_helpers() {
        assert_eq!(Plic::m_context(0), 0);
        assert_eq!(Plic::s_context(0), 1);
        assert_eq!(Plic::m_context(1), 2);
        assert_eq!(Plic::s_context(1), 3);
        assert_eq!(Plic::m_context(3), 6);
        assert_eq!(Plic::s_context(3), 7);
    }

    #[test]
    fn test_plic_multi_context() {
        let plic = Plic::new();
        
        // Enable source 1 for hart 1 S-mode (context 3)
        {
            let mut state = plic.state.lock().unwrap();
            state.enable[Plic::s_context(1)] = 1 << 1;
            state.priority[1] = 1;
            state.threshold[Plic::s_context(1)] = 0;
        }
        // Sync caches after manual state modification
        plic.sync_caches();
        
        plic.set_source_level(1, true);
        
        // Should be pending for hart 1 S-mode, not hart 0
        assert!(!plic.is_interrupt_pending_for(Plic::s_context(0)));
        assert!(plic.is_interrupt_pending_for(Plic::s_context(1)));
    }

    #[test]
    fn test_plic_claim_complete_context1() {
        let plic = Plic::new();
        // Priorities
        {
            let mut state = plic.state.lock().unwrap();
            state.priority[1] = 5;
            state.priority[10] = 3;
        }
        // Enable sources 1 and 10 for context 1 (S-mode)
        let enable_val = (1u32 << 1) | (1u32 << 10);
        let _ = plic.store(0x002000 + 0x80 * 1, 4, enable_val as u64);
        // Threshold 0 for context 1
        let _ = plic.store(0x200000 + 0x1000 * 1, 4, 0);
        // Sync priority caches (we modified them directly above)
        plic.sync_caches();
        // Assert device lines
        plic.set_source_level(1, true);
        plic.set_source_level(10, true);

        // Claim highest priority first (source 1)
        let id1 = plic.claim_interrupt_for(1);
        assert_eq!(id1, 1);
        // Next claim should return source 10 (since 1 is active)
        let id2 = plic.claim_interrupt_for(1);
        assert_eq!(id2, 10);
        // Complete source 1
        let _ = plic.store(0x200004 + 0x1000 * 1, 4, 1);
        // Claim again should allow source 1
        let id3 = plic.claim_interrupt_for(1);
        assert_eq!(id3, 1);
    }

    #[test]
    fn test_plic_cache_accessors() {
        let plic = Plic::new();
        
        // Initial state: all zeros
        assert_eq!(plic.pending_cached(), 0);
        assert_eq!(plic.enable_cached(0), 0);
        assert_eq!(plic.threshold_cached(0), 0);
        assert_eq!(plic.priority_cached(0), 0);
        
        // Out of bounds returns 0
        assert_eq!(plic.enable_cached(NUM_CONTEXTS + 100), 0);
        assert_eq!(plic.priority_cached(NUM_SOURCES + 100), 0);
    }

    #[test]
    fn test_plic_cache_sync() {
        let plic = Plic::new();
        
        // Manually modify state through store()
        plic.store(0x000000 + 4 * 10, 4, 5).unwrap();  // priority[10] = 5
        plic.store(0x002000, 4, 1 << 10).unwrap();     // enable[0] = bit 10
        plic.store(0x200000, 4, 2).unwrap();           // threshold[0] = 2
        
        // Set pending via set_source_level
        plic.set_source_level(10, true);
        
        // Caches should be synced by store() and set_source_level()
        assert_eq!(plic.priority_cached(10), 5);
        assert_eq!(plic.enable_cached(0), 1 << 10);
        assert_eq!(plic.threshold_cached(0), 2);
        assert!((plic.pending_cached() & (1 << 10)) != 0);
    }

    #[test]
    fn test_store_syncs_priority_cache() {
        let plic = Plic::new();
        
        // Write priority for source 5 via MMIO
        plic.store(0x000000 + 4 * 5, 4, 7).unwrap();
        
        // Cache should be updated
        assert_eq!(plic.priority_cached(5), 7);
        
        // Authoritative state should match
        assert_eq!(plic.get_priority()[5], 7);
    }

    #[test]
    fn test_store_syncs_enable_cache() {
        let plic = Plic::new();
        
        // Write enable for context 1 (S-mode for hart 0) via MMIO
        plic.store(0x002000 + 0x80 * 1, 4, 0x1234).unwrap();
        
        // Cache should be updated
        assert_eq!(plic.enable_cached(1), 0x1234);
    }

    #[test]
    fn test_store_syncs_threshold_cache() {
        let plic = Plic::new();
        
        // Write threshold for context 0 via MMIO
        plic.store(0x200000, 4, 3).unwrap();
        
        // Cache should be updated
        assert_eq!(plic.threshold_cached(0), 3);
    }

    #[test]
    fn test_set_source_level_syncs_cache() {
        let plic = Plic::new();
        
        assert_eq!(plic.pending_cached(), 0);
        
        plic.set_source_level(5, true);
        assert!((plic.pending_cached() & (1 << 5)) != 0);
        
        plic.set_source_level(5, false);
        assert!((plic.pending_cached() & (1 << 5)) == 0);
    }

    #[test]
    fn test_fast_pending_check() {
        let plic = Plic::new();
        
        // Setup: source 10, priority 5, enable for ctx 1, threshold 0
        plic.store(0x000000 + 4 * 10, 4, 5).unwrap();  // priority[10] = 5
        plic.store(0x002000 + 0x80 * 1, 4, 1 << 10).unwrap();  // enable[1] = bit 10
        plic.store(0x200000 + 0x1000 * 1, 4, 0).unwrap();  // threshold[1] = 0
        
        // No interrupt yet (not pending)
        assert!(!plic.is_interrupt_pending_for_fast(1));
        
        // Set source 10 as pending
        plic.set_source_level(10, true);
        
        // Now should detect interrupt
        assert!(plic.is_interrupt_pending_for_fast(1));
        
        // But not for context 0 (not enabled there)
        assert!(!plic.is_interrupt_pending_for_fast(0));
    }

    #[test]
    fn test_fast_check_respects_threshold() {
        let plic = Plic::new();
        
        // Setup: source 5, priority 3
        plic.store(0x000000 + 4 * 5, 4, 3).unwrap();
        plic.store(0x002000, 4, 1 << 5).unwrap();  // enable for ctx 0
        plic.set_source_level(5, true);
        
        // Threshold 0: should see interrupt
        plic.store(0x200000, 4, 0).unwrap();
        assert!(plic.is_interrupt_pending_for_fast(0));
        
        // Threshold 3: priority not > threshold, no interrupt
        plic.store(0x200000, 4, 3).unwrap();
        assert!(!plic.is_interrupt_pending_for_fast(0));
        
        // Threshold 2: priority > threshold, should see interrupt
        plic.store(0x200000, 4, 2).unwrap();
        assert!(plic.is_interrupt_pending_for_fast(0));
    }

    #[test]
    fn test_has_pending_candidate() {
        let plic = Plic::new();
        
        // Setup: source 3 enabled for ctx 0, but not pending
        plic.store(0x002000, 4, 1 << 3).unwrap();
        assert!(!plic.has_pending_candidate(0));
        
        // Set source 3 as pending
        plic.set_source_level(3, true);
        assert!(plic.has_pending_candidate(0));
        
        // Clear pending
        plic.set_source_level(3, false);
        assert!(!plic.has_pending_candidate(0));
    }
}
</file>

<file path="riscv-vm/src/shared_mem.rs">
//! Shared Memory Layout for WASM SMP
//!
//! This module defines the memory layout for SharedArrayBuffer-based
//! multi-hart execution in WASM environments.
//!
//! ## Memory Layout
//!
//! ```text
//! ┌─────────────────────────────────────────────────────────────┐
//! │ Control Region (4KB)         @ 0x0000                       │
//! │   - halt_requested (i32)     @ 0x0000                       │
//! │   - halted (i32)             @ 0x0004                       │
//! │   - halt_code (i64)          @ 0x0008                       │
//! │   - reserved                 @ 0x0010+                      │
//! ├─────────────────────────────────────────────────────────────┤
//! │ CLINT Region (64KB)          @ 0x1000                       │
//! │   - msip[MAX_HARTS]          @ 0x0000 (4B each)             │
//! │   - hart_count               @ 0x0F00 (4B)                  │
//! │   - mtimecmp[MAX_HARTS]      @ 0x4000 (8B each)             │
//! │   - mtime                    @ 0xBFF8 (8B)                  │
//! ├─────────────────────────────────────────────────────────────┤
//! │ DRAM Region                  @ 0x11000 (DRAM_BASE offset)   │
//! │   - Kernel, stack, heap, etc.                               │
//! └─────────────────────────────────────────────────────────────┘
//! ```
//!
//! The CLINT layout mirrors the native CLINT for software compatibility.
//! Workers use JavaScript Atomics to access the shared state.

/// Size of the control region in bytes (4KB).
pub const CONTROL_REGION_SIZE: usize = 4096;

/// Size of the CLINT region in bytes (64KB, matches native CLINT_SIZE).
pub const CLINT_REGION_SIZE: usize = 0x10000;

/// Size of the shared UART output region in bytes (4KB).
pub const UART_OUTPUT_REGION_SIZE: usize = 4096;

/// Size of the shared UART input region in bytes (4KB).
pub const UART_INPUT_REGION_SIZE: usize = 4096;

/// Total header size before DRAM starts.
pub const HEADER_SIZE: usize = CONTROL_REGION_SIZE + CLINT_REGION_SIZE + UART_OUTPUT_REGION_SIZE + UART_INPUT_REGION_SIZE;

// ============================================================================
// Shared UART Output Region Offsets
// ============================================================================

/// Offset of the shared UART output region from start of SharedArrayBuffer.
pub const UART_OUTPUT_REGION_OFFSET: usize = CONTROL_REGION_SIZE + CLINT_REGION_SIZE;

/// UART output: write index (i32 index within UART region)
pub const UART_WRITE_IDX: u32 = 0;
/// UART output: read index (i32 index within UART region)
pub const UART_READ_IDX: u32 = 1;
/// UART output: buffer starts at byte 8 (after write_idx and read_idx)
pub const UART_BUFFER_OFFSET: usize = 8;
/// UART output: buffer capacity (region size minus header)
pub const UART_BUFFER_CAPACITY: usize = UART_OUTPUT_REGION_SIZE - UART_BUFFER_OFFSET;

// ============================================================================
// Shared UART Input Region Offsets
// ============================================================================

/// Offset of the shared UART input region from start of SharedArrayBuffer.
pub const UART_INPUT_REGION_OFFSET: usize = CONTROL_REGION_SIZE + CLINT_REGION_SIZE + UART_OUTPUT_REGION_SIZE;

/// UART input: write index (i32 index within UART input region)
pub const UART_INPUT_WRITE_IDX: u32 = 0;
/// UART input: read index (i32 index within UART input region)
pub const UART_INPUT_READ_IDX: u32 = 1;
/// UART input: buffer starts at byte 8 (after write_idx and read_idx)
pub const UART_INPUT_BUFFER_OFFSET: usize = 8;
/// UART input: buffer capacity (region size minus header)
pub const UART_INPUT_BUFFER_CAPACITY: usize = UART_INPUT_REGION_SIZE - UART_INPUT_BUFFER_OFFSET;

// ============================================================================
// Control Region Offsets (relative to start of SharedArrayBuffer)
// Using i32 indices for Atomics API compatibility
// ============================================================================

/// Control region: halt_requested flag (i32 index 0)
pub const CTRL_HALT_REQUESTED: u32 = 0;
/// Control region: halted flag (i32 index 1)
pub const CTRL_HALTED: u32 = 1;
/// Control region: halt_code low 32 bits (i32 index 2)
pub const CTRL_HALT_CODE_LO: u32 = 2;
/// Control region: halt_code high 32 bits (i32 index 3)
pub const CTRL_HALT_CODE_HI: u32 = 3;
/// Control region: number of active harts (i32 index 4)
pub const CTRL_NUM_HARTS: u32 = 4;
/// Control region: epoch counter for workers to detect new work (i32 index 5)
pub const CTRL_EPOCH: u32 = 5;
/// Control region: workers can start executing (i32 index 6)
/// Workers poll this flag; they park until main thread sets it.
pub const CTRL_WORKERS_CAN_START: u32 = 6;

// ============================================================================
// CLINT Region Offsets (relative to CLINT region start at CONTROL_REGION_SIZE)
// These match the native CLINT layout for software compatibility
// ============================================================================

/// CLINT: MSIP base offset (per-hart software interrupt pending)
pub const CLINT_MSIP_BASE: usize = 0x0000;
/// CLINT: MTIMECMP base offset (per-hart timer compare)
pub const CLINT_MTIMECMP_BASE: usize = 0x4000;
/// CLINT: MTIME offset (global timer)
pub const CLINT_MTIME_OFFSET: usize = 0xBFF8;
/// CLINT: HART_COUNT offset (read-only hart count)
pub const CLINT_HART_COUNT_OFFSET: usize = 0x0F00;

/// Maximum harts supported (matches native MAX_HARTS)
pub const MAX_HARTS: usize = 128;

/// Calculate the total SharedArrayBuffer size needed.
///
/// # Arguments
/// * `dram_size` - Size of DRAM region in bytes
pub const fn total_shared_size(dram_size: usize) -> usize {
    HEADER_SIZE + dram_size
}

/// Calculate the DRAM offset within the SharedArrayBuffer.
pub const fn dram_offset() -> usize {
    HEADER_SIZE
}

/// Calculate byte offset for MSIP of a specific hart.
pub const fn msip_offset(hart_id: usize) -> usize {
    CONTROL_REGION_SIZE + CLINT_MSIP_BASE + (hart_id * 4)
}

/// Calculate byte offset for MTIMECMP of a specific hart.
pub const fn mtimecmp_offset(hart_id: usize) -> usize {
    CONTROL_REGION_SIZE + CLINT_MTIMECMP_BASE + (hart_id * 8)
}

/// Calculate byte offset for MTIME.
pub const fn mtime_offset() -> usize {
    CONTROL_REGION_SIZE + CLINT_MTIME_OFFSET
}

/// Calculate byte offset for HART_COUNT.
pub const fn hart_count_offset() -> usize {
    CONTROL_REGION_SIZE + CLINT_HART_COUNT_OFFSET
}

// ============================================================================
// WASM-specific shared CLINT implementation
// ============================================================================

#[cfg(target_arch = "wasm32")]
pub mod wasm {
    use super::*;
    use js_sys::{Atomics, Int32Array, SharedArrayBuffer, Uint8Array};

    /// Shared CLINT accessor for WASM workers.
    ///
    /// This provides a CLINT-compatible interface backed by SharedArrayBuffer
    /// using JavaScript Atomics for thread-safe access.
    pub struct SharedClint {
        /// View of the entire SharedArrayBuffer as Int32Array for Atomics
        view: Int32Array,
        /// CLINT region byte offset
        clint_base: usize,
    }
    
    // SAFETY: SharedClint uses SharedArrayBuffer and JavaScript Atomics for
    // thread-safe access. In WASM, each worker has its own isolated memory space,
    // so the Int32Array view is not actually shared between Rust threads.
    // All cross-worker synchronization goes through SharedArrayBuffer + Atomics.
    unsafe impl Send for SharedClint {}
    unsafe impl Sync for SharedClint {}

    impl SharedClint {
        /// Create a new SharedClint from a SharedArrayBuffer.
        pub fn new(buffer: &SharedArrayBuffer) -> Self {
            Self {
                view: Int32Array::new(buffer),
                clint_base: CONTROL_REGION_SIZE,
            }
        }

        /// Get the i32 index for a byte offset.
        #[inline]
        fn i32_index(&self, byte_offset: usize) -> u32 {
            (byte_offset / 4) as u32
        }

        /// Load mtime (64-bit).
        pub fn mtime(&self) -> u64 {
            let offset = mtime_offset();
            let lo = self.load_i32(offset) as u32 as u64;
            let hi = self.load_i32(offset + 4) as u32 as u64;
            lo | (hi << 32)
        }

        /// Increment mtime (called by hart 0 only).
        pub fn tick(&self, increment: u64) {
            let offset = mtime_offset();
            // Read-modify-write using atomics
            // Note: In WASM, we use Atomics.add for 32-bit values
            // For 64-bit, we need two operations (potential race, but mtime only updated by hart 0)
            let current = self.mtime();
            let new_val = current.wrapping_add(increment);
            self.store_i32(offset, new_val as i32);
            self.store_i32(offset + 4, (new_val >> 32) as i32);
        }

        /// Get MSIP for a hart.
        pub fn get_msip(&self, hart_id: usize) -> u32 {
            if hart_id >= MAX_HARTS {
                return 0;
            }
            let offset = msip_offset(hart_id);
            (self.load_i32(offset) & 1) as u32
        }

        /// Set MSIP for a hart (IPI).
        pub fn set_msip(&self, hart_id: usize, value: u32) {
            if hart_id >= MAX_HARTS {
                return;
            }
            let offset = msip_offset(hart_id);
            self.store_i32(offset, (value & 1) as i32);
        }

        /// Get MTIMECMP for a hart.
        pub fn get_mtimecmp(&self, hart_id: usize) -> u64 {
            if hart_id >= MAX_HARTS {
                return u64::MAX;
            }
            let offset = mtimecmp_offset(hart_id);
            let lo = self.load_i32(offset) as u32 as u64;
            let hi = self.load_i32(offset + 4) as u32 as u64;
            lo | (hi << 32)
        }

        /// Set MTIMECMP for a hart.
        pub fn set_mtimecmp(&self, hart_id: usize, value: u64) {
            if hart_id >= MAX_HARTS {
                return;
            }
            let offset = mtimecmp_offset(hart_id);
            self.store_i32(offset, value as i32);
            self.store_i32(offset + 4, (value >> 32) as i32);
        }

        /// Check interrupts for a hart.
        /// Returns (msip_pending, timer_pending).
        pub fn check_interrupts(&self, hart_id: usize) -> (bool, bool) {
            if hart_id >= MAX_HARTS {
                return (false, false);
            }
            let msip = self.get_msip(hart_id) != 0;
            let mtime = self.mtime();
            let mtimecmp = self.get_mtimecmp(hart_id);
            let timer = mtime >= mtimecmp;
            (msip, timer)
        }

        /// Get number of harts.
        pub fn num_harts(&self) -> usize {
            let offset = hart_count_offset();
            self.load_i32(offset) as usize
        }

        /// Set number of harts (called during init).
        pub fn set_num_harts(&self, num_harts: usize) {
            let offset = hart_count_offset();
            self.store_i32(offset, num_harts.min(MAX_HARTS) as i32);
        }

        /// Load a CLINT register (MMIO-style).
        pub fn load(&self, offset: u64, size: u64) -> u64 {
            let byte_offset = self.clint_base + offset as usize;
            match size {
                4 => self.load_i32(byte_offset) as u32 as u64,
                8 => {
                    let lo = self.load_i32(byte_offset) as u32 as u64;
                    let hi = self.load_i32(byte_offset + 4) as u32 as u64;
                    lo | (hi << 32)
                }
                _ => 0,
            }
        }

        /// Store to a CLINT register (MMIO-style).
        pub fn store(&self, offset: u64, size: u64, value: u64) {
            let byte_offset = self.clint_base + offset as usize;
            match size {
                4 => self.store_i32(byte_offset, value as i32),
                8 => {
                    self.store_i32(byte_offset, value as i32);
                    self.store_i32(byte_offset + 4, (value >> 32) as i32);
                }
                _ => {}
            }
        }

        // Low-level atomic operations

        #[inline]
        fn load_i32(&self, byte_offset: usize) -> i32 {
            let idx = self.i32_index(byte_offset);
            Atomics::load(&self.view, idx).unwrap_or(0)
        }

        #[inline]
        fn store_i32(&self, byte_offset: usize, value: i32) {
            let idx = self.i32_index(byte_offset);
            let _ = Atomics::store(&self.view, idx, value);
        }
    }

    /// Shared control region accessor.
    pub struct SharedControl {
        view: Int32Array,
    }

    impl SharedControl {
        /// Create from SharedArrayBuffer.
        pub fn new(buffer: &SharedArrayBuffer) -> Self {
            Self {
                view: Int32Array::new(buffer),
            }
        }

        /// Check if halt has been requested.
        pub fn is_halt_requested(&self) -> bool {
            Atomics::load(&self.view, CTRL_HALT_REQUESTED).unwrap_or(0) != 0
        }

        /// Request halt (called by any hart).
        pub fn request_halt(&self) {
            let _ = Atomics::store(&self.view, CTRL_HALT_REQUESTED, 1);
            // Wake any workers waiting on this flag
            let _ = Atomics::notify(&self.view, CTRL_HALT_REQUESTED);
        }

        /// Check if VM has halted.
        pub fn is_halted(&self) -> bool {
            Atomics::load(&self.view, CTRL_HALTED).unwrap_or(0) != 0
        }

        /// Signal that VM has halted with a code.
        pub fn signal_halted(&self, code: u64) {
            let _ = Atomics::store(&self.view, CTRL_HALT_CODE_LO, (code & 0xFFFFFFFF) as i32);
            let _ = Atomics::store(&self.view, CTRL_HALT_CODE_HI, (code >> 32) as i32);
            let _ = Atomics::store(&self.view, CTRL_HALTED, 1);
            // Wake all waiting threads
            let _ = Atomics::notify(&self.view, CTRL_HALTED);
        }

        /// Get the halt code.
        pub fn halt_code(&self) -> u64 {
            let lo = Atomics::load(&self.view, CTRL_HALT_CODE_LO).unwrap_or(0) as u32 as u64;
            let hi = Atomics::load(&self.view, CTRL_HALT_CODE_HI).unwrap_or(0) as u32 as u64;
            lo | (hi << 32)
        }

        /// Check if we should stop (halt requested or halted).
        #[inline]
        pub fn should_stop(&self) -> bool {
            self.is_halt_requested() || self.is_halted()
        }

        /// Get the number of active harts.
        pub fn num_harts(&self) -> usize {
            Atomics::load(&self.view, CTRL_NUM_HARTS).unwrap_or(1) as usize
        }

        /// Set the number of active harts.
        pub fn set_num_harts(&self, n: usize) {
            let _ = Atomics::store(&self.view, CTRL_NUM_HARTS, n as i32);
        }

        /// Increment epoch (signal new work available).
        pub fn increment_epoch(&self) {
            let _ = Atomics::add(&self.view, CTRL_EPOCH, 1);
            let _ = Atomics::notify(&self.view, CTRL_EPOCH);
        }

        /// Wait for epoch change (used by workers to wait for work).
        pub fn wait_for_epoch(&self, expected: i32) {
            // Atomics.wait returns immediately if value != expected
            let _ = Atomics::wait(&self.view, CTRL_EPOCH, expected);
        }

        /// Get current epoch.
        pub fn epoch(&self) -> i32 {
            Atomics::load(&self.view, CTRL_EPOCH).unwrap_or(0)
        }

        /// Check if workers can start executing.
        /// Workers poll this flag; they remain parked until it's set.
        pub fn can_workers_start(&self) -> bool {
            Atomics::load(&self.view, CTRL_WORKERS_CAN_START).unwrap_or(0) != 0
        }

        /// Signal that workers can start executing.
        /// Called by hart 0 after initial boot is complete.
        pub fn allow_workers_to_start(&self) {
            let _ = Atomics::store(&self.view, CTRL_WORKERS_CAN_START, 1);
            // Wake any workers waiting on this flag
            let _ = Atomics::notify(&self.view, CTRL_WORKERS_CAN_START);
        }

        /// Wait for workers_can_start signal.
        /// Workers call this to park until main thread allows execution.
        pub fn wait_for_start_signal(&self) {
            // Poll-wait with yield - Atomics.wait may not work in workers
            // depending on browser, so we use a simple poll loop
            while !self.can_workers_start() {
                // Yield to prevent busy-spin from starving other threads
                // This is a hint to the JS runtime
                std::hint::spin_loop();
            }
        }
    }

    /// Shared UART output ring buffer for workers to send output to hart 0.
    ///
    /// This implements a lock-free single-producer-single-consumer ring buffer
    /// using atomics. Workers write to it, and hart 0 reads from it.
    pub struct SharedUartOutput {
        /// View of the entire SharedArrayBuffer as Int32Array for Atomics
        view: Int32Array,
        /// View of the UART buffer region as Uint8Array
        byte_view: Uint8Array,
    }

    // SAFETY: SharedUartOutput uses SharedArrayBuffer and JavaScript Atomics
    unsafe impl Send for SharedUartOutput {}
    unsafe impl Sync for SharedUartOutput {}

    impl SharedUartOutput {
        /// Create a new SharedUartOutput from a SharedArrayBuffer.
        pub fn new(buffer: &SharedArrayBuffer) -> Self {
            Self {
                view: Int32Array::new(buffer),
                byte_view: Uint8Array::new(buffer),
            }
        }

        /// Get the i32 index for an offset within the UART output region.
        #[inline]
        fn uart_i32_index(&self, offset: u32) -> u32 {
            ((UART_OUTPUT_REGION_OFFSET / 4) as u32) + offset
        }

        /// Write a byte to the shared UART output buffer.
        /// Returns true if the byte was written, false if buffer is full.
        pub fn write_byte(&self, byte: u8) -> bool {
            let write_idx_slot = self.uart_i32_index(UART_WRITE_IDX);
            let read_idx_slot = self.uart_i32_index(UART_READ_IDX);

            let write_idx = Atomics::load(&self.view, write_idx_slot).unwrap_or(0) as u32;
            let read_idx = Atomics::load(&self.view, read_idx_slot).unwrap_or(0) as u32;

            let capacity = UART_BUFFER_CAPACITY as u32;
            let next_write = (write_idx + 1) % capacity;

            // Check if buffer is full
            if next_write == read_idx {
                return false;
            }

            // Write the byte
            let byte_offset = UART_OUTPUT_REGION_OFFSET + UART_BUFFER_OFFSET + (write_idx as usize);
            self.byte_view.set_index(byte_offset as u32, byte);

            // Update write index atomically
            let _ = Atomics::store(&self.view, write_idx_slot, next_write as i32);

            true
        }

        /// Read a byte from the shared UART output buffer.
        /// Returns None if buffer is empty.
        pub fn read_byte(&self) -> Option<u8> {
            let write_idx_slot = self.uart_i32_index(UART_WRITE_IDX);
            let read_idx_slot = self.uart_i32_index(UART_READ_IDX);

            let write_idx = Atomics::load(&self.view, write_idx_slot).unwrap_or(0) as u32;
            let read_idx = Atomics::load(&self.view, read_idx_slot).unwrap_or(0) as u32;

            // Check if buffer is empty
            if write_idx == read_idx {
                return None;
            }

            // Read the byte
            let byte_offset = UART_OUTPUT_REGION_OFFSET + UART_BUFFER_OFFSET + (read_idx as usize);
            let byte = self.byte_view.get_index(byte_offset as u32);

            // Update read index atomically
            let capacity = UART_BUFFER_CAPACITY as u32;
            let next_read = (read_idx + 1) % capacity;
            let _ = Atomics::store(&self.view, read_idx_slot, next_read as i32);

            Some(byte)
        }

        /// Check if there are bytes available to read.
        pub fn has_data(&self) -> bool {
            let write_idx_slot = self.uart_i32_index(UART_WRITE_IDX);
            let read_idx_slot = self.uart_i32_index(UART_READ_IDX);

            let write_idx = Atomics::load(&self.view, write_idx_slot).unwrap_or(0);
            let read_idx = Atomics::load(&self.view, read_idx_slot).unwrap_or(0);

            write_idx != read_idx
        }
        
        /// Write multiple bytes to the shared UART output buffer.
        /// This is more efficient than calling write_byte repeatedly as it
        /// reduces atomic operations (only one index read/write per batch).
        /// Returns the number of bytes successfully written.
        pub fn write_bytes(&self, bytes: &[u8]) -> usize {
            if bytes.is_empty() {
                return 0;
            }
            
            let write_idx_slot = self.uart_i32_index(UART_WRITE_IDX);
            let read_idx_slot = self.uart_i32_index(UART_READ_IDX);
            
            // Single atomic read of indices at start
            let write_idx = Atomics::load(&self.view, write_idx_slot).unwrap_or(0) as u32;
            let read_idx = Atomics::load(&self.view, read_idx_slot).unwrap_or(0) as u32;
            
            let capacity = UART_BUFFER_CAPACITY as u32;
            
            // Calculate available space (ring buffer)
            let available = if write_idx >= read_idx {
                capacity - (write_idx - read_idx) - 1
            } else {
                read_idx - write_idx - 1
            };
            
            // Write as many bytes as we can
            let to_write = (bytes.len() as u32).min(available) as usize;
            if to_write == 0 {
                return 0;
            }
            
            let mut current_write = write_idx;
            for &byte in &bytes[..to_write] {
                let byte_offset = UART_OUTPUT_REGION_OFFSET + UART_BUFFER_OFFSET + (current_write as usize);
                self.byte_view.set_index(byte_offset as u32, byte);
                current_write = (current_write + 1) % capacity;
            }
            
            // Single atomic write to update the write index
            let _ = Atomics::store(&self.view, write_idx_slot, current_write as i32);
            
            to_write
        }
        
        /// Read multiple bytes from the shared UART output buffer.
        /// This is more efficient than calling read_byte repeatedly.
        /// Returns a vector of bytes read.
        pub fn read_bytes(&self, max_count: usize) -> Vec<u8> {
            let write_idx_slot = self.uart_i32_index(UART_WRITE_IDX);
            let read_idx_slot = self.uart_i32_index(UART_READ_IDX);
            
            // Single atomic read of indices at start
            let write_idx = Atomics::load(&self.view, write_idx_slot).unwrap_or(0) as u32;
            let read_idx = Atomics::load(&self.view, read_idx_slot).unwrap_or(0) as u32;
            
            // Check if buffer is empty
            if write_idx == read_idx {
                return Vec::new();
            }
            
            let capacity = UART_BUFFER_CAPACITY as u32;
            
            // Calculate available bytes
            let available = if write_idx >= read_idx {
                write_idx - read_idx
            } else {
                capacity - read_idx + write_idx
            } as usize;
            
            let to_read = available.min(max_count);
            let mut bytes = Vec::with_capacity(to_read);
            
            let mut current_read = read_idx;
            for _ in 0..to_read {
                let byte_offset = UART_OUTPUT_REGION_OFFSET + UART_BUFFER_OFFSET + (current_read as usize);
                bytes.push(self.byte_view.get_index(byte_offset as u32));
                current_read = (current_read + 1) % capacity;
            }
            
            // Single atomic write to update the read index
            let _ = Atomics::store(&self.view, read_idx_slot, current_read as i32);
            
            bytes
        }
    }

    /// Shared UART input ring buffer for main thread to send input to workers.
    ///
    /// This implements a lock-free single-producer-single-consumer ring buffer
    /// using atomics. Main thread (hart 0) writes to it, workers read from it.
    /// 
    /// This allows workers to receive keyboard input that the browser sends
    /// to the main thread.
    pub struct SharedUartInput {
        /// View of the entire SharedArrayBuffer as Int32Array for Atomics
        view: Int32Array,
        /// View of the UART input buffer region as Uint8Array
        byte_view: Uint8Array,
    }

    // SAFETY: SharedUartInput uses SharedArrayBuffer and JavaScript Atomics
    unsafe impl Send for SharedUartInput {}
    unsafe impl Sync for SharedUartInput {}

    impl SharedUartInput {
        /// Create a new SharedUartInput from a SharedArrayBuffer.
        pub fn new(buffer: &SharedArrayBuffer) -> Self {
            Self {
                view: Int32Array::new(buffer),
                byte_view: Uint8Array::new(buffer),
            }
        }

        /// Get the i32 index for an offset within the UART input region.
        #[inline]
        fn uart_i32_index(&self, offset: u32) -> u32 {
            ((UART_INPUT_REGION_OFFSET / 4) as u32) + offset
        }

        /// Write a byte to the shared UART input buffer (called by main thread).
        /// Returns true if the byte was written, false if buffer is full.
        pub fn write_byte(&self, byte: u8) -> bool {
            let write_idx_slot = self.uart_i32_index(UART_INPUT_WRITE_IDX);
            let read_idx_slot = self.uart_i32_index(UART_INPUT_READ_IDX);

            let write_idx = Atomics::load(&self.view, write_idx_slot).unwrap_or(0) as u32;
            let read_idx = Atomics::load(&self.view, read_idx_slot).unwrap_or(0) as u32;

            let capacity = UART_INPUT_BUFFER_CAPACITY as u32;
            let next_write = (write_idx + 1) % capacity;

            // Check if buffer is full
            if next_write == read_idx {
                return false;
            }

            // Write the byte
            let byte_offset = UART_INPUT_REGION_OFFSET + UART_INPUT_BUFFER_OFFSET + (write_idx as usize);
            self.byte_view.set_index(byte_offset as u32, byte);

            // Update write index atomically
            let _ = Atomics::store(&self.view, write_idx_slot, next_write as i32);

            true
        }

        /// Read a byte from the shared UART input buffer (called by workers).
        /// Returns None if buffer is empty.
        pub fn read_byte(&self) -> Option<u8> {
            let write_idx_slot = self.uart_i32_index(UART_INPUT_WRITE_IDX);
            let read_idx_slot = self.uart_i32_index(UART_INPUT_READ_IDX);

            let write_idx = Atomics::load(&self.view, write_idx_slot).unwrap_or(0) as u32;
            let read_idx = Atomics::load(&self.view, read_idx_slot).unwrap_or(0) as u32;

            // Check if buffer is empty
            if write_idx == read_idx {
                return None;
            }

            // Read the byte
            let byte_offset = UART_INPUT_REGION_OFFSET + UART_INPUT_BUFFER_OFFSET + (read_idx as usize);
            let byte = self.byte_view.get_index(byte_offset as u32);

            // Update read index atomically
            let capacity = UART_INPUT_BUFFER_CAPACITY as u32;
            let next_read = (read_idx + 1) % capacity;
            let _ = Atomics::store(&self.view, read_idx_slot, next_read as i32);

            Some(byte)
        }

        /// Check if there are bytes available to read.
        pub fn has_data(&self) -> bool {
            let write_idx_slot = self.uart_i32_index(UART_INPUT_WRITE_IDX);
            let read_idx_slot = self.uart_i32_index(UART_INPUT_READ_IDX);

            let write_idx = Atomics::load(&self.view, write_idx_slot).unwrap_or(0);
            let read_idx = Atomics::load(&self.view, read_idx_slot).unwrap_or(0);

            write_idx != read_idx
        }
        
        /// Write multiple bytes to the shared UART input buffer.
        /// This is more efficient than calling write_byte repeatedly.
        /// Returns the number of bytes successfully written.
        pub fn write_bytes(&self, bytes: &[u8]) -> usize {
            if bytes.is_empty() {
                return 0;
            }
            
            let write_idx_slot = self.uart_i32_index(UART_INPUT_WRITE_IDX);
            let read_idx_slot = self.uart_i32_index(UART_INPUT_READ_IDX);
            
            let write_idx = Atomics::load(&self.view, write_idx_slot).unwrap_or(0) as u32;
            let read_idx = Atomics::load(&self.view, read_idx_slot).unwrap_or(0) as u32;
            
            let capacity = UART_INPUT_BUFFER_CAPACITY as u32;
            
            let available = if write_idx >= read_idx {
                capacity - (write_idx - read_idx) - 1
            } else {
                read_idx - write_idx - 1
            };
            
            let to_write = (bytes.len() as u32).min(available) as usize;
            if to_write == 0 {
                return 0;
            }
            
            let mut current_write = write_idx;
            for &byte in &bytes[..to_write] {
                let byte_offset = UART_INPUT_REGION_OFFSET + UART_INPUT_BUFFER_OFFSET + (current_write as usize);
                self.byte_view.set_index(byte_offset as u32, byte);
                current_write = (current_write + 1) % capacity;
            }
            
            let _ = Atomics::store(&self.view, write_idx_slot, current_write as i32);
            
            to_write
        }
        
        /// Read multiple bytes from the shared UART input buffer.
        /// This is more efficient than calling read_byte repeatedly.
        pub fn read_bytes(&self, max_count: usize) -> Vec<u8> {
            let write_idx_slot = self.uart_i32_index(UART_INPUT_WRITE_IDX);
            let read_idx_slot = self.uart_i32_index(UART_INPUT_READ_IDX);
            
            let write_idx = Atomics::load(&self.view, write_idx_slot).unwrap_or(0) as u32;
            let read_idx = Atomics::load(&self.view, read_idx_slot).unwrap_or(0) as u32;
            
            if write_idx == read_idx {
                return Vec::new();
            }
            
            let capacity = UART_INPUT_BUFFER_CAPACITY as u32;
            
            let available = if write_idx >= read_idx {
                write_idx - read_idx
            } else {
                capacity - read_idx + write_idx
            } as usize;
            
            let to_read = available.min(max_count);
            let mut bytes = Vec::with_capacity(to_read);
            
            let mut current_read = read_idx;
            for _ in 0..to_read {
                let byte_offset = UART_INPUT_REGION_OFFSET + UART_INPUT_BUFFER_OFFSET + (current_read as usize);
                bytes.push(self.byte_view.get_index(byte_offset as u32));
                current_read = (current_read + 1) % capacity;
            }
            
            let _ = Atomics::store(&self.view, read_idx_slot, current_read as i32);
            
            bytes
        }
    }

    /// Initialize the shared memory region.
    ///
    /// Sets up the control region, CLINT, and shared UART output with default values.
    pub fn init_shared_memory(buffer: &SharedArrayBuffer, num_harts: usize) {
        let view = Int32Array::new(buffer);

        // Initialize control region
        let _ = Atomics::store(&view, CTRL_HALT_REQUESTED, 0);
        let _ = Atomics::store(&view, CTRL_HALTED, 0);
        let _ = Atomics::store(&view, CTRL_HALT_CODE_LO, 0);
        let _ = Atomics::store(&view, CTRL_HALT_CODE_HI, 0);
        let _ = Atomics::store(&view, CTRL_NUM_HARTS, num_harts as i32);
        let _ = Atomics::store(&view, CTRL_EPOCH, 0);
        // Workers start parked - main thread will set this after boot
        let _ = Atomics::store(&view, CTRL_WORKERS_CAN_START, 0);

        // Initialize CLINT region
        let clint = SharedClint::new(buffer);

        // Initialize MTIME to 0
        let mtime_off = mtime_offset();
        let _ = Atomics::store(&view, (mtime_off / 4) as u32, 0);
        let _ = Atomics::store(&view, ((mtime_off + 4) / 4) as u32, 0);

        // Initialize MSIP to 0 for all harts
        for hart in 0..MAX_HARTS {
            clint.set_msip(hart, 0);
        }

        // Initialize MTIMECMP to MAX for all harts (no timer interrupt)
        for hart in 0..MAX_HARTS {
            clint.set_mtimecmp(hart, u64::MAX);
        }

        // Set hart count
        clint.set_num_harts(num_harts);

        // Initialize shared UART output region
        // write_idx and read_idx both start at 0 (empty buffer)
        let uart_out_base_i32 = (UART_OUTPUT_REGION_OFFSET / 4) as u32;
        let _ = Atomics::store(&view, uart_out_base_i32 + UART_WRITE_IDX, 0);
        let _ = Atomics::store(&view, uart_out_base_i32 + UART_READ_IDX, 0);

        // Initialize shared UART input region
        // write_idx and read_idx both start at 0 (empty buffer)
        let uart_in_base_i32 = (UART_INPUT_REGION_OFFSET / 4) as u32;
        let _ = Atomics::store(&view, uart_in_base_i32 + UART_INPUT_WRITE_IDX, 0);
        let _ = Atomics::store(&view, uart_in_base_i32 + UART_INPUT_READ_IDX, 0);
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_offsets() {
        // Control region is 4KB
        assert_eq!(CONTROL_REGION_SIZE, 4096);
        
        // CLINT region is 64KB
        assert_eq!(CLINT_REGION_SIZE, 0x10000);
        
        // UART output region is 4KB
        assert_eq!(UART_OUTPUT_REGION_SIZE, 4096);
        
        // UART input region is 4KB
        assert_eq!(UART_INPUT_REGION_SIZE, 4096);
        
        // Header is control + CLINT + UART output + UART input
        assert_eq!(HEADER_SIZE, 4096 + 0x10000 + 4096 + 4096);
        
        // DRAM starts after header
        assert_eq!(dram_offset(), HEADER_SIZE);
    }

    #[test]
    fn test_clint_offsets() {
        // MSIP for hart 0 is at CLINT base
        assert_eq!(msip_offset(0), CONTROL_REGION_SIZE + 0);
        
        // MSIP for hart 1 is 4 bytes later
        assert_eq!(msip_offset(1), CONTROL_REGION_SIZE + 4);
        
        // MTIMECMP for hart 0
        assert_eq!(mtimecmp_offset(0), CONTROL_REGION_SIZE + 0x4000);
        
        // MTIME
        assert_eq!(mtime_offset(), CONTROL_REGION_SIZE + 0xBFF8);
    }

    #[test]
    fn test_total_size() {
        let dram_size = 512 * 1024 * 1024; // 512 MiB
        let total = total_shared_size(dram_size);
        assert_eq!(total, HEADER_SIZE + dram_size);
    }
}
</file>

<file path="riscv-vm/tsup/tsup.core.cjs.ts">
import createConfig from './';
export default createConfig({
  format: ['cjs'],
  entry: ['index.ts'],  // Worker is built separately
});
</file>

<file path="riscv-vm/tsup/tsup.core.esm.ts">
import createConfig from './';
export default createConfig({
  format: ['esm'],
  entry: ['index.ts'],  // Worker is built separately
});
</file>

<file path="riscv-vm/tsup/tsup.worker.ts">
import { defineConfig } from "tsup";
import { wasmPlugin } from "./";

// Worker needs to be self-contained (no code splitting) because
// it runs in a separate thread and can't resolve relative imports.
// We use ESM format but bundle everything inline.
export default defineConfig({
  entry: { worker: "worker.ts" },
  format: ["esm"], // ESM works in workers without module.exports issues
  outDir: "build",
  outExtension: () => ({ js: ".js" }),
  target: "esnext",
  minify: false,
  platform: "browser",
  clean: false,
  splitting: false, // No code splitting - single file
  treeshake: true,
  esbuildPlugins: [wasmPlugin],
  noExternal: [/.*/], // Bundle everything including WASM bindings
  esbuildOptions: (options) => {
    options.platform = "browser";
    // Bundle all imports inline
    options.bundle = true;
  },
});
</file>

<file path="riscv-vm/tsconfig.json">
{
  "compilerOptions": {
    "outDir": "build",
    "skipLibCheck": true,
    "moduleResolution": "bundler",
    "allowJs": true,
    "target": "es2022",
    "module": "es2022",
    "declaration": true,
    "emitDeclarationOnly": false,
    "esModuleInterop": true,
    "forceConsistentCasingInFileNames": true,
    "moduleDetection": "force",
    "strict": true,
    "lib": ["ES2022", "DOM", ],
  },
  "include": ["pkg", "index.ts", "worker.ts", "cli.ts","node-worker.ts"],
  "exclude": ["node_modules", "build"]
}
</file>

<file path="kernel/src/fs.rs">
// kernel/src/sfs.rs
use alloc::string::String;
use alloc::vec::Vec;
use crate::virtio_blk::VirtioBlock;

// Must match mkfs constants
const SECTOR_SIZE: u64 = 512;
const MAGIC: u32 = 0x53465331;
const SEC_SUPER: u64 = 0;
const SEC_MAP_START: u64 = 1;
const SEC_MAP_COUNT: u64 = 64;
pub const SEC_DIR_START: u64 = 65;
pub const SEC_DIR_COUNT: u64 = 64;
const SEC_DATA_START: u64 = 129;

#[repr(C, packed)]
#[derive(Clone, Copy)]
struct DirEntry {
    name: [u8; 24],
    size: u32,
    head: u32,
}

/// Information about a file in the filesystem
/// Used by the scripting engine to expose directory listing
#[derive(Clone)]
pub struct FileInfo {
    pub name: String,
    pub size: u32,
    pub is_dir: bool,
}

pub struct FileSystem {
    // Only cache first sector of bitmap for now to save RAM
    // A production FS would cache on demand
    bitmap_cache: [u8; 512],
    bitmap_dirty: bool,
}

impl FileSystem {
    pub fn init(dev: &mut VirtioBlock) -> Option<Self> {
        let mut buf = [0u8; 512];
        if dev.read_sector(SEC_SUPER, &mut buf).is_err() { return None; }
        
        let magic = u32::from_le_bytes(buf[0..4].try_into().unwrap());
        if magic != MAGIC { return None; }

        // Load first sector of bitmap
        if dev.read_sector(SEC_MAP_START, &mut buf).is_err() { return None; }

        Some(Self {
            bitmap_cache: buf,
            bitmap_dirty: false,
        })
    }

    /// List all files in the root directory
    /// Returns a Vec of FileInfo structs for use by the scripting engine
    pub fn list_dir(&self, dev: &mut VirtioBlock, _path: &str) -> Vec<FileInfo> {
        let mut entries = Vec::new();
        let mut buf = [0u8; 512];

        for i in 0..SEC_DIR_COUNT {
            if dev.read_sector(SEC_DIR_START + i, &mut buf).is_ok() {
                for j in 0..16 { // 512 / 32 = 16 entries
                    let offset = j * 32;
                    if buf[offset] == 0 { continue; }

                    let entry = unsafe { &*(buf[offset..offset+32].as_ptr() as *const DirEntry) };
                    
                    // Decode Name
                    let name_len = entry.name.iter().position(|&c| c == 0).unwrap_or(24);
                    let name = core::str::from_utf8(&entry.name[..name_len])
                        .unwrap_or("???")
                        .into();

                    entries.push(FileInfo {
                        name,
                        size: entry.size,
                        is_dir: false, // Simple FS - everything is a file
                    });
                }
            }
        }
        entries
    }

    /// Legacy ls function that prints directly to UART
    pub fn ls(&self, dev: &mut VirtioBlock) {
        let mut buf = [0u8; 512];
        crate::uart::write_line("SIZE        NAME");
        crate::uart::write_line("----------  --------------------");

        for i in 0..SEC_DIR_COUNT {
            dev.read_sector(SEC_DIR_START + i, &mut buf).ok();
            for j in 0..16 { // 512 / 32 = 16 entries
                let offset = j * 32;
                if buf[offset] == 0 { continue; }

                let entry = unsafe { &*(buf[offset..offset+32].as_ptr() as *const DirEntry) };
                
                // Decode Name
                let name_len = entry.name.iter().position(|&c| c == 0).unwrap_or(24);
                let name = core::str::from_utf8(&entry.name[..name_len]).unwrap_or("???");

                // Print
                crate::uart::write_u64(entry.size as u64);
                if entry.size < 10 { crate::uart::write_str("         "); }
                else if entry.size < 100 { crate::uart::write_str("        "); }
                else { crate::uart::write_str("       "); }
                crate::uart::write_line(name);
            }
        }
    }

    pub fn read_file(&self, dev: &mut VirtioBlock, filename: &str) -> Option<Vec<u8>> {
        let entry = self.find_entry(dev, filename)?;
        let mut data = Vec::with_capacity(entry.size as usize);
        let mut next = entry.head;
        let mut buf = [0u8; 512];

        while next != 0 && (data.len() < entry.size as usize) {
            dev.read_sector(next as u64, &mut buf).ok()?;
            let next_ptr = u32::from_le_bytes(buf[0..4].try_into().unwrap());
            
            let remaining = entry.size as usize - data.len();
            let chunk = core::cmp::min(remaining, 508);
            data.extend_from_slice(&buf[4..4+chunk]);
            
            next = next_ptr;
        }
        Some(data)
    }

    pub fn write_file(&mut self, dev: &mut VirtioBlock, filename: &str, data: &[u8]) -> Result<(), &'static str> {
        // Simple implementation: Overwrite existing or Create new
        let (sector, index) = match self.find_entry_pos(dev, filename) {
            Some(pos) => pos,
            None => self.find_free_dir_entry(dev).ok_or("Root dir full")?,
        };

        // Note: This implementation leaks old blocks if overwriting (simplification)
        
        // Write Data
        let mut remaining = data;
        let mut head = 0;
        let mut prev = 0;

        // Special case: empty file
        if data.is_empty() {
            // head stays 0
        } else {
            while !remaining.is_empty() {
                let current = self.alloc_block(dev).ok_or("Disk full")?;
                if head == 0 { head = current; }
                
                if prev != 0 {
                    // Link previous
                    self.link_block(dev, prev, current)?;
                }

                let len = core::cmp::min(remaining.len(), 508);
                let mut buf = [0u8; 512];
                // Next = 0 (for now)
                buf[4..4+len].copy_from_slice(&remaining[..len]);
                dev.write_sector(current as u64, &buf)?;

                remaining = &remaining[len..];
                prev = current;
            }
        }

        // Update Dir Entry
        let mut name = [0u8; 24];
        let fname_bytes = filename.as_bytes();
        let len = core::cmp::min(fname_bytes.len(), 24);
        name[..len].copy_from_slice(&fname_bytes[..len]);

        let entry = DirEntry {
            name,
            size: data.len() as u32,
            head,
        };

        // Write Entry
        let mut buf = [0u8; 512];
        dev.read_sector(sector, &mut buf)?;
        let offset = index * 32;
        let ptr = &mut buf[offset] as *mut u8 as *mut DirEntry;
        unsafe { *ptr = entry; }
        dev.write_sector(sector, &buf)?;

        Ok(())
    }

    // --- Helpers ---

    fn find_entry(&self, dev: &mut VirtioBlock, name: &str) -> Option<DirEntry> {
        if let Some((sec, idx)) = self.find_entry_pos(dev, name) {
            let mut buf = [0u8; 512];
            dev.read_sector(sec, &mut buf).ok()?;
            let offset = idx * 32;
            let entry = unsafe { &*(buf[offset..offset+32].as_ptr() as *const DirEntry) };
            return Some(*entry);
        }
        None
    }

    fn find_entry_pos(&self, dev: &mut VirtioBlock, name: &str) -> Option<(u64, usize)> {
        let mut buf = [0u8; 512];
        for i in 0..SEC_DIR_COUNT {
            let sector = SEC_DIR_START + i;
            dev.read_sector(sector, &mut buf).ok()?;
            for j in 0..16 {
                let offset = j * 32;
                if buf[offset] == 0 { continue; }
                let entry = unsafe { &*(buf[offset..offset+32].as_ptr() as *const DirEntry) };
                let len = entry.name.iter().position(|&c| c == 0).unwrap_or(24);
                let entry_name = core::str::from_utf8(&entry.name[..len]).unwrap_or("");
                if entry_name == name { return Some((sector, j)); }
            }
        }
        None
    }

    fn find_free_dir_entry(&self, dev: &mut VirtioBlock) -> Option<(u64, usize)> {
        let mut buf = [0u8; 512];
        for i in 0..SEC_DIR_COUNT {
            let sector = SEC_DIR_START + i;
            dev.read_sector(sector, &mut buf).ok()?;
            for j in 0..16 {
                if buf[j * 32] == 0 { return Some((sector, j)); }
            }
        }
        None
    }

    fn alloc_block(&mut self, dev: &mut VirtioBlock) -> Option<u32> {
        // Naive: Only searches the cached first sector of bitmap
        for i in 0..self.bitmap_cache.len() {
            if self.bitmap_cache[i] != 0xFF {
                for bit in 0..8 {
                    if (self.bitmap_cache[i] & (1 << bit)) == 0 {
                        self.bitmap_cache[i] |= 1 << bit;
                        self.bitmap_dirty = true;
                        
                        // Sync immediately
                        dev.write_sector(SEC_MAP_START, &self.bitmap_cache).ok()?;
                        
                        let sector = (i * 8 + bit) as u32;
                        // Map offset + offset in map
                        // Actually our logic says sector is absolute index.
                        // But remember MKFS reserved first X sectors.
                        return Some(sector);
                    }
                }
            }
        }
        None
    }

    fn link_block(&self, dev: &mut VirtioBlock, prev: u32, next: u32) -> Result<(), &'static str> {
        let mut buf = [0u8; 512];
        dev.read_sector(prev as u64, &mut buf)?;
        buf[0..4].copy_from_slice(&next.to_le_bytes());
        dev.write_sector(prev as u64, &buf)
    }
}
</file>

<file path="kernel/src/init.rs">
//! Init system - PID 1 process
//!
//! The init process is responsible for:
//! - Spawning system services (daemons)
//! - Running startup scripts from /etc/init.d/
//! - Reaping zombie processes
//! - System shutdown coordination
//!
//! Similar to Linux's init/systemd but much simpler.

use alloc::string::String;
use alloc::vec::Vec;
use alloc::format;
use core::sync::atomic::{AtomicBool, AtomicUsize, Ordering};

use crate::task::Priority;
use crate::scheduler::SCHEDULER;
use crate::klog::{klog_info, klog_error};
use crate::Spinlock;

/// Init system state
static INIT_STATE: Spinlock<InitState> = Spinlock::new(InitState::new());

/// Whether init has completed startup
static INIT_COMPLETE: AtomicBool = AtomicBool::new(false);

/// Number of services started
static SERVICES_STARTED: AtomicUsize = AtomicUsize::new(0);

/// Service status
#[derive(Clone, Copy, PartialEq, Eq)]
pub enum ServiceStatus {
    Stopped,
    Running,
    Failed,
}

impl ServiceStatus {
    pub fn as_str(&self) -> &'static str {
        match self {
            ServiceStatus::Stopped => "stopped",
            ServiceStatus::Running => "running",
            ServiceStatus::Failed => "failed",
        }
    }
}

/// Service definition - describes a service that can be started/stopped
#[derive(Clone)]
pub struct ServiceDef {
    pub name: String,
    pub description: String,
    pub entry: crate::task::TaskEntry,
    pub priority: crate::task::Priority,
    pub preferred_hart: Option<usize>,
}

/// Service runtime info
#[derive(Clone)]
pub struct ServiceInfo {
    pub name: String,
    pub pid: u32,
    pub status: ServiceStatus,
    pub started_at: u64,
    pub hart: Option<usize>,
}

/// Init state
struct InitState {
    /// Registered service definitions
    service_defs: Vec<ServiceDef>,
    /// Running services
    services: Vec<ServiceInfo>,
}

impl InitState {
    const fn new() -> Self {
        Self {
            service_defs: Vec::new(),
            services: Vec::new(),
        }
    }
}

// ═══════════════════════════════════════════════════════════════════════════════
// INIT PROCESS
// ═══════════════════════════════════════════════════════════════════════════════

/// Init process entry point - PID 1
/// 
/// This runs on the primary hart and is responsible for bringing up the system.
pub fn init_main() {
    klog_info("init", "Starting init system (PID 1)");
    
    // Phase 1: Create required directories
    klog_info("init", "Phase 1: Creating system directories");
    ensure_directories();
    
    // Phase 2: Start system services
    klog_info("init", "Phase 2: Starting system services");
    start_system_services();
    
    // Phase 3: Run init scripts
    klog_info("init", "Phase 3: Running init scripts");
    run_init_scripts();
    
    // Mark init complete
    INIT_COMPLETE.store(true, Ordering::Release);
    
    let services = SERVICES_STARTED.load(Ordering::Relaxed);
    klog_info("init", &format!("Init complete. {} services started.", services));
    
    // Write initial boot message to kernel.log
    write_boot_log();
    
    // Init process is done - it doesn't need to loop
    // The scheduler will continue running other tasks
}

/// Ensure required system directories exist
fn ensure_directories() {
    let dirs = [
        "/var",
        "/var/log",
        "/var/run",
        "/etc",
        "/tmp",
    ];
    
    for dir in &dirs {
        // For our simple FS, we just ensure we can write a marker file
        // A real FS would have proper directory support
        // Directory ensured: dir (no-op in our simple FS)
        let _ = dir;
    }
}

/// Start core system services
fn start_system_services() {
    let num_harts = crate::HARTS_ONLINE.load(Ordering::Relaxed);
    klog_info("init", &format!("{} harts available for parallel tasks", num_harts));
    
    // Register service definitions (available services)
    // 
    // NOTE: All daemons are pinned to hart 0 (Some(0)) because in WASM multi-hart
    // mode, only hart 0 (main thread) has VirtIO access. Secondary harts (workers)
    // only share DRAM via SharedArrayBuffer and cannot access disk/network.
    // 
    // In native mode, all harts share Arc<SystemBus> with VirtIO, but pinning to
    // hart 0 is still safe and keeps behavior consistent across platforms.
    register_service_def(
        "klogd",
        "Kernel logger daemon - logs system memory stats",
        klogd_service,
        Priority::Normal,
        Some(0),  // Pin to hart 0 - has VirtIO access in both native and WASM
    );
    
    register_service_def(
        "sysmond",
        "System monitor daemon - monitors system health",
        sysmond_service,
        Priority::Normal,
        Some(0),  // Pin to hart 0 - has VirtIO access in both native and WASM
    );
    
    // Auto-start daemons (they're pinned to hart 0, safe in all modes)
    if let Ok(()) = start_service("klogd") {
        klog_info("init", "Auto-started klogd on hart 0");
    }
    if let Ok(()) = start_service("sysmond") {
        klog_info("init", "Auto-started sysmond on hart 0");
    }
}

// ═══════════════════════════════════════════════════════════════════════════════
// PUBLIC SERVICE CONTROL API
// ═══════════════════════════════════════════════════════════════════════════════

/// Start a service by name
/// Returns Ok(()) on success, Err(message) on failure
pub fn start_service(name: &str) -> Result<(), &'static str> {
    let state = INIT_STATE.lock();
    
    // Check if already running
    if let Some(svc) = state.services.iter().find(|s| s.name == name) {
        if svc.status == ServiceStatus::Running {
            return Err("Service is already running");
        }
    }
    
    // Find service definition
    let def = state.service_defs.iter().find(|d| d.name == name)
        .ok_or("Service not found")?;
    
    let entry = def.entry;
    let priority = def.priority;
    let preferred_hart = def.preferred_hart;
    let name_owned = def.name.clone();
    
    drop(state); // Release lock before spawning
    
    // Spawn the service
    let pid = SCHEDULER.spawn_daemon_on_hart(
        &name_owned,
        entry,
        priority,
        preferred_hart,
    );
    
    // Register as running
    register_service(&name_owned, pid, preferred_hart);
    
    // Wake the target hart
    if let Some(hart) = preferred_hart {
        crate::send_ipi(hart);
    }
    
    Ok(())
}

/// Stop a service by name
/// Returns Ok(()) on success, Err(message) on failure
pub fn stop_service(name: &str) -> Result<(), &'static str> {
    let state = INIT_STATE.lock();
    
    // Find the running service
    let svc = state.services.iter().find(|s| s.name == name)
        .ok_or("Service not found")?;
    
    if svc.status != ServiceStatus::Running {
        return Err("Service is not running");
    }
    
    let pid = svc.pid;
    drop(state); // Release lock before killing
    
    // Kill the service task
    if pid > 0 {
        SCHEDULER.kill(pid);
    }
    
    // Mark as stopped
    mark_service_stopped(name);
    
    Ok(())
}

/// Restart a service by name
/// Returns Ok(()) on success, Err(message) on failure
pub fn restart_service(name: &str) -> Result<(), &'static str> {
    // Stop if running (ignore error if not running)
    let _ = stop_service(name);
    
    // Small delay to let things settle
    for _ in 0..10000 {
        core::hint::spin_loop();
    }
    
    // Start the service
    start_service(name)
}

/// Get status of a service
pub fn service_status(name: &str) -> Option<ServiceStatus> {
    let state = INIT_STATE.lock();
    state.services.iter()
        .find(|s| s.name == name)
        .map(|s| s.status)
}

/// Get detailed info about a service
pub fn get_service_info(name: &str) -> Option<ServiceInfo> {
    let state = INIT_STATE.lock();
    state.services.iter()
        .find(|s| s.name == name)
        .cloned()
}

/// List all registered services (definitions)
pub fn list_service_defs() -> Vec<(String, String)> {
    let state = INIT_STATE.lock();
    state.service_defs.iter()
        .map(|d| (d.name.clone(), d.description.clone()))
        .collect()
}

/// Register a service definition (what the service is and how to start it)
fn register_service_def(name: &str, description: &str, entry: crate::task::TaskEntry, priority: crate::task::Priority, preferred_hart: Option<usize>) {
    let mut state = INIT_STATE.lock();
    state.service_defs.push(ServiceDef {
        name: String::from(name),
        description: String::from(description),
        entry,
        priority,
        preferred_hart,
    });
}

/// Register a running service instance
fn register_service(name: &str, pid: u32, hart: Option<usize>) {
    let mut state = INIT_STATE.lock();
    
    // Update existing or add new
    if let Some(svc) = state.services.iter_mut().find(|s| s.name == name) {
        svc.pid = pid;
        svc.status = ServiceStatus::Running;
        svc.started_at = crate::get_time_ms() as u64;
        svc.hart = hart;
    } else {
        state.services.push(ServiceInfo {
            name: String::from(name),
            pid,
            status: ServiceStatus::Running,
            started_at: crate::get_time_ms() as u64,
            hart,
        });
    }
    SERVICES_STARTED.fetch_add(1, Ordering::Relaxed);
}

/// Mark a service as stopped
fn mark_service_stopped(name: &str) {
    let mut state = INIT_STATE.lock();
    if let Some(svc) = state.services.iter_mut().find(|s| s.name == name) {
        svc.status = ServiceStatus::Stopped;
        svc.pid = 0;
        svc.hart = None;
    }
}

/// Run init scripts from /etc/init.d/
fn run_init_scripts() {
    let fs_guard = crate::FS_STATE.lock();
    let mut blk_guard = crate::BLK_DEV.lock();
    
    if let (Some(fs), Some(dev)) = (fs_guard.as_ref(), blk_guard.as_mut()) {
        // Look for init scripts
        let files = fs.list_dir(dev, "/");
        for file in files {
            if file.name.starts_with("/etc/init.d/") {
                let script_name = &file.name[12..]; // Strip "/etc/init.d/"
                klog_info("init", &format!("Running init script: {}", script_name));
                
                // Read and execute the script
                if let Some(content) = fs.read_file(dev, &file.name) {
                    if let Ok(script) = core::str::from_utf8(&content) {
                        drop(blk_guard);
                        drop(fs_guard);
                        
                        // Execute via scripting engine
                        match crate::scripting::execute_script(script, "") {
                            Ok(output) => {
                                if !output.is_empty() {
                                    klog_info("init", &format!("Script output: {}", output.trim()));
                                }
                            }
                            Err(e) => {
                                klog_error("init", &format!("Script error: {}", e));
                            }
                        }
                        return; // Re-acquire locks would be complex, just return
                    }
                }
            }
        }
    }
}

/// Write boot information to kernel.log
fn write_boot_log() {
    let timestamp = crate::get_time_ms();
    let num_harts = crate::HARTS_ONLINE.load(Ordering::Relaxed);
    let services = SERVICES_STARTED.load(Ordering::Relaxed);
    
    let boot_msg = format!(
        "=== BAVY OS Boot Log ===\n\
         Boot time: {}ms\n\
         Harts online: {}\n\
         Services started: {}\n\
         ========================\n",
        timestamp, num_harts, services
    );
    
    // Write to kernel.log
    let mut fs_guard = crate::FS_STATE.lock();
    let mut blk_guard = crate::BLK_DEV.lock();
    
    if let (Some(fs), Some(dev)) = (fs_guard.as_mut(), blk_guard.as_mut()) {
        if let Err(e) = fs.write_file(dev, "/var/log/kernel.log", boot_msg.as_bytes()) {
            klog_error("init", &format!("Failed to write boot log: {}", e));
        } else {
            klog_info("init", "Boot log written to /var/log/kernel.log");
        }
    }
}

// ═══════════════════════════════════════════════════════════════════════════════
// SYSTEM SERVICES (long-running daemons on secondary harts)
// ═══════════════════════════════════════════════════════════════════════════════

/// Spin-delay for approximately the given milliseconds
/// Uses busy-waiting since secondary harts don't have timer interrupts
#[inline(never)]
fn spin_delay_ms(ms: u64) {
    let start = crate::get_time_ms() as u64;
    let target = start + ms;
    while (crate::get_time_ms() as u64) < target {
        // Yield CPU hints to save power
        for _ in 0..100 {
            core::hint::spin_loop();
        }
    }
}

/// Append a line to the kernel log file
/// Returns true on success
fn append_to_log(line: &str) -> bool {
    let mut fs_guard = crate::FS_STATE.lock();
    let mut blk_guard = crate::BLK_DEV.lock();
    
    if let (Some(fs), Some(dev)) = (fs_guard.as_mut(), blk_guard.as_mut()) {
        // Read existing content
        let existing = fs.read_file(dev, "/var/log/kernel.log")
            .map(|v| String::from_utf8_lossy(&v).into_owned())
            .unwrap_or_default();
        
        // Truncate if too large (keep last 16KB)
        let trimmed = if existing.len() > 16384 {
            String::from(&existing[existing.len() - 16384..])
        } else {
            existing
        };
        
        let new_content = format!("{}{}\n", trimmed, line);
        
        return fs.write_file(dev, "/var/log/kernel.log", new_content.as_bytes()).is_ok();
    }
    false
}

/// Kernel Logger Daemon (klogd)
/// 
/// Runs continuously on a secondary hart, periodically writing system status
/// to /var/log/kernel.log every 5 seconds.
pub fn klogd_service() {
    let hart_id = crate::get_hart_id();
    let mut tick: u64 = 0;
    
    // Write startup message
    let startup_msg = format!(
        "══════════════════════════════════════════════════════════════\n\
         BAVY OS - Kernel Logger Started\n\
         ══════════════════════════════════════════════════════════════\n\
         Time: {}ms | Hart: {} | klogd daemon initialized\n\
         ──────────────────────────────────────────────────────────────",
        crate::get_time_ms(),
        hart_id
    );
    append_to_log(&startup_msg);
    
    // Main daemon loop
    loop {
        tick += 1;
        
        // Wait 5 seconds between log entries
        spin_delay_ms(5000);
        
        let timestamp = crate::get_time_ms();
        let (heap_used, heap_free) = crate::allocator::heap_stats();
        let heap_total = crate::allocator::heap_size();
        let usage_pct = (heap_used * 100) / heap_total.max(1);
        
        // Format log entry
        let log_entry = format!(
            "[{:>10}ms] klogd #{}: mem={}%({}/{}KB)",
            timestamp,
            tick,
            usage_pct,
            heap_used / 1024,
            heap_total / 1024,
        );
        
        append_to_log(&log_entry);
    }
}

/// System Monitor Daemon (sysmond)  
/// 
/// Runs continuously on a secondary hart, monitoring system health
/// and logging statistics every 10 seconds.
pub fn sysmond_service() {
    let hart_id = crate::get_hart_id();
    let mut tick: u64 = 0;
    
    // Small initial delay to let klogd start first
    spin_delay_ms(2000);
    
    // Write startup message
    let startup_msg = format!(
        "[{:>10}ms] sysmond started on hart {}",
        crate::get_time_ms(),
        hart_id
    );
    append_to_log(&startup_msg);
    
    // Main daemon loop
    loop {
        tick += 1;
        
        // Wait 10 seconds between checks
        spin_delay_ms(10000);
        
        let timestamp = crate::get_time_ms();
        
        // Collect system stats (minimize lock hold time)
        let task_count = SCHEDULER.task_count();
        let queued = SCHEDULER.queued_count();
        let num_harts = crate::HARTS_ONLINE.load(Ordering::Relaxed);
        
        let net_ok = crate::NET_STATE.lock().is_some();
        let fs_ok = crate::FS_STATE.lock().is_some();
        
        // Format log entry
        let log_entry = format!(
            "[{:>10}ms] sysmond #{}: harts={} tasks={} queued={} net={} fs={}",
            timestamp,
            tick,
            num_harts,
            task_count,
            queued,
            if net_ok { "UP" } else { "DOWN" },
            if fs_ok { "OK" } else { "ERR" },
        );
        
        append_to_log(&log_entry);
        
        // Reap zombie processes periodically
        let reaped = SCHEDULER.reap_zombies();
        if reaped > 0 {
            let reap_msg = format!(
                "[{:>10}ms] sysmond: reaped {} zombie process(es)",
                crate::get_time_ms(),
                reaped
            );
            append_to_log(&reap_msg);
        }
    }
}

// ═══════════════════════════════════════════════════════════════════════════════
// UTILITY FUNCTIONS
// ═══════════════════════════════════════════════════════════════════════════════

/// Check if init has completed
pub fn is_init_complete() -> bool {
    INIT_COMPLETE.load(Ordering::Acquire)
}

/// Get list of all services (running and stopped)
pub fn list_services() -> Vec<ServiceInfo> {
    let state = INIT_STATE.lock();
    
    // Return all services, adding stopped ones from definitions
    let mut result = state.services.clone();
    
    // Add any defined services that aren't in the running list
    for def in &state.service_defs {
        if !result.iter().any(|s| s.name == def.name) {
            result.push(ServiceInfo {
                name: def.name.clone(),
                pid: 0,
                status: ServiceStatus::Stopped,
                started_at: 0,
                hart: None,
            });
        }
    }
    
    result
}

/// Get number of services started
pub fn service_count() -> usize {
    SERVICES_STARTED.load(Ordering::Relaxed)
}
</file>

<file path="mkfs/root/usr/bin/cat">
// cat - Display file contents
// Usage: cat <filename>

import * as fs from "os:fs"
import * as sys from "os:sys"

if ARGS.len() < 1 {
    print("Usage: cat <filename>");
} else {
    let path = ARGS[0];
    
    // Resolve path relative to CWD
    let filename = "";
    if path.starts_with("/") {
        filename = path;
    } else {
        let cwd = sys.cwd();
        if cwd == "/" {
            filename = "/" + path;
        } else {
            filename = cwd + "/" + path;
        }
    }
    
    if !fs.exists(filename) {
        print("Error: File not found: " + filename);
    } else {
        let content = fs.read(filename);
        if content.ends_with("\n") {
            write(content);
        } else {
            print(content);
        }
    }
}
</file>

<file path="mkfs/root/usr/bin/ls">
// ls - List files in the filesystem
// Usage: ls [OPTIONS] [PATH]

import * as fs from "os:fs"
import * as sys from "os:sys"

if !fs.available() {
    print("\x1b[1;31mError:\x1b[0m Filesystem not available");
    return;
}

// Parse options
let show_long = false;
let show_all = false;
let human_readable = false;
let one_per_line = false;
let recursive = false;
let path_filter = sys.cwd();

for arg in ARGS {
    if arg.starts_with("-") {
        for ch in arg.chars() {
            if ch == 'l' { show_long = true; }
            if ch == 'a' { show_all = true; }
            if ch == 'h' { human_readable = true; }
            if ch == '1' { one_per_line = true; }
            if ch == 'R' { recursive = true; }
        }
    } else {
        // Resolve path relative to CWD
        if arg.starts_with("/") {
            path_filter = arg;
        } else {
            let cwd = sys.cwd();
            if cwd == "/" {
                path_filter = "/" + arg;
            } else {
                path_filter = cwd + "/" + arg;
            }
        }
        if path_filter.len() > 1 && path_filter.ends_with("/") {
            path_filter = path_filter.sub_string(0, path_filter.len() - 1);
        }
    }
}

let all_files = fs.ls();

fn get_child_name(full_path, parent_path) {
    let relative = "";
    if parent_path == "/" {
        if full_path.starts_with("/") {
            relative = full_path.sub_string(1);
        } else {
            relative = full_path;
        }
    } else {
        if full_path.starts_with(parent_path + "/") {
            relative = full_path.sub_string(parent_path.len() + 1);
        } else if full_path == parent_path {
            return "";
        } else {
            return "";
        }
    }
    
    if relative.contains("/") {
        let idx = 0;
        for ch in relative.chars() {
            if ch == '/' { break; }
            idx += 1;
        }
        return relative.sub_string(0, idx);
    }
    return relative;
}

let entries = #{};

for file in all_files {
    let name = file.name;
    
    if recursive {
        let base = name;
        if name.contains("/") {
            let parts = name.split("/");
            base = parts[parts.len() - 1];
        }
        if !show_all && base.starts_with(".") {
            continue;
        }
        entries[name] = #{name: name, size: file.size, is_dir: false};
        continue;
    }
    
    let child = get_child_name(name, path_filter);
    if child == "" { continue; }
    
    if !show_all && child.starts_with(".") {
        continue;
    }
    
    let full_child_path = "";
    if path_filter == "/" {
        full_child_path = "/" + child;
    } else {
        full_child_path = path_filter + "/" + child;
    }
    
    let is_dir = name.len() > full_child_path.len();
    
    if entries.contains(child) {
        if is_dir && !entries[child].is_dir {
            entries[child].is_dir = true;
        }
    } else {
        entries[child] = #{
            name: child, 
            size: if is_dir { 0 } else { file.size },
            is_dir: is_dir
        };
    }
}

let files = [];
for key in entries.keys() {
    files.push(entries[key]);
}

files.sort(|a, b| {
    if a.is_dir && !b.is_dir { return -1; }
    if !a.is_dir && b.is_dir { return 1; }
    if a.name < b.name { -1 }
    else if a.name > b.name { 1 }
    else { 0 }
});

fn format_size(size, human) {
    if !human {
        return size.to_string();
    }
    if size < 1024 {
        return size.to_string() + "B";
    } else if size < 1024 * 1024 {
        let kb = size / 1024;
        return kb.to_string() + "K";
    } else {
        let mb = size / (1024 * 1024);
        return mb.to_string() + "M";
    }
}

if files.len() == 0 {
    print("ls: cannot access '" + path_filter + "': No such file or directory");
    return;
}

if show_long {
    for file in files {
        let size_str = "";
        if file.is_dir {
            size_str = "\x1b[0;90m<dir>\x1b[0m";
        } else {
            size_str = format_size(file.size, human_readable);
        }
        let padding = " ".repeat(8 - if file.is_dir { 5 } else { size_str.len() });
        
        let display = file.name;
        if file.is_dir {
            display = "\x1b[1;34m" + file.name + "/\x1b[0m";
        } else if path_filter == "/usr/bin" || path_filter.starts_with("/usr/bin") {
            display = "\x1b[1;32m" + file.name + "\x1b[0m";
        }
        
        print(padding + size_str + "  " + display);
    }
    print("");
    let dirs = 0;
    let fils = 0;
    for f in files {
        if f.is_dir { dirs += 1; } else { fils += 1; }
    }
    print("\x1b[0;90m" + dirs.to_string() + " dir(s), " + fils.to_string() + " file(s)\x1b[0m");
    
} else if one_per_line {
    for file in files {
        if file.is_dir {
            print(file.name + "/");
        } else {
            print(file.name);
        }
    }
} else {
    let max_len = 0;
    for f in files {
        let len = f.name.len() + if f.is_dir { 1 } else { 0 };
        if len > max_len { max_len = len; }
    }
    
    let col_width = max_len + 2;
    if col_width < 4 { col_width = 4; }
    let num_cols = 60 / col_width;
    if num_cols < 1 { num_cols = 1; }
    
    let col = 0;
    let line = "";
    for file in files {
        let name = file.name;
        let display_len = name.len();
        
        if file.is_dir {
            name = "\x1b[1;34m" + name + "/\x1b[0m";
            display_len += 1;
        } else if path_filter == "/usr/bin" {
            name = "\x1b[1;32m" + name + "\x1b[0m";
        }
        
        let pad = " ".repeat(col_width - display_len);
        line = line + name + pad;
        col += 1;
        
        if col >= num_cols {
            print(line);
            line = "";
            col = 0;
        }
    }
    if line.len() > 0 {
        print(line);
    }
}
</file>

<file path="mkfs/root/usr/bin/sysinfo">
// sysinfo - Display system information
// Usage: sysinfo

import * as fs from "os:fs"
import * as net from "os:net"
import * as sys from "os:sys"
import * as mem from "os:mem"

print("");
print("\x1b[1;35m┌─────────────────────────────────────────────────────────────┐\x1b[0m");
print("\x1b[1;35m│\x1b[0m              \x1b[1;97mBAVY OS System Information\x1b[0m                     \x1b[1;35m│\x1b[0m");
print("\x1b[1;35m├─────────────────────────────────────────────────────────────┤\x1b[0m");

let version = sys.version();
let version_pad = " ".repeat(61 - 16 - version.len());
print("\x1b[1;35m│\x1b[0m  Kernel:       \x1b[1;97m" + version + "\x1b[0m" + version_pad + "\x1b[1;35m│\x1b[0m");

let architecture = sys.arch();
let arch_pad = " ".repeat(61 - 16 - architecture.len());
print("\x1b[1;35m│\x1b[0m  Architecture: \x1b[1;97m" + architecture + "\x1b[0m" + arch_pad + "\x1b[1;35m│\x1b[0m");

print("\x1b[1;35m│\x1b[0m  Mode:         \x1b[1;97mMachine Mode (M-Mode)\x1b[0m                        \x1b[1;35m│\x1b[0m");
print("\x1b[1;35m│\x1b[0m  Runtime:      \x1b[1;97mJavaScript\x1b[0m                                   \x1b[1;35m│\x1b[0m");
print("\x1b[1;35m│\x1b[0m                                                             \x1b[1;35m│\x1b[0m");

if net.available() {
    let ip = net.ip();
    let ip_pad = " ".repeat(61 - 30 - ip.len());
    print("\x1b[1;35m│\x1b[0m  Network:      \x1b[1;32m● Online\x1b[0m  IP: \x1b[1;97m" + ip + "\x1b[0m" + ip_pad + "\x1b[1;35m│\x1b[0m");
} else {
    print("\x1b[1;35m│\x1b[0m  Network:      \x1b[1;31m● Offline\x1b[0m                                  \x1b[1;35m│\x1b[0m");
}

if fs.available() {
    let files = fs.ls();
    let count = files.len().to_string();
    let fs_pad = " ".repeat(61 - 28 - count.len() - 6);
    print("\x1b[1;35m│\x1b[0m  Filesystem:   \x1b[1;32m● Mounted\x1b[0m (" + count + " files)" + fs_pad + "\x1b[1;35m│\x1b[0m");
} else {
    print("\x1b[1;35m│\x1b[0m  Filesystem:   \x1b[1;31m● Not mounted\x1b[0m                              \x1b[1;35m│\x1b[0m");
}

print("\x1b[1;35m│\x1b[0m                                                             \x1b[1;35m│\x1b[0m");

let total_kb = mem.total() / 1024;
let used_kb = mem.used() / 1024;
let mem_str = used_kb.to_string() + " / " + total_kb.to_string() + " KiB";
let mem_pad = " ".repeat(61 - 16 - mem_str.len());
print("\x1b[1;35m│\x1b[0m  Memory:       \x1b[1;97m" + mem_str + "\x1b[0m" + mem_pad + "\x1b[1;35m│\x1b[0m");

let uptime_ms = sys.time();
let uptime_sec = uptime_ms / 1000;
let uptime_str = uptime_sec.to_string() + " seconds";
let uptime_pad = " ".repeat(61 - 16 - uptime_str.len());
print("\x1b[1;35m│\x1b[0m  Uptime:       \x1b[1;97m" + uptime_str + "\x1b[0m" + uptime_pad + "\x1b[1;35m│\x1b[0m");

print("\x1b[1;35m└─────────────────────────────────────────────────────────────┘\x1b[0m");
print("");
</file>

<file path="mkfs/root/usr/bin/write">
// write - Write content to a file
// Usage: write <filename> <content...>

import * as fs from "os:fs"
import * as sys from "os:sys"

if ARGS.len() < 2 {
    print("Usage: write <filename> <content...>");
    print("Example: write test.txt Hello World!");
} else {
    let path = ARGS[0];
    
    // Resolve path relative to CWD
    let filename = "";
    if path.starts_with("/") {
        filename = path;
    } else {
        let cwd = sys.cwd();
        if cwd == "/" {
            filename = "/" + path;
        } else {
            filename = cwd + "/" + path;
        }
    }
    
    // Join remaining args as content
    let content_parts = [];
    let i = 1;
    while i < ARGS.len() {
        content_parts.push(ARGS[i]);
        i += 1;
    }
    let content = join(content_parts, " ");
    
    if fs.write(filename, content) {
        print("\x1b[1;32m✓\x1b[0m Written to " + filename);
    } else {
        print("\x1b[1;31mError:\x1b[0m Failed to write to " + filename);
    }
}
</file>

<file path="mkfs/src/main.rs">
use clap::Parser;
use std::fs::{self, File};
use std::io::{Seek, SeekFrom, Write};
use std::path::PathBuf;

const SECTOR_SIZE: u64 = 512;
const MAGIC: u32 = 0x53465331; // "SFS1"

// Layout
const SEC_SUPER: u64 = 0;
const SEC_MAP_START: u64 = 1;
const SEC_MAP_COUNT: u64 = 64; // Covers ~128MB
const SEC_DIR_START: u64 = 65;
const SEC_DIR_COUNT: u64 = 64; // 1024 files max
const SEC_DATA_START: u64 = 129;

#[derive(Parser)]
struct Args {
    /// Output disk image path
    #[arg(short, long)]
    output: PathBuf,

    /// Directory to import files from
    #[arg(short, long)]
    dir: Option<PathBuf>,

    /// Disk size in MB
    #[arg(short, long, default_value_t = 128)]
    size: u64,
}

#[repr(C, packed)]
struct DirEntry {
    name: [u8; 24],
    size: u32,
    head: u32,
}

fn main() -> std::io::Result<()> {
    let args = Args::parse();
    
    let total_sectors = (args.size * 1024 * 1024) / SECTOR_SIZE;
    println!("Creating SFS image: {:?} ({} MB, {} sectors)", args.output, args.size, total_sectors);

    let mut file = File::create(&args.output)?;
    file.set_len(args.size * 1024 * 1024)?;

    // 1. Write Superblock
    file.seek(SeekFrom::Start(SEC_SUPER * SECTOR_SIZE))?;
    file.write_all(&MAGIC.to_le_bytes())?;
    file.write_all(&(total_sectors as u32).to_le_bytes())?;

    // 2. Initialize Bitmap (Mark system sectors as used)
    let mut bitmap = vec![0u8; (SEC_MAP_COUNT * SECTOR_SIZE) as usize];
    let reserved_sectors = SEC_DATA_START;
    for i in 0..reserved_sectors {
        let byte_idx = (i / 8) as usize;
        let bit_idx = i % 8;
        if byte_idx < bitmap.len() {
            bitmap[byte_idx] |= 1 << bit_idx;
        }
    }
    
    let mut dir_idx = 0u64;
    
    // 3. Import Files from root directory (non-recursive, just files in root)
    if let Some(ref src_dir) = args.dir {
        if src_dir.exists() {
            dir_idx = import_directory(&mut file, &mut bitmap, src_dir, dir_idx, "")?;
        }
    }
    
    // 4. Import files from usr/bin/ subdirectory (scripts with /usr/bin/ prefix)
    if let Some(ref src_dir) = args.dir {
        let usr_bin_dir = src_dir.join("usr").join("bin");
        if usr_bin_dir.exists() {
            println!("\n📜 Importing scripts from usr/bin/...");
            dir_idx = import_directory(&mut file, &mut bitmap, &usr_bin_dir, dir_idx, "/usr/bin/")?;
        }
    }
    
    // 5. Import files from home/ subdirectory (with /home/ prefix)
    if let Some(ref src_dir) = args.dir {
        let home_dir = src_dir.join("home");
        if home_dir.exists() {
            println!("\n🏠 Importing files from home/...");
            dir_idx = import_directory(&mut file, &mut bitmap, &home_dir, dir_idx, "/home/")?;
        }
    }
    
    // 6. Import files from var/log/ subdirectory (with /var/log/ prefix)
    if let Some(ref src_dir) = args.dir {
        let var_log_dir = src_dir.join("var").join("log");
        if var_log_dir.exists() {
            println!("\n📋 Importing files from var/log/...");
            dir_idx = import_directory(&mut file, &mut bitmap, &var_log_dir, dir_idx, "/var/log/")?;
        }
    }
    
    // 7. Import files from etc/init.d/ subdirectory (with /etc/init.d/ prefix)
    if let Some(ref src_dir) = args.dir {
        let etc_init_dir = src_dir.join("etc").join("init.d");
        if etc_init_dir.exists() {
            println!("\n⚙️  Importing files from etc/init.d/...");
            dir_idx = import_directory(&mut file, &mut bitmap, &etc_init_dir, dir_idx, "/etc/init.d/")?;
        }
    }

    // 8. Write Bitmap back to disk
    file.seek(SeekFrom::Start(SEC_MAP_START * SECTOR_SIZE))?;
    file.write_all(&bitmap)?;

    println!("\n✅ Done. {} files imported.", dir_idx);
    Ok(())
}

/// Import all files from a directory into the filesystem image
fn import_directory(
    file: &mut File,
    bitmap: &mut Vec<u8>,
    dir: &PathBuf,
    mut dir_idx: u64,
    prefix: &str,
) -> std::io::Result<u64> {
    for entry in fs::read_dir(dir)? {
        let entry = entry?;
        let path = entry.path();
        
        // Skip subdirectories (except bin/ which is handled separately)
        if path.is_dir() {
            continue;
        }
        
        if path.is_file() {
            let base_name = path.file_name().unwrap().to_str().unwrap();
            let filename = if prefix.is_empty() {
                base_name.to_string()
            } else {
                format!("{}{}", prefix, base_name)
            };
            
            if filename.len() > 23 {
                println!("⚠️  Skipping {}: Name too long (max 23 chars)", filename);
                continue;
            }
            
            // Show different icon for scripts
            let icon = if filename.ends_with(".rhai") { "📜" } else { "📄" };
            println!("  {} Importing {}", icon, filename);
            
            let data = fs::read(&path)?;
            let head_sector = write_data(file, bitmap, &data)?;
            write_dir_entry(file, dir_idx, &filename, data.len() as u32, head_sector)?;
            dir_idx += 1;
        }
    }
    Ok(dir_idx)
}

fn find_free_sector(bitmap: &mut [u8]) -> Option<u32> {
    for (byte_idx, &byte) in bitmap.iter().enumerate() {
        if byte != 0xFF {
            for bit_idx in 0..8 {
                if (byte & (1 << bit_idx)) == 0 {
                    bitmap[byte_idx] |= 1 << bit_idx;
                    return Some((byte_idx * 8 + bit_idx) as u32);
                }
            }
        }
    }
    None
}

fn write_data(file: &mut File, bitmap: &mut [u8], data: &[u8]) -> std::io::Result<u32> {
    if data.is_empty() { return Ok(0); }

    let mut remaining = data;
    let head = find_free_sector(bitmap).expect("Disk full");
    let mut current = head;

    while !remaining.is_empty() {
        let chunk_len = std::cmp::min(remaining.len(), 508);
        let chunk = &remaining[..chunk_len];
        remaining = &remaining[chunk_len..];

        let next = if remaining.is_empty() { 0 } else { find_free_sector(bitmap).expect("Disk full") };

        file.seek(SeekFrom::Start(current as u64 * SECTOR_SIZE))?;
        file.write_all(&next.to_le_bytes())?;
        file.write_all(chunk)?;
        // Pad with zeros if partial sector
        if chunk_len < 508 {
            file.write_all(&vec![0u8; 508 - chunk_len])?;
        }

        current = next;
    }
    Ok(head)
}

fn write_dir_entry(file: &mut File, idx: u64, name: &str, size: u32, head: u32) -> std::io::Result<()> {
    let offset = (SEC_DIR_START * SECTOR_SIZE) + (idx * 32);
    file.seek(SeekFrom::Start(offset))?;

    let mut name_bytes = [0u8; 24];
    let nb = name.as_bytes();
    name_bytes[..nb.len()].copy_from_slice(nb);

    file.write_all(&name_bytes)?;
    file.write_all(&size.to_le_bytes())?;
    file.write_all(&head.to_le_bytes())?;
    Ok(())
}
</file>

<file path="riscv-vm/src/clint.rs">
use std::sync::atomic::{AtomicU32, AtomicU64, AtomicUsize, Ordering};

pub const CLINT_BASE: u64 = 0x0200_0000;
pub const CLINT_SIZE: u64 = 0x10000;

pub const MSIP_OFFSET: u64 = 0x0000;
pub const MTIME_OFFSET: u64 = 0xbff8;
pub const MTIMECMP_OFFSET: u64 = 0x4000;
/// Hart count register offset (read-only, set by emulator at init)
pub const HART_COUNT_OFFSET: u64 = 0x0F00;

/// Maximum number of harts supported by the CLINT.
/// Set high enough to support modern multi-core systems.
pub const MAX_HARTS: usize = 128;

/// Time increment per tick (in timer ticks).
/// This is called every 256 CPU steps (when CPU poll_counter wraps), so we
/// increment by 256 to maintain the same effective timer rate.
/// At 10MHz and ~1 instruction per cycle at ~10MHz CPU, this gives roughly real-time.
const MTIME_INCREMENT: u64 = 256;

/// Core Local Interruptor (CLINT) - Timer and Software Interrupts
///
/// All operations are lock-free using atomic operations.
/// This is safe because:
/// - Each hart primarily accesses its own msip/mtimecmp slots
/// - mtime is shared but only incremented by hart 0
/// - The weak memory ordering matches RISC-V's memory model
pub struct Clint {
    /// Machine timer counter - incremented by tick() every 256 CPU steps.
    mtime: AtomicU64,

    /// Per-hart Machine Software Interrupt Pending bits.
    /// Only bit 0 is meaningful for each entry.
    msip: [AtomicU32; MAX_HARTS],

    /// Per-hart Machine Timer Compare registers.
    /// Timer interrupt fires when mtime >= mtimecmp[hart].
    mtimecmp: [AtomicU64; MAX_HARTS],

    /// Number of harts in the system (set at initialization).
    num_harts: AtomicUsize,
}

impl Clint {
    pub fn new() -> Self {
        // Default to 1 hart, can be set with set_num_harts()
        Self::with_harts(1)
    }
    
    /// Create a new CLINT with a specific hart count.
    pub fn with_harts(num_harts: usize) -> Self {
        // Create arrays of atomics initialized to their default values.
        // Note: We can't use [AtomicXX::new(val); MAX_HARTS] because atomics
        // don't implement Copy. We use consts for array initialization.
        const ZERO_U32: AtomicU32 = AtomicU32::new(0);
        const MAX_U64: AtomicU64 = AtomicU64::new(u64::MAX);

        Self {
            mtime: AtomicU64::new(0),
            msip: [ZERO_U32; MAX_HARTS],
            mtimecmp: [MAX_U64; MAX_HARTS],
            num_harts: AtomicUsize::new(num_harts.min(MAX_HARTS)),
        }
    }
    
    /// Set the number of harts (called by emulator at init).
    pub fn set_num_harts(&self, num_harts: usize) {
        self.num_harts.store(num_harts.min(MAX_HARTS), Ordering::Release);
    }

    /// Get the number of harts (lock-free using atomics).
    #[inline]
    pub fn num_harts(&self) -> usize {
        self.num_harts.load(Ordering::Relaxed)
    }

    /// Returns the current mtime value.
    /// Lock-free for performance.
    #[inline]
    pub fn mtime(&self) -> u64 {
        self.mtime.load(Ordering::Relaxed)
    }

    /// Sets mtime to a specific value (used for snapshot restore).
    pub fn set_mtime(&self, val: u64) {
        self.mtime.store(val, Ordering::Relaxed);
    }

    /// Advance mtime by one tick. Called once per CPU step.
    /// Lock-free using atomic fetch_add.
    #[inline]
    pub fn tick(&self) {
        self.mtime.fetch_add(MTIME_INCREMENT, Ordering::Relaxed);
    }

    /// Backward compatibility: increment is now tick()
    pub fn increment(&self) {
        self.tick();
    }

    pub fn sync_time_micros(&self, _micros: u64) {
        // No-op for deterministic timer
    }

    /// Get msip value for a hart (lock-free using atomics)
    pub fn get_msip(&self, hart: usize) -> u32 {
        if hart < MAX_HARTS {
            self.msip[hart].load(Ordering::Relaxed)
        } else {
            0
        }
    }

    /// Set MSIP value for a specific hart (only bit 0 is meaningful).
    /// Uses Release ordering to ensure any prior writes (e.g., data being
    /// passed to the target hart) are visible before the target sees the interrupt.
    pub fn set_msip(&self, hart: usize, value: u32) {
        if hart < MAX_HARTS {
            // Only bit 0 matters for MSIP
            self.msip[hart].store(value & 1, Ordering::Release);
        }
    }

    /// Get mtimecmp value for a hart (lock-free using atomics)
    pub fn get_mtimecmp(&self, hart: usize) -> u64 {
        if hart < MAX_HARTS {
            self.mtimecmp[hart].load(Ordering::Relaxed)
        } else {
            u64::MAX
        }
    }

    /// Set mtimecmp value for a specific hart (lock-free using atomics)
    pub fn set_mtimecmp(&self, hart: usize, value: u64) {
        if hart < MAX_HARTS {
            self.mtimecmp[hart].store(value, Ordering::Release);
        }
    }

    /// Get the low 32 bits of MTIMECMP for a hart
    pub fn get_mtimecmp_low(&self, hart: usize) -> u32 {
        if hart < MAX_HARTS {
            (self.mtimecmp[hart].load(Ordering::Relaxed) & 0xFFFF_FFFF) as u32
        } else {
            u32::MAX
        }
    }

    /// Get the high 32 bits of MTIMECMP for a hart
    pub fn get_mtimecmp_high(&self, hart: usize) -> u32 {
        if hart < MAX_HARTS {
            (self.mtimecmp[hart].load(Ordering::Relaxed) >> 32) as u32
        } else {
            u32::MAX
        }
    }

    /// Set the low 32 bits of MTIMECMP for a hart.
    /// Uses compare-and-swap to atomically update only the low bits.
    pub fn set_mtimecmp_low(&self, hart: usize, value: u32) {
        if hart >= MAX_HARTS {
            return;
        }

        // Atomic read-modify-write using compare_exchange loop
        loop {
            let current = self.mtimecmp[hart].load(Ordering::Relaxed);
            let new = (current & 0xFFFF_FFFF_0000_0000) | (value as u64);

            match self.mtimecmp[hart].compare_exchange_weak(
                current,
                new,
                Ordering::Release,
                Ordering::Relaxed,
            ) {
                Ok(_) => break,
                Err(_) => continue, // Retry on contention
            }
        }
    }

    /// Set the high 32 bits of MTIMECMP for a hart.
    /// Uses compare-and-swap to atomically update only the high bits.
    pub fn set_mtimecmp_high(&self, hart: usize, value: u32) {
        if hart >= MAX_HARTS {
            return;
        }

        loop {
            let current = self.mtimecmp[hart].load(Ordering::Relaxed);
            let new = (current & 0x0000_0000_FFFF_FFFF) | ((value as u64) << 32);

            match self.mtimecmp[hart].compare_exchange_weak(
                current,
                new,
                Ordering::Release,
                Ordering::Relaxed,
            ) {
                Ok(_) => break,
                Err(_) => continue,
            }
        }
    }

    /// Check if timer interrupt is pending for a specific hart.
    /// Completely lock-free using atomic reads.
    #[inline]
    pub fn is_timer_pending(&self, hart_id: usize) -> bool {
        if hart_id >= MAX_HARTS {
            return false;
        }
        let mtime = self.mtime.load(Ordering::Relaxed);
        let mtimecmp = self.mtimecmp[hart_id].load(Ordering::Relaxed);
        mtime >= mtimecmp
    }

    /// Check if software interrupt is pending for a specific hart.
    /// Lock-free using atomics.
    #[inline]
    pub fn is_msip_pending(&self, hart_id: usize) -> bool {
        if hart_id >= MAX_HARTS {
            return false;
        }
        (self.msip[hart_id].load(Ordering::Relaxed) & 1) != 0
    }

    /// Check all interrupt conditions for a hart.
    /// Returns (msip_pending, timer_pending).
    /// Completely lock-free using atomic reads.
    #[inline]
    pub fn check_interrupts_for_hart(&self, hart_id: usize) -> (bool, bool) {
        if hart_id >= MAX_HARTS {
            return (false, false);
        }
        let mtime = self.mtime.load(Ordering::Relaxed);
        let msip = (self.msip[hart_id].load(Ordering::Relaxed) & 1) != 0;
        let mtimecmp = self.mtimecmp[hart_id].load(Ordering::Relaxed);
        let timer = mtime >= mtimecmp;
        (msip, timer)
    }

    /// Load from the CLINT register space.
    ///
    /// Offsets are relative to `CLINT_BASE`. Only naturally aligned 4- and
    /// 8-byte accesses are architecturally meaningful; other sizes return 0.
    ///
    /// This method is completely lock-free using atomic operations.
    pub fn load(&self, offset: u64, size: u64) -> u64 {
        match (offset, size) {
            // ============================================================
            // MTIME: 64-bit timer register
            // ============================================================
            (MTIME_OFFSET, 8) => self.mtime.load(Ordering::Relaxed),
            (MTIME_OFFSET, 4) => {
                // Low 32 bits
                self.mtime.load(Ordering::Relaxed) & 0xFFFF_FFFF
            }
            (o, 4) if o == MTIME_OFFSET + 4 => {
                // High 32 bits
                self.mtime.load(Ordering::Relaxed) >> 32
            }

            // ============================================================
            // MSIP: Per-hart software interrupt pending (32-bit each)
            // ============================================================
            (o, 4) if o >= MSIP_OFFSET && o < MSIP_OFFSET + (MAX_HARTS as u64 * 4) => {
                let hart_idx = ((o - MSIP_OFFSET) / 4) as usize;
                if hart_idx < MAX_HARTS {
                    self.msip[hart_idx].load(Ordering::Relaxed) as u64
                } else {
                    0
                }
            }

            // ============================================================
            // MTIMECMP: Per-hart timer compare register (64-bit each)
            // ============================================================
            (o, 8) if o >= MTIMECMP_OFFSET && o < MTIMECMP_OFFSET + (MAX_HARTS as u64 * 8) => {
                let hart_idx = ((o - MTIMECMP_OFFSET) / 8) as usize;
                if hart_idx < MAX_HARTS {
                    self.mtimecmp[hart_idx].load(Ordering::Relaxed)
                } else {
                    u64::MAX
                }
            }
            (o, 4) if o >= MTIMECMP_OFFSET && o < MTIMECMP_OFFSET + (MAX_HARTS as u64 * 8) => {
                let hart_idx = ((o - MTIMECMP_OFFSET) / 8) as usize;
                if hart_idx >= MAX_HARTS {
                    return 0;
                }
                let sub_offset = (o - MTIMECMP_OFFSET) % 8;
                let val = self.mtimecmp[hart_idx].load(Ordering::Relaxed);
                match sub_offset {
                    0 => val & 0xFFFF_FFFF,  // Low 32 bits
                    4 => val >> 32,          // High 32 bits
                    _ => 0,                  // Misaligned (shouldn't happen)
                }
            }

            // ============================================================
            // HART_COUNT: Number of harts (read-only, set at init)
            // ============================================================
            (HART_COUNT_OFFSET, 4) | (HART_COUNT_OFFSET, 8) => {
                self.num_harts.load(Ordering::Relaxed) as u64
            }

            // ============================================================
            // Reserved/unmapped: return zero
            // ============================================================
            _ => 0,
        }
    }

    // Snapshot support methods

    /// Get a copy of all MSIP values for snapshot.
    ///
    /// Note: This should only be called when the VM is paused for consistent state.
    pub fn get_msip_array(&self) -> [u32; MAX_HARTS] {
        let mut result = [0u32; MAX_HARTS];
        for i in 0..MAX_HARTS {
            result[i] = self.msip[i].load(Ordering::Relaxed);
        }
        result
    }

    /// Get a copy of all MTIMECMP values for snapshot.
    ///
    /// Note: This should only be called when the VM is paused for consistent state.
    pub fn get_mtimecmp_array(&self) -> [u64; MAX_HARTS] {
        let mut result = [u64::MAX; MAX_HARTS];
        for i in 0..MAX_HARTS {
            result[i] = self.mtimecmp[i].load(Ordering::Relaxed);
        }
        result
    }

    /// Restore MSIP values from snapshot.
    ///
    /// Note: This should only be called when the VM is paused for consistent state.
    pub fn set_msip_array(&self, values: &[u32]) {
        let len = values.len().min(MAX_HARTS);
        for i in 0..len {
            self.msip[i].store(values[i], Ordering::Relaxed);
        }
        // Clear any remaining slots
        for i in len..MAX_HARTS {
            self.msip[i].store(0, Ordering::Relaxed);
        }
    }

    /// Restore MTIMECMP values from snapshot.
    ///
    /// Note: This should only be called when the VM is paused for consistent state.
    pub fn set_mtimecmp_array(&self, values: &[u64]) {
        let len = values.len().min(MAX_HARTS);
        for i in 0..len {
            self.mtimecmp[i].store(values[i], Ordering::Relaxed);
        }
        // Set remaining slots to MAX (no timer interrupt)
        for i in len..MAX_HARTS {
            self.mtimecmp[i].store(u64::MAX, Ordering::Relaxed);
        }
    }

    /// Store into the CLINT register space.
    ///
    /// Offsets are relative to `CLINT_BASE`. Mis-sized or strange offsets are
    /// ignored to keep the device side-effect free for unsupported accesses.
    ///
    /// This method is completely lock-free using atomic operations.
    pub fn store(&self, offset: u64, size: u64, value: u64) {
        match (offset, size) {
            // ============================================================
            // MSIP: Per-hart software interrupt pending (32-bit write)
            // Only bit 0 is meaningful
            // ============================================================
            (o, 4) if o >= MSIP_OFFSET && o < MSIP_OFFSET + (MAX_HARTS as u64 * 4) => {
                let hart_idx = ((o - MSIP_OFFSET) / 4) as usize;
                if hart_idx < MAX_HARTS {
                    // Only bit 0 matters for MSIP (Machine Software Interrupt Pending)
                    self.msip[hart_idx].store((value & 1) as u32, Ordering::Release);
                }
            }

            // ============================================================
            // MTIME: Read-only in this implementation
            // (Timer is driven by tick() calls from the emulator)
            // ============================================================
            (MTIME_OFFSET, _) => {
                // Ignore writes to MTIME
            }
            (o, 4) if o == MTIME_OFFSET + 4 => {
                // Ignore writes to MTIME high bits
            }

            // ============================================================
            // MTIMECMP: Per-hart timer compare (64-bit or split 32-bit)
            // ============================================================
            (o, 8) if o >= MTIMECMP_OFFSET && o < MTIMECMP_OFFSET + (MAX_HARTS as u64 * 8) => {
                // Full 64-bit write
                let hart_idx = ((o - MTIMECMP_OFFSET) / 8) as usize;
                if hart_idx < MAX_HARTS {
                    self.mtimecmp[hart_idx].store(value, Ordering::Release);
                }
            }
            (o, 4) if o >= MTIMECMP_OFFSET && o < MTIMECMP_OFFSET + (MAX_HARTS as u64 * 8) => {
                // Split 32-bit write
                let hart_idx = ((o - MTIMECMP_OFFSET) / 8) as usize;
                if hart_idx >= MAX_HARTS {
                    return;
                }

                let sub_offset = (o - MTIMECMP_OFFSET) % 8;
                match sub_offset {
                    0 => {
                        // Write to low 32 bits - use atomic RMW
                        self.set_mtimecmp_low(hart_idx, value as u32);
                    }
                    4 => {
                        // Write to high 32 bits - use atomic RMW
                        self.set_mtimecmp_high(hart_idx, value as u32);
                    }
                    _ => {
                        // Misaligned access - ignore
                    }
                }
            }

            // ============================================================
            // HART_COUNT: Read-only (set at initialization)
            // ============================================================
            (HART_COUNT_OFFSET, _) => {
                // Ignore writes to HART_COUNT
            }

            // ============================================================
            // Reserved/unmapped: ignore
            // ============================================================
            _ => {}
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    fn assert_send<T: Send>() {}
    fn assert_sync<T: Sync>() {}

    #[test]
    fn clint_is_thread_safe() {
        assert_send::<Clint>();
        assert_sync::<Clint>();
    }

    #[test]
    fn test_mtimecmp_split_access() {
        let clint = Clint::new();

        // Set via 64-bit write
        clint.set_mtimecmp(0, 0x1234_5678_9ABC_DEF0);

        // Read via 32-bit methods
        assert_eq!(clint.get_mtimecmp_low(0), 0x9ABC_DEF0);
        assert_eq!(clint.get_mtimecmp_high(0), 0x1234_5678);

        // Write via 32-bit methods
        clint.set_mtimecmp_low(0, 0x1111_1111);
        assert_eq!(clint.get_mtimecmp(0), 0x1234_5678_1111_1111);

        clint.set_mtimecmp_high(0, 0x2222_2222);
        assert_eq!(clint.get_mtimecmp(0), 0x2222_2222_1111_1111);
    }

    #[test]
    fn test_num_harts_atomic() {
        let clint = Clint::with_harts(4);
        assert_eq!(clint.num_harts(), 4);

        clint.set_num_harts(8);
        assert_eq!(clint.num_harts(), 8);

        // Verify clamping
        clint.set_num_harts(MAX_HARTS + 100);
        assert_eq!(clint.num_harts(), MAX_HARTS);
    }

    #[test]
    fn test_load_msip() {
        let clint = Clint::with_harts(4);

        // Initially all MSIP should be 0
        assert_eq!(clint.load(MSIP_OFFSET, 4), 0);
        assert_eq!(clint.load(MSIP_OFFSET + 4, 4), 0);

        // Set MSIP for hart 1
        clint.set_msip(1, 1);
        assert_eq!(clint.load(MSIP_OFFSET, 4), 0);     // Hart 0: still 0
        assert_eq!(clint.load(MSIP_OFFSET + 4, 4), 1); // Hart 1: now 1
    }

    #[test]
    fn test_load_mtimecmp() {
        let clint = Clint::with_harts(2);

        // Set MTIMECMP for hart 0
        clint.set_mtimecmp(0, 0x1234_5678_9ABC_DEF0);

        // 64-bit read
        assert_eq!(clint.load(MTIMECMP_OFFSET, 8), 0x1234_5678_9ABC_DEF0);

        // 32-bit split reads
        assert_eq!(clint.load(MTIMECMP_OFFSET, 4), 0x9ABC_DEF0);     // Low
        assert_eq!(clint.load(MTIMECMP_OFFSET + 4, 4), 0x1234_5678); // High
    }

    #[test]
    fn test_load_hart_count() {
        let clint = Clint::with_harts(16);
        assert_eq!(clint.load(HART_COUNT_OFFSET, 4), 16);
    }

    #[test]
    fn test_store_msip() {
        let clint = Clint::with_harts(4);

        // Write MSIP for hart 0 via MMIO
        clint.store(MSIP_OFFSET, 4, 1);
        assert_eq!(clint.get_msip(0), 1);

        // Only bit 0 matters
        clint.store(MSIP_OFFSET, 4, 0xFF);
        assert_eq!(clint.get_msip(0), 1); // Stored as 1

        // Clear
        clint.store(MSIP_OFFSET, 4, 0);
        assert_eq!(clint.get_msip(0), 0);
    }

    #[test]
    fn test_store_mtimecmp_64bit() {
        let clint = Clint::with_harts(2);

        // 64-bit write
        clint.store(MTIMECMP_OFFSET, 8, 0x1234_5678_9ABC_DEF0);
        assert_eq!(clint.get_mtimecmp(0), 0x1234_5678_9ABC_DEF0);
    }

    #[test]
    fn test_store_mtimecmp_32bit_split() {
        let clint = Clint::with_harts(2);

        // Start with a known value
        clint.set_mtimecmp(0, 0);

        // Write low 32 bits via MMIO
        clint.store(MTIMECMP_OFFSET, 4, 0xDEAD_BEEF);
        assert_eq!(clint.get_mtimecmp(0), 0x0000_0000_DEAD_BEEF);

        // Write high 32 bits via MMIO
        clint.store(MTIMECMP_OFFSET + 4, 4, 0xCAFE_BABE);
        assert_eq!(clint.get_mtimecmp(0), 0xCAFE_BABE_DEAD_BEEF);
    }

    #[test]
    fn test_store_mtime_readonly() {
        let clint = Clint::with_harts(1);

        let before = clint.mtime();
        clint.store(MTIME_OFFSET, 8, 0xFFFF_FFFF_FFFF_FFFF);
        let after = clint.mtime();

        // MTIME should not change (read-only via MMIO)
        assert_eq!(before, after);
    }

    #[test]
    fn test_check_interrupts_msip() {
        let clint = Clint::with_harts(4);

        // Initially no interrupts
        let (msip, timer) = clint.check_interrupts_for_hart(0);
        assert!(!msip);
        assert!(!timer); // mtimecmp defaults to MAX

        // Set MSIP for hart 0
        clint.set_msip(0, 1);
        let (msip, timer) = clint.check_interrupts_for_hart(0);
        assert!(msip);
        assert!(!timer);

        // Hart 1 should still have no MSIP
        let (msip, _) = clint.check_interrupts_for_hart(1);
        assert!(!msip);
    }

    #[test]
    fn test_check_interrupts_timer() {
        let clint = Clint::with_harts(2);

        // Set timer for hart 0 to trigger at time 1000
        clint.set_mtimecmp(0, 1000);

        // Before deadline
        clint.set_mtime(999);
        let (_, timer) = clint.check_interrupts_for_hart(0);
        assert!(!timer);

        // At deadline
        clint.set_mtime(1000);
        let (_, timer) = clint.check_interrupts_for_hart(0);
        assert!(timer);

        // After deadline
        clint.set_mtime(1001);
        let (_, timer) = clint.check_interrupts_for_hart(0);
        assert!(timer);
    }

    #[test]
    fn test_check_interrupts_out_of_bounds() {
        let clint = Clint::with_harts(4);

        // Out of bounds hart should return (false, false)
        let (msip, timer) = clint.check_interrupts_for_hart(MAX_HARTS);
        assert!(!msip);
        assert!(!timer);

        let (msip, timer) = clint.check_interrupts_for_hart(MAX_HARTS + 100);
        assert!(!msip);
        assert!(!timer);
    }

    #[test]
    fn test_check_interrupts_concurrent() {
        use std::sync::Arc;
        use std::thread;

        let clint = Arc::new(Clint::with_harts(4));
        let mut handles = vec![];

        // Spawn 4 threads simulating 4 harts
        for hart_id in 0..4 {
            let clint_clone = Arc::clone(&clint);
            let handle = thread::spawn(move || {
                for _ in 0..1_000_000 {
                    let _ = clint_clone.check_interrupts_for_hart(hart_id);
                }
            });
            handles.push(handle);
        }

        // All threads should complete without deadlock or panic
        for handle in handles {
            handle.join().unwrap();
        }
    }

    #[test]
    fn test_clint_snapshot_roundtrip() {
        let clint1 = Clint::with_harts(4);

        // Set some state
        clint1.set_mtime(12345);
        clint1.set_msip(0, 1);
        clint1.set_msip(2, 1);
        clint1.set_mtimecmp(0, 1000);
        clint1.set_mtimecmp(1, 2000);
        clint1.set_mtimecmp(3, 3000);

        // Take snapshot
        let mtime = clint1.mtime();
        let msip_array = clint1.get_msip_array();
        let mtimecmp_array = clint1.get_mtimecmp_array();
        let num_harts = clint1.num_harts();

        // Create new CLINT and restore
        let clint2 = Clint::with_harts(num_harts);
        clint2.set_mtime(mtime);
        clint2.set_msip_array(&msip_array);
        clint2.set_mtimecmp_array(&mtimecmp_array);

        // Verify state matches
        assert_eq!(clint2.mtime(), 12345);
        assert_eq!(clint2.get_msip(0), 1);
        assert_eq!(clint2.get_msip(1), 0);
        assert_eq!(clint2.get_msip(2), 1);
        assert_eq!(clint2.get_mtimecmp(0), 1000);
        assert_eq!(clint2.get_mtimecmp(1), 2000);
        assert_eq!(clint2.get_mtimecmp(3), 3000);
    }

    #[test]
    fn test_is_timer_pending() {
        let clint = Clint::with_harts(2);

        // Set timer compare for hart 0
        clint.set_mtimecmp(0, 500);

        // Before the timer fires
        clint.set_mtime(100);
        assert!(!clint.is_timer_pending(0));

        // At the trigger point
        clint.set_mtime(500);
        assert!(clint.is_timer_pending(0));

        // After the trigger point
        clint.set_mtime(600);
        assert!(clint.is_timer_pending(0));

        // Hart 1 should still be pending (default MAX)
        assert!(!clint.is_timer_pending(1));
    }

    #[test]
    fn test_is_msip_pending() {
        let clint = Clint::with_harts(2);

        // Initially not pending
        assert!(!clint.is_msip_pending(0));
        assert!(!clint.is_msip_pending(1));

        // Set MSIP for hart 0
        clint.set_msip(0, 1);
        assert!(clint.is_msip_pending(0));
        assert!(!clint.is_msip_pending(1));

        // Clear MSIP for hart 0
        clint.set_msip(0, 0);
        assert!(!clint.is_msip_pending(0));

        // Out of bounds
        assert!(!clint.is_msip_pending(MAX_HARTS));
    }
}
</file>

<file path="riscv-vm/src/mmu.rs">
use crate::bus::Bus;
use crate::csr::Mode;
use crate::Trap;

#[derive(Clone, Copy, PartialEq, Eq, Debug)]
pub enum AccessType {
    Instruction,
    Load,
    Store,
}

const PAGE_SIZE: u64 = 4096;
const PTE_SIZE: u64 = 8;
const MAX_LEVELS: usize = 4;

/// TLB size (power of 2 for fast modulo)
const TLB_SIZE: usize = 64;
const TLB_MASK: usize = TLB_SIZE - 1;

/// Permission bit masks for packed perm field
pub const PERM_R: u8 = 1 << 0;
pub const PERM_W: u8 = 1 << 1;
pub const PERM_X: u8 = 1 << 2;
pub const PERM_U: u8 = 1 << 3;
pub const PERM_A: u8 = 1 << 4;
pub const PERM_D: u8 = 1 << 5;
pub const PERM_G: u8 = 1 << 6; // Global mapping bit

/// Compact, cache-friendly TLB entry structure.
/// Memory layout: 8 + 8 + 2 + 1 + 1 + 1 + padding = 24 bytes
/// Total TLB: 64 × 24 = 1.5KB (fits in L1 cache)
#[derive(Clone, Copy, Debug)]
pub struct TlbEntry {
    /// Virtual page number (upper bits of VA)
    pub vpn: u64,
    /// Physical page number (translated)
    pub ppn: u64,
    /// Address Space Identifier (16 bits in RISC-V SATP)
    pub asid: u16,
    /// Packed permission bits (R/W/X/U/A/D/G)
    pub perm: u8,
    /// Page level (0=4KB, 1=2MB megapage, 2=1GB gigapage, 3=512GB)
    pub level: u8,
    /// Entry is valid
    pub valid: bool,
}

impl TlbEntry {
    /// Empty/invalid TLB entry constant
    pub const EMPTY: Self = Self {
        vpn: 0,
        ppn: 0,
        asid: 0,
        perm: 0,
        level: 0,
        valid: false,
    };

    /// Check if entry has read permission
    #[inline(always)]
    pub const fn r(&self) -> bool {
        self.perm & PERM_R != 0
    }

    /// Check if entry has write permission
    #[inline(always)]
    pub const fn w(&self) -> bool {
        self.perm & PERM_W != 0
    }

    /// Check if entry has execute permission
    #[inline(always)]
    pub const fn x(&self) -> bool {
        self.perm & PERM_X != 0
    }

    /// Check if entry is user-accessible
    #[inline(always)]
    pub const fn u(&self) -> bool {
        self.perm & PERM_U != 0
    }

    /// Check if entry has been accessed
    #[inline(always)]
    pub const fn a(&self) -> bool {
        self.perm & PERM_A != 0
    }

    /// Check if entry is dirty (written)
    #[inline(always)]
    pub const fn d(&self) -> bool {
        self.perm & PERM_D != 0
    }

    /// Check if entry is global (ignores ASID)
    #[inline(always)]
    pub const fn global(&self) -> bool {
        self.perm & PERM_G != 0
    }

    /// Set the accessed bit
    #[inline(always)]
    pub fn set_a(&mut self) {
        self.perm |= PERM_A;
    }

    /// Set the dirty bit
    #[inline(always)]
    pub fn set_d(&mut self) {
        self.perm |= PERM_D;
    }
}

impl Default for TlbEntry {
    fn default() -> Self {
        Self::EMPTY
    }
}

/// Direct-mapped TLB for fast virtual-to-physical address translation
pub struct Tlb {
    entries: [TlbEntry; TLB_SIZE],
}

impl Tlb {
    pub fn new() -> Self {
        Self {
            entries: [TlbEntry::EMPTY; TLB_SIZE],
        }
    }

    /// Flush entire TLB (SFENCE.VMA with rs1=x0, rs2=x0)
    #[inline]
    pub fn flush(&mut self) {
        for entry in &mut self.entries {
            entry.valid = false;
        }
    }

    /// Flush by ASID (SFENCE.VMA with rs2!=x0)
    /// Global mappings are not flushed.
    #[inline]
    pub fn flush_asid(&mut self, asid: u64) {
        let asid16 = asid as u16;
        for entry in &mut self.entries {
            if !entry.global() && entry.asid == asid16 {
                entry.valid = false;
            }
        }
    }

    /// Flush specific virtual address (SFENCE.VMA with rs1!=x0)
    #[inline]
    pub fn flush_va(&mut self, va: u64) {
        let vpn = va >> 12;
        let idx = (vpn as usize) & TLB_MASK;
        // SAFETY: idx is always < TLB_SIZE due to the bitmask
        let entry = unsafe { self.entries.get_unchecked_mut(idx) };

        if entry.vpn == vpn {
            entry.valid = false;
        }
    }

    /// Flush specific page with ASID check (SFENCE.VMA with rs1!=x0, rs2!=x0)
    #[inline]
    pub fn flush_page(&mut self, vpn: u64, asid: u64) {
        let idx = (vpn as usize) & TLB_MASK;
        // SAFETY: idx is always < TLB_SIZE due to the bitmask
        let entry = unsafe { self.entries.get_unchecked_mut(idx) };

        if entry.valid && entry.vpn == vpn {
            // For page-specific flush, invalidate matching ASID mappings.
            // Global mappings ignore ASID and are treated as matching.
            let match_asid = entry.global() || entry.asid == asid as u16;
            if match_asid {
                entry.valid = false;
            }
        }
    }

    /// Look up a virtual page number in the TLB.
    /// Returns reference to TlbEntry if found, None if miss.
    #[inline(always)]
    pub fn lookup(&self, vpn: u64, asid: u64) -> Option<&TlbEntry> {
        let idx = (vpn as usize) & TLB_MASK;
        // SAFETY: idx is always < TLB_SIZE due to the bitmask
        let entry = unsafe { self.entries.get_unchecked(idx) };

        // Hit if: valid AND VPN matches AND (entry is global OR ASID matches).
        if entry.valid && entry.vpn == vpn && (entry.global() || entry.asid == asid as u16) {
            Some(entry)
        } else {
            None
        }
    }

    /// Fast lookup returning just (ppn, perm) for common case
    #[inline(always)]
    pub fn lookup_fast(&self, vpn: u64, asid: u64) -> Option<(u64, u8)> {
        let idx = (vpn as usize) & TLB_MASK;
        // SAFETY: idx is always < TLB_SIZE due to the bitmask
        let entry = unsafe { self.entries.get_unchecked(idx) };

        if entry.valid && entry.vpn == vpn && (entry.global() || entry.asid == asid as u16) {
            Some((entry.ppn, entry.perm))
        } else {
            None
        }
    }

    /// Look up with level awareness (for superpages)
    #[inline]
    pub fn lookup_with_level(&self, vpn: u64, asid: u64) -> Option<(u64, u8, u8)> {
        let idx = (vpn as usize) & TLB_MASK;
        // SAFETY: idx is always < TLB_SIZE due to the bitmask
        let entry = unsafe { self.entries.get_unchecked(idx) };

        if entry.valid && entry.vpn == vpn && (entry.global() || entry.asid == asid as u16) {
            Some((entry.ppn, entry.perm, entry.level))
        } else {
            None
        }
    }

    /// Insert a TLB entry. Overwrites any existing entry at the same index.
    #[inline(always)]
    pub fn insert(&mut self, entry: TlbEntry) {
        let idx = (entry.vpn as usize) & TLB_MASK;
        // SAFETY: idx is always < TLB_SIZE due to the bitmask
        unsafe {
            *self.entries.get_unchecked_mut(idx) = entry;
        }
    }

    /// Insert a translation with explicit parameters.
    /// Overwrites any existing entry at the same index (direct-mapped).
    #[inline]
    pub fn insert_translation(
        &mut self,
        vpn: u64,
        ppn: u64,
        perm: u8,
        level: u8,
        asid: u16,
    ) {
        let idx = (vpn as usize) & TLB_MASK;
        // SAFETY: idx is always < TLB_SIZE due to the bitmask
        unsafe {
            *self.entries.get_unchecked_mut(idx) = TlbEntry {
                vpn,
                ppn,
                asid,
                perm,
                level,
                valid: true,
            };
        }
    }
}

/// Sv39/Sv48 translation + A/D bit updates.
///
/// `addr` is a virtual address. Returns the translated physical address or a
/// `Trap` corresponding to the appropriate page/access fault.
pub fn translate(
    bus: &dyn Bus,
    tlb: &mut Tlb,
    mode: Mode,
    satp: u64,
    mstatus: u64,
    addr: u64,
    access_type: AccessType,
) -> Result<u64, Trap> {
    // No translation in Machine mode (always Bare).
    if mode == Mode::Machine {
        return Ok(addr);
    }

    let satp_mode = (satp >> 60) & 0xF;
    let current_asid = (satp >> 44) & 0xFFFF;

    let (levels, va_bits, vpn_full_mask): (usize, u64, u64) = match satp_mode {
        0 => {
            // Bare: no translation.
            return Ok(addr);
        }
        8 => {
            // Sv39
            let levels = 3;
            let va_bits = 39;
            let vpn_full_mask = (1u64 << (9 * levels)) - 1;
            (levels, va_bits, vpn_full_mask)
        }
        9 => {
            // Sv48 (supported by this MMU, though not required for virt).
            let levels = 4;
            let va_bits = 48;
            let vpn_full_mask = (1u64 << (9 * levels)) - 1;
            (levels, va_bits, vpn_full_mask)
        }
        _ => {
            // Unsupported mode: treat as Bare.
            return Ok(addr);
        }
    };

    // Check canonical form of the virtual address for the configured VA width.
    let sign_bit = va_bits - 1;
    let upper_mask = !((1u64 << va_bits) - 1);
    let sign = (addr >> sign_bit) & 1;
    let expected_upper = if sign == 1 { upper_mask } else { 0 };
    if (addr & upper_mask) != expected_upper {
        return Err(page_fault(access_type, addr));
    }

    let vpn_full = (addr >> 12) & vpn_full_mask;

    // TLB hit path.
    if let Some(entry) = tlb.lookup(vpn_full, current_asid) {
        if check_permission_tlb(mode, mstatus, entry, access_type) {
            // For now we do not lazily update A/D on TLB hits – page table
            // entries are already marked by the walk that inserted this entry.
            let offset = addr & 0xFFF;
            let pa = (entry.ppn << 12) | offset;
            return Ok(pa);
        } else {
            return Err(page_fault(access_type, addr));
        }
    }

    // Page table walk on TLB miss.
    let mut vpn = [0u64; MAX_LEVELS];
    for level in 0..levels {
        vpn[level] = (addr >> (12 + 9 * level as u64)) & 0x1FF;
    }

    let root_ppn = satp & ((1u64 << 44) - 1);
    let mut a = root_ppn * PAGE_SIZE;

    for i in (0..levels).rev() {
        let pte_addr = a + vpn[i] * PTE_SIZE;

        let pte = match bus.load(pte_addr, 8) {
            Ok(val) => val,
            Err(_) => return Err(access_fault(access_type, addr)),
        };

        let v = (pte >> 0) & 1;
        let r = (pte >> 1) & 1;
        let w = (pte >> 2) & 1;
        let x = (pte >> 3) & 1;

        // Invalid or malformed.
        if v == 0 || (r == 0 && w == 1) {
            return Err(page_fault(access_type, addr));
        }

        // Pointer to next level if R=X=0.
        if r == 0 && x == 0 {
            if i == 0 {
                return Err(page_fault(access_type, addr));
            }
            let ppn = (pte >> 10) & 0xFFF_FFFF_FFFF;
            a = ppn * PAGE_SIZE;
            continue;
        }

        // Leaf PTE - extract permission bits into packed format
        let mut perm: u8 = 0;
        if r != 0 {
            perm |= PERM_R;
        }
        if w != 0 {
            perm |= PERM_W;
        }
        if x != 0 {
            perm |= PERM_X;
        }
        if (pte >> 4) & 1 != 0 {
            perm |= PERM_U;
        }
        if (pte >> 5) & 1 != 0 {
            perm |= PERM_G;
        }
        if (pte >> 6) & 1 != 0 {
            perm |= PERM_A;
        }
        if (pte >> 7) & 1 != 0 {
            perm |= PERM_D;
        }

        let mut entry = TlbEntry {
            vpn: vpn_full,
            ppn: (pte >> 10) & 0xFFF_FFFF_FFFF,
            asid: current_asid as u16,
            perm,
            level: i as u8,
            valid: true,
        };

        if !check_permission_tlb(mode, mstatus, &entry, access_type) {
            return Err(page_fault(access_type, addr));
        }

        // Superpage alignment checks (Sv39/48 spec).
        if i > 0 {
            let ppn_mask = (1 << (9 * i)) - 1;
            let ppn = (pte >> 10) & 0xFFF_FFFF_FFFF;
            if (ppn & ppn_mask) != 0 {
                return Err(page_fault(access_type, addr));
            }
        }

        // A/D bit updates: set in memory and in the cached entry.
        let mut new_pte = pte;
        let mut update = false;

        if !entry.a() {
            new_pte |= 1 << 6;
            entry.set_a();
            update = true;
        }
        if matches!(access_type, AccessType::Store) && !entry.d() {
            new_pte |= 1 << 7;
            entry.set_d();
            update = true;
        }

        if update {
            if bus.store(pte_addr, 8, new_pte).is_err() {
                return Err(access_fault(access_type, addr));
            }
        }

        let offset_in_page = addr & 0xFFF;

        // Construct final PPN, filling low parts from the VA on superpages.
        let ppn = (pte >> 10) & 0xFFF_FFFF_FFFF;
        let vpn_mask = (1 << (9 * i)) - 1;
        let result_ppn = (ppn & !vpn_mask) | ((addr >> 12) & vpn_mask);

        entry.ppn = result_ppn;
        tlb.insert(entry);

        let pa = (result_ppn << 12) | offset_in_page;
        return Ok(pa);
    }

    Err(page_fault(access_type, addr))
}

#[inline(always)]
fn check_permission_tlb(mode: Mode, mstatus: u64, entry: &TlbEntry, access_type: AccessType) -> bool {
    let mxr = (mstatus >> 19) & 1;
    let sum = (mstatus >> 18) & 1;

    match mode {
        Mode::Supervisor => {
            if entry.u() {
                if matches!(access_type, AccessType::Instruction) {
                    return false;
                }
                if sum == 0 {
                    return false;
                }
            }
        }
        Mode::User => {
            if !entry.u() {
                return false;
            }
        }
        Mode::Machine => {}
    }

    match access_type {
        AccessType::Instruction => entry.x(),
        AccessType::Store => entry.w(),
        AccessType::Load => {
            if entry.r() {
                true
            } else {
                mxr == 1 && entry.x()
            }
        }
    }
}

#[inline]
fn page_fault(access_type: AccessType, addr: u64) -> Trap {
    match access_type {
        AccessType::Instruction => Trap::InstructionPageFault(addr),
        AccessType::Load => Trap::LoadPageFault(addr),
        AccessType::Store => Trap::StorePageFault(addr),
    }
}

#[inline]
fn access_fault(access_type: AccessType, addr: u64) -> Trap {
    match access_type {
        AccessType::Instruction => Trap::InstructionAccessFault(addr),
        AccessType::Load => Trap::LoadAccessFault(addr),
        AccessType::Store => Trap::StoreAccessFault(addr),
    }
}
</file>

<file path="riscv-vm/src/uart.rs">
use crate::dram::MemoryError;
use std::collections::VecDeque;
use std::sync::Mutex;

pub const UART_BASE: u64 = 0x1000_0000;
pub const UART_SIZE: u64 = 0x100;

// Registers (offset)
const RBR: u64 = 0x00; // Receiver Buffer (Read)
const THR: u64 = 0x00; // Transmitter Holding (Write)
const IER: u64 = 0x01; // Interrupt Enable
const IIR: u64 = 0x02; // Interrupt Identity (Read)
const FCR: u64 = 0x02; // FIFO Control (Write)
const LCR: u64 = 0x03; // Line Control
const MCR: u64 = 0x04; // Modem Control
const LSR: u64 = 0x05; // Line Status
const MSR: u64 = 0x06; // Modem Status
const SCR: u64 = 0x07; // Scratch

/// RX path state (host → guest)
struct RxState {
    /// Input FIFO (keyboard/serial input from host)
    fifo: VecDeque<u8>,
}

/// TX path state (guest → host)
struct TxState {
    /// Output FIFO (console output to host)
    fifo: VecDeque<u8>,
    /// THRE interrupt pending flag
    thre_ip: bool,
}

/// Control registers (shared, less frequent access)
struct UartRegs {
    ier: u8,      // Interrupt Enable Register
    iir: u8,      // Interrupt Identification Register (read-only computed)
    fcr: u8,      // FIFO Control Register
    lcr: u8,      // Line Control Register
    mcr: u8,      // Modem Control Register
    lsr: u8,      // Line Status Register
    msr: u8,      // Modem Status Register
    scr: u8,      // Scratch Register
    dll: u8,      // Divisor Latch Low
    dlm: u8,      // Divisor Latch High
    interrupting: bool,
}

impl RxState {
    fn new() -> Self {
        Self { fifo: VecDeque::new() }
    }
}

impl TxState {
    fn new() -> Self {
        Self {
            fifo: VecDeque::new(),
            thre_ip: true, // Starts empty
        }
    }
}

impl UartRegs {
    fn new() -> Self {
        Self {
            ier: 0x00,
            iir: 0x01, // No interrupt pending
            fcr: 0x00,
            lcr: 0x00,
            mcr: 0x00,
            lsr: 0x60, // TX empty
            msr: 0x00,
            scr: 0x00,
            dll: 0x00,
            dlm: 0x00,
            interrupting: false,
        }
    }
}

pub struct Uart {
    /// RX path: input from host to guest
    rx: Mutex<RxState>,
    
    /// TX path: output from guest to host
    tx: Mutex<TxState>,
    
    /// Control registers (shared, accessed for config)
    regs: Mutex<UartRegs>,
}

impl Uart {
    pub fn new() -> Self {
        Self {
            rx: Mutex::new(RxState::new()),
            tx: Mutex::new(TxState::new()),
            regs: Mutex::new(UartRegs::new()),
        }
    }

    /// Internal helper to update interrupt state
    /// Lock order convention: regs must be locked first, then rx, then tx
    fn update_interrupts_internal(regs: &mut UartRegs, _rx: &RxState, tx: &TxState) {
        regs.interrupting = false;
        regs.iir = 0x01; // No interrupt pending

        // Priority 1: Receiver Line Status (not implemented extensively)

        // Priority 2: Received Data Available
        if (regs.lsr & 0x01) != 0 && (regs.ier & 0x01) != 0 {
            regs.interrupting = true;
            regs.iir = 0x04;
            return;
        }

        // Priority 3: THRE
        if tx.thre_ip && (regs.ier & 0x02) != 0 {
            regs.interrupting = true;
            regs.iir = 0x02;
        }
    }

    /// Check if the UART is currently signaling an interrupt (only locks regs)
    pub fn is_interrupting(&self) -> bool {
        self.regs.lock().unwrap().interrupting
    }

    // Snapshot support methods

    /// Get input FIFO contents for snapshot
    pub fn get_input(&self) -> Vec<u8> {
        self.rx.lock().unwrap().fifo.iter().copied().collect()
    }

    /// Get output FIFO contents for snapshot
    pub fn get_output(&self) -> Vec<u8> {
        self.tx.lock().unwrap().fifo.iter().copied().collect()
    }

    /// Get the number of bytes pending in the output FIFO
    pub fn output_len(&self) -> usize {
        self.tx.lock().unwrap().fifo.len()
    }

    /// Get all register values for snapshot
    pub fn get_registers(&self) -> (u8, u8, u8, u8, u8, u8, u8, u8, u8, u8) {
        let regs = self.regs.lock().unwrap();
        (regs.ier, regs.iir, regs.fcr, regs.lcr, regs.mcr,
         regs.lsr, regs.msr, regs.scr, regs.dll, regs.dlm)
    }

    /// Restore input FIFO from snapshot
    pub fn set_input(&self, values: &[u8]) {
        let mut regs = self.regs.lock().unwrap();
        let mut rx = self.rx.lock().unwrap();
        
        rx.fifo.clear();
        for &v in values {
            rx.fifo.push_back(v);
        }
        // Update LSR data ready bit
        if !rx.fifo.is_empty() {
            regs.lsr |= 0x01;
        } else {
            regs.lsr &= !0x01;
        }
    }

    /// Restore output FIFO from snapshot
    pub fn set_output(&self, values: &[u8]) {
        let mut tx = self.tx.lock().unwrap();
        tx.fifo.clear();
        for &v in values {
            tx.fifo.push_back(v);
        }
    }

    /// Restore register values from snapshot
    pub fn set_registers(&self, ier: u8, iir: u8, fcr: u8, lcr: u8, mcr: u8,
                         lsr: u8, msr: u8, scr: u8, dll: u8, dlm: u8) {
        let mut regs = self.regs.lock().unwrap();
        let rx = self.rx.lock().unwrap();
        let tx = self.tx.lock().unwrap();
        
        regs.ier = ier;
        regs.iir = iir;
        regs.fcr = fcr;
        regs.lcr = lcr;
        regs.mcr = mcr;
        regs.lsr = lsr;
        regs.msr = msr;
        regs.scr = scr;
        regs.dll = dll;
        regs.dlm = dlm;
        Self::update_interrupts_internal(&mut regs, &rx, &tx);
    }

    pub fn load(&self, offset: u64, size: u64) -> Result<u64, MemoryError> {
        if size != 1 {
            return Ok(0);
        }

        match offset {
            RBR => {
                let mut regs = self.regs.lock().unwrap();
                if (regs.lcr & 0x80) != 0 {
                    // DLAB mode: return DLL
                    Ok(regs.dll as u64)
                } else {
                    // Normal mode: read from RX FIFO
                    let mut rx = self.rx.lock().unwrap();
                    let byte = rx.fifo.pop_front().unwrap_or(0);

                    // Update LSR based on FIFO state
                    if rx.fifo.is_empty() {
                        regs.lsr &= !0x01; // Clear Data Ready
                    }

                    let tx = self.tx.lock().unwrap();
                    Self::update_interrupts_internal(&mut regs, &rx, &tx);
                    Ok(byte as u64)
                }
            }
            IER => {
                let regs = self.regs.lock().unwrap();
                if (regs.lcr & 0x80) != 0 {
                    Ok(regs.dlm as u64)
                } else {
                    Ok(regs.ier as u64)
                }
            }
            IIR => {
                let mut regs = self.regs.lock().unwrap();
                let val = regs.iir;
                // Clear THRE interrupt if it was the pending one
                if (val & 0x0F) == 0x02 {
                    let rx = self.rx.lock().unwrap();
                    let mut tx = self.tx.lock().unwrap();
                    tx.thre_ip = false;
                    Self::update_interrupts_internal(&mut regs, &rx, &tx);
                    log::trace!("[UART] IIR read cleared THRE ip");
                } else {
                    log::trace!("[UART] IIR read val={:x}", val);
                }
                Ok(val as u64)
            }
            LCR => Ok(self.regs.lock().unwrap().lcr as u64),
            MCR => Ok(self.regs.lock().unwrap().mcr as u64),
            LSR => Ok(self.regs.lock().unwrap().lsr as u64),
            MSR => Ok(self.regs.lock().unwrap().msr as u64),
            SCR => Ok(self.regs.lock().unwrap().scr as u64),
            _ => Ok(0),
        }
    }

    pub fn store(&self, offset: u64, size: u64, value: u64) -> Result<(), MemoryError> {
        if size != 1 {
            return Ok(());
        }
        let val = (value & 0xff) as u8;

        match offset {
            THR => {
                let mut regs = self.regs.lock().unwrap();
                if (regs.lcr & 0x80) != 0 {
                    regs.dll = val;
                } else {
                    // Write to TX FIFO
                    log::trace!(
                        "[UART] TX '{}' (0x{:02x})",
                        if val.is_ascii_graphic() {
                            val as char
                        } else {
                            '.'
                        },
                        val
                    );
                    let rx = self.rx.lock().unwrap();
                    let mut tx = self.tx.lock().unwrap();
                    tx.fifo.push_back(val);

                    // THR is instantly "transmitted", so THRE stays set
                    regs.lsr |= 0x20;
                    tx.thre_ip = true; // Re-assert THRE interrupt

                    Self::update_interrupts_internal(&mut regs, &rx, &tx);
                }
            }
            IER => {
                let mut regs = self.regs.lock().unwrap();
                if (regs.lcr & 0x80) != 0 {
                    regs.dlm = val;
                } else {
                    regs.ier = val;
                    let rx = self.rx.lock().unwrap();
                    let tx = self.tx.lock().unwrap();
                    Self::update_interrupts_internal(&mut regs, &rx, &tx);
                }
            }
            FCR => {
                let mut regs = self.regs.lock().unwrap();
                regs.fcr = val;

                if (val & 0x02) != 0 {
                    // Clear RX FIFO
                    let mut rx = self.rx.lock().unwrap();
                    rx.fifo.clear();
                    regs.lsr &= !0x01;
                }
                if (val & 0x04) != 0 {
                    // Clear TX FIFO
                    let mut tx = self.tx.lock().unwrap();
                    tx.fifo.clear();
                    regs.lsr |= 0x60;
                }
            }
            LCR => self.regs.lock().unwrap().lcr = val,
            MCR => self.regs.lock().unwrap().mcr = val,
            LSR => {
                // Usually read-only, but factory test mode might write. Ignore.
            }
            MSR => {
                // Read-only.
            }
            SCR => self.regs.lock().unwrap().scr = val,
            _ => {}
        }
        Ok(())
    }

    // Host I/O methods

    /// Push input byte from host (lock-free for TX path)
    pub fn push_input(&self, byte: u8) {
        let mut regs = self.regs.lock().unwrap();
        let mut rx = self.rx.lock().unwrap();

        rx.fifo.push_back(byte);
        regs.lsr |= 0x01; // Data Ready

        let tx = self.tx.lock().unwrap();
        Self::update_interrupts_internal(&mut regs, &rx, &tx);
    }

    /// Pop output byte (only locks TX path)
    pub fn pop_output(&self) -> Option<u8> {
        self.tx.lock().unwrap().fifo.pop_front()
    }

    /// Drain all output (only locks TX path)
    pub fn drain_output(&self) -> Vec<u8> {
        self.tx.lock().unwrap().fifo.drain(..).collect()
    }

    /// Check if has output (only locks TX path)
    pub fn has_output(&self) -> bool {
        !self.tx.lock().unwrap().fifo.is_empty()
    }

    /// Push a byte directly to the output queue (only locks TX path)
    pub fn push_output(&self, byte: u8) {
        self.tx.lock().unwrap().fifo.push_back(byte);
    }

    /// Push a string directly to the output queue
    pub fn push_output_str(&self, s: &str) {
        let mut tx = self.tx.lock().unwrap();
        for b in s.bytes() {
            tx.fifo.push_back(b);
        }
    }

    /// Clear interrupt flag (only locks regs)
    pub fn clear_interrupt(&self) {
        self.regs.lock().unwrap().interrupting = false;
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use std::sync::Arc;
    use std::thread;
    use std::time::{Duration, Instant};

    #[test]
    fn test_basic_io() {
        let uart = Uart::new();
        
        // Push input
        uart.push_input(b'A');
        assert!(uart.get_input().contains(&b'A'));
        
        // Push output
        uart.push_output(b'B');
        assert_eq!(uart.pop_output(), Some(b'B'));
        assert_eq!(uart.pop_output(), None);
    }

    #[test]
    fn test_concurrent_input_output() {
        let uart = Arc::new(Uart::new());
        let uart_in = Arc::clone(&uart);
        let uart_out = Arc::clone(&uart);

        // Input thread
        let input_handle = thread::spawn(move || {
            for i in 0..1000 {
                uart_in.push_input(i as u8);
            }
        });

        // Output thread (should not block input)
        let output_handle = thread::spawn(move || {
            let mut count = 0;
            for _ in 0..10000 {
                if uart_out.pop_output().is_some() {
                    count += 1;
                }
            }
            count
        });

        input_handle.join().unwrap();
        output_handle.join().unwrap();

        // Input should have completed without blocking
        // (if single lock, there would be contention)
    }

    #[test]
    fn test_drain_doesnt_block_input() {
        let uart = Arc::new(Uart::new());

        // Fill output buffer
        for i in 0..100 {
            uart.push_output(i);
        }

        let uart_drain = Arc::clone(&uart);
        let uart_input = Arc::clone(&uart);

        let start = Instant::now();

        // Drain in one thread
        let drain_handle = thread::spawn(move || {
            thread::sleep(Duration::from_millis(10));
            uart_drain.drain_output()
        });

        // Push input concurrently
        for i in 0..100 {
            uart_input.push_input(i);
        }

        let input_time = start.elapsed();
        drain_handle.join().unwrap();

        // Input should complete quickly (< 50ms) if not blocked by drain
        assert!(input_time < Duration::from_millis(50));
    }

    #[test]
    fn test_output_operations_independent() {
        let uart = Arc::new(Uart::new());
        
        // Fill with some output
        for i in 0..10 {
            uart.push_output(i);
        }
        
        let uart1 = Arc::clone(&uart);
        let uart2 = Arc::clone(&uart);
        
        // Two threads doing output operations should not deadlock
        let h1 = thread::spawn(move || {
            for _ in 0..100 {
                uart1.has_output();
                uart1.pop_output();
            }
        });
        
        let h2 = thread::spawn(move || {
            for i in 0..100 {
                uart2.push_output(i as u8);
            }
        });
        
        h1.join().unwrap();
        h2.join().unwrap();
    }

    #[test]
    fn test_register_access() {
        let uart = Uart::new();
        
        // Write to SCR (scratch register)
        uart.store(SCR, 1, 0x42).unwrap();
        assert_eq!(uart.load(SCR, 1).unwrap(), 0x42);
        
        // Test LCR
        uart.store(LCR, 1, 0x03).unwrap();
        assert_eq!(uart.load(LCR, 1).unwrap(), 0x03);
    }

    #[test]
    fn test_dlab_mode() {
        let uart = Uart::new();
        
        // Enable DLAB
        uart.store(LCR, 1, 0x80).unwrap();
        
        // Write divisor latch
        uart.store(THR, 1, 0x12).unwrap(); // DLL
        uart.store(IER, 1, 0x34).unwrap(); // DLM
        
        // Read back
        assert_eq!(uart.load(RBR, 1).unwrap(), 0x12);
        assert_eq!(uart.load(IER, 1).unwrap(), 0x34);
        
        // Disable DLAB
        uart.store(LCR, 1, 0x00).unwrap();
    }

    #[test]
    fn test_fifo_clear() {
        let uart = Uart::new();
        
        // Add some input
        uart.push_input(b'A');
        uart.push_input(b'B');
        
        // Add some output
        uart.push_output(b'X');
        uart.push_output(b'Y');
        
        // Clear RX FIFO (bit 1)
        uart.store(FCR, 1, 0x02).unwrap();
        assert!(uart.get_input().is_empty());
        
        // Output should still be there
        assert_eq!(uart.get_output().len(), 2);
        
        // Clear TX FIFO (bit 2)
        uart.store(FCR, 1, 0x04).unwrap();
        assert!(uart.get_output().is_empty());
    }

    #[test]
    fn test_snapshot_restore() {
        let uart = Uart::new();
        
        // Set up some state
        uart.push_input(b'A');
        uart.push_output(b'B');
        uart.store(SCR, 1, 0x55).unwrap();
        
        // Get snapshot
        let input = uart.get_input();
        let output = uart.get_output();
        let regs = uart.get_registers();
        
        // Create new UART and restore
        let uart2 = Uart::new();
        uart2.set_input(&input);
        uart2.set_output(&output);
        uart2.set_registers(regs.0, regs.1, regs.2, regs.3, regs.4,
                           regs.5, regs.6, regs.7, regs.8, regs.9);
        
        // Verify
        assert_eq!(uart2.get_input(), vec![b'A']);
        assert_eq!(uart2.get_output(), vec![b'B']);
        assert_eq!(uart2.load(SCR, 1).unwrap(), 0x55);
    }
}
</file>

<file path="riscv-vm/src/worker.rs">
//! Web Worker entry point for WASM SMP.
//!
//! This module provides the Rust entry point that runs inside each Web Worker,
//! executing CPU instructions in parallel with other workers and the main thread.
//!
//! ## Architecture
//!
//! - Each worker runs one secondary hart (1, 2, 3, ...)
//! - Hart 0 runs on the main thread (handles I/O)
//! - Workers share DRAM and CLINT via SharedArrayBuffer
//! - Workers do NOT have access to VirtIO devices (disk, network)
//! - Inter-hart communication uses CLINT MSIP for IPIs
//!
//! ## Memory Layout
//!
//! The SharedArrayBuffer is laid out as:
//! - Control region (4KB): halt flags, hart count
//! - CLINT region (64KB): mtime, msip[], mtimecmp[]
//! - DRAM region: kernel memory

#[cfg(target_arch = "wasm32")]
use wasm_bindgen::prelude::*;
#[cfg(target_arch = "wasm32")]
use js_sys::SharedArrayBuffer;
#[cfg(target_arch = "wasm32")]
use crate::shared_mem::{self, wasm::{SharedClint, SharedControl}};
#[cfg(target_arch = "wasm32")]
use crate::bus::SystemBus;
#[cfg(target_arch = "wasm32")]
use crate::cpu::Cpu;
#[cfg(target_arch = "wasm32")]
use crate::Trap;

/// Result of executing a batch of instructions.
#[cfg(target_arch = "wasm32")]
#[wasm_bindgen]
#[derive(Clone, Copy, PartialEq, Eq)]
pub enum WorkerStepResult {
    /// Continue executing - call step_batch again
    Continue = 0,
    /// Halt requested via control region
    Halted = 1,
    /// Shutdown requested by guest (RequestedTrap)
    Shutdown = 2,
    /// Fatal error occurred
    Error = 3,
}

/// Worker state stored in JS (passed back to Rust on each step_batch call).
/// This avoids recreating CPU/bus state on every call.
#[cfg(target_arch = "wasm32")]
#[wasm_bindgen]
pub struct WorkerState {
    cpu: Cpu,
    bus: SystemBus,
    control: SharedControl,
    clint: SharedClint,
    hart_id: usize,
    step_count: u64,
    /// Cached flag: have we received the "workers can start" signal?
    /// Once set to true, we never need to check again (reduces atomic ops).
    workers_started: bool,
}

#[cfg(target_arch = "wasm32")]
#[wasm_bindgen]
impl WorkerState {
    /// Create a new worker state for a secondary hart.
    #[wasm_bindgen(constructor)]
    pub fn new(hart_id: usize, shared_mem: JsValue, entry_pc: u64) -> WorkerState {
        // Convert JsValue to SharedArrayBuffer
        let sab: SharedArrayBuffer = shared_mem.unchecked_into();
        
        // Create shared control and CLINT accessors
        let control = SharedControl::new(&sab);
        let clint = SharedClint::new(&sab);
        
        // Create bus view of shared DRAM
        let dram_offset = shared_mem::dram_offset();
        let shared_clint_for_bus = SharedClint::new(&sab);
        // Workers read from shared UART input (is_worker = true)
        let bus = SystemBus::from_shared_buffer(sab, dram_offset, shared_clint_for_bus, true);
        
        // Create CPU for this hart
        let cpu = Cpu::new(entry_pc, hart_id as u64);
        
        web_sys::console::log_1(&JsValue::from_str(
            &format!("[Worker {}] Initialized at PC=0x{:x}", hart_id, entry_pc)));
        
        WorkerState {
            cpu,
            bus,
            control,
            clint,
            hart_id,
            step_count: 0,
            workers_started: false, // Will be cached on first check
        }
    }
    
    /// Execute a batch of instructions and return.
    /// 
    /// This is designed to be called repeatedly from JavaScript, allowing
    /// the event loop to yield between batches. This prevents the worker
    /// from blocking indefinitely and allows it to respond to messages.
    ///
    /// Performance optimization: We reduce atomic operations by:
    /// - Only checking halt signals every HALT_CHECK_INTERVAL instructions
    /// - Only checking interrupts every INTERRUPT_CHECK_INTERVAL instructions
    /// - Doing a full interrupt check at the end of each batch
    ///
    /// Returns a WorkerStepResult indicating whether to continue, halt, etc.
    pub fn step_batch(&mut self, batch_size: u32) -> WorkerStepResult {
        // Check intervals - reduce atomic operations overhead
        // Higher values = better performance, but less responsive to signals
        const HALT_CHECK_INTERVAL: u32 = 10_000;
        const INTERRUPT_CHECK_INTERVAL: u32 = 5_000;
        
        // Check for halt request first (one atomic check at batch start)
        if self.control.should_stop() {
            web_sys::console::log_1(&JsValue::from_str(
                &format!("[Worker {}] Halt detected after {} steps", 
                    self.hart_id, self.step_count)));
            return WorkerStepResult::Halted;
        }
        
        // Wait for main thread to signal that workers can start.
        // This ensures hart 0 boots first and sets up memory before
        // secondary harts start executing kernel code.
        // 
        // Optimization: Cache the result once workers are allowed to start.
        // This eliminates an atomic operation per batch after startup.
        if !self.workers_started {
            if !self.control.can_workers_start() {
                // Still parked - return Continue to keep polling
                return WorkerStepResult::Continue;
            }
            // Workers can start - cache this permanently
            self.workers_started = true;
        }
        
        // Execute batch of instructions with reduced atomic operation frequency
        for i in 0..batch_size {
            // Periodic halt check (much less frequent than per-instruction)
            if i > 0 && i % HALT_CHECK_INTERVAL == 0 {
                if self.control.should_stop() {
                    web_sys::console::log_1(&JsValue::from_str(
                        &format!("[Worker {}] Halt detected during batch after {} steps", 
                            self.hart_id, self.step_count)));
                    return WorkerStepResult::Halted;
                }
            }
            
            // Periodic interrupt check (less frequent than halt check)
            if i > 0 && i % INTERRUPT_CHECK_INTERVAL == 0 {
                self.deliver_interrupts();
            }
            
            match self.cpu.step(&self.bus) {
                Ok(()) => {
                    self.step_count += 1;
                }
                Err(Trap::RequestedTrap(code)) => {
                    web_sys::console::log_1(&JsValue::from_str(
                        &format!("[Worker {}] Shutdown requested (code: {:#x})", 
                            self.hart_id, code)));
                    self.control.signal_halted(code);
                    return WorkerStepResult::Shutdown;
                }
                Err(Trap::Fatal(msg)) => {
                    web_sys::console::error_1(&JsValue::from_str(
                        &format!("[Worker {}] Fatal: {} at PC=0x{:x}", 
                            self.hart_id, msg, self.cpu.pc)));
                    self.control.signal_halted(0xDEAD);
                    return WorkerStepResult::Error;
                }
                Err(_trap) => {
                    // Architectural traps handled by CPU
                    self.step_count += 1;
                }
            }
        }
        
        // Full interrupt check at end of batch
        self.deliver_interrupts();
        
        WorkerStepResult::Continue
    }
    
    /// Check and deliver interrupts from shared CLINT.
    /// Separated into its own method to allow periodic calling during batch execution.
    #[inline]
    fn deliver_interrupts(&mut self) {
        let (msip_pending, timer_pending) = self.clint.check_interrupts(self.hart_id);
        if msip_pending || timer_pending {
            if let Ok(mut mip) = self.cpu.read_csr(0x344) { // MIP
                if msip_pending {
                    mip |= 1 << 3; // MSIP
                }
                if timer_pending {
                    mip |= 1 << 7; // MTIP
                }
                let _ = self.cpu.write_csr(0x344, mip);
            }
        }
    }
    
    /// Get the total step count.
    pub fn step_count(&self) -> u64 {
        self.step_count
    }
    
    /// Get the hart ID.
    pub fn hart_id(&self) -> usize {
        self.hart_id
    }
}

/// Legacy worker entry point - DEPRECATED.
/// 
/// This function runs a blocking infinite loop. Use WorkerState + step_batch instead
/// for cooperative scheduling that doesn't block the worker's event loop.
#[cfg(target_arch = "wasm32")]
#[wasm_bindgen]
pub fn worker_entry(hart_id: usize, shared_mem: JsValue, entry_pc: u64) {
    web_sys::console::warn_1(&JsValue::from_str(
        "[Worker] Using deprecated blocking worker_entry. Consider using WorkerState."));
    
    let mut state = WorkerState::new(hart_id, shared_mem, entry_pc);
    
    loop {
        match state.step_batch(256) {
            WorkerStepResult::Continue => continue,
            _ => break,
        }
    }
    
    web_sys::console::log_1(&JsValue::from_str(
        &format!("[Worker {}] Exited after {} steps", hart_id, state.step_count)));
}

/// Check interrupts for this hart using the shared CLINT.
///
/// This is called periodically by the worker to check for:
/// - Software interrupts (IPI via MSIP)
/// - Timer interrupts (MTIP)
#[cfg(target_arch = "wasm32")]
#[wasm_bindgen]
pub fn worker_check_interrupts(hart_id: usize, shared_mem: JsValue) -> u64 {
    let sab: SharedArrayBuffer = shared_mem.unchecked_into();
    let clint = SharedClint::new(&sab);
    
    let mut mip: u64 = 0;
    let (msip, timer) = clint.check_interrupts(hart_id);
    
    if msip {
        mip |= 1 << 3; // MSIP
    }
    if timer {
        mip |= 1 << 7; // MTIP
    }
    
    mip
}

#[cfg(test)]
mod tests {
    // Worker tests require WASM environment
}
</file>

<file path="riscv-vm/build.sh">
#!/usr/bin/env bash
set -e  # Exit on any error

is_mac() {
  [[ "$OSTYPE" == "darwin"* ]]
}

PACKAGEJSON=./pkg/package.json
IMPORTFILE=./pkg/riscv_vm.js

echo "Building the rust library"
RUSTFLAGS=--cfg=web_sys_unstable_apis npx wasm-pack build  --target web 

if is_mac; then
  sed -i '' 's/"module": "ridb_core.js",/"main": "ridb_core.js",/' $PACKAGEJSON
  sed -i '' "/if (typeof module_or_path === 'undefined') {/,/}/d" $IMPORTFILE
else
  sed -i  's/"module": "ridb_core.js",/"main": "ridb_core.js",/' $PACKAGEJSON
  sed -i "/if (typeof module_or_path === 'undefined') {/,/}/d" $IMPORTFILE
fi

npx tsup --config tsup/tsup.cli.ts
npx tsup --config tsup/tsup.core.cjs.ts
npx tsup --config tsup/tsup.core.esm.ts
npx tsup --config tsup/tsup.core.cjs.ts --dts-only
npx tsup --config tsup/tsup.worker.ts
npx tsup --config tsup/tsup.node-worker.ts
</file>

<file path="riscv-vm/cli.ts">
#!/usr/bin/env node
/// <reference types="node" />
/**
 * RISC-V VM CLI
 *
 * This CLI mirrors the native Rust VM CLI interface:
 * - loads a kernel image (ELF or raw binary) via --kernel/-k
 * - optionally loads a VirtIO block disk image (e.g. xv6 `fs.img`) via --disk/-d
 * - optionally specifies number of harts via --harts/-n (0 = auto-detect as CPU/2)
 * - can optionally connect to a network relay via --net-webtransport
 * - runs the VM in a tight loop
 * - connects stdin → UART input and UART output → stdout
 *
 * Multi-hart support:
 * - Uses Node.js worker_threads for parallel execution
 * - Hart 0 runs on main thread (handles I/O)
 * - Harts 1+ run on worker threads
 * - All harts share memory via SharedArrayBuffer
 */

import fs from 'node:fs';
import os from 'node:os';
import path from 'node:path';
import { Worker } from 'node:worker_threads';
import yargs from 'yargs';
import { hideBin } from 'yargs/helpers';

// Default relay server URL and cert hash.
const DEFAULT_RELAY_URL =
  process.env.RELAY_URL || 'https://localhost:4433';
const DEFAULT_CERT_HASH =
  process.env.RELAY_CERT_HASH || '';

/**
 * Auto-detect the number of harts based on CPU cores.
 * Uses half of available cores, minimum 1.
 */
function detectHartCount(): number {
  const cpus = os.cpus().length;
  return Math.max(1, Math.floor(cpus / 2));
}

/**
 * Try to load the native WebTransport addon.
 * Returns the WebTransportClient class if available, null otherwise.
 */
async function loadNativeWebTransport(): Promise<any | null> {
  // Try to load from the native directory (built with npm run build:native)
  // ESM requires explicit file path, not directory imports
  const addonPath = path.resolve(__dirname, '..', 'native', 'index.js');
  
  try {
    const addon = await import(addonPath);
    if (addon.WebTransportClient) {
      console.error('[CLI] Native WebTransport addon loaded');
      return addon.WebTransportClient;
    }
    console.error('[CLI] Native addon loaded but WebTransportClient not found');
  } catch (e: any) {
    // Not available - likely not built yet
    console.error('[CLI] Native WebTransport addon not available');
    console.error(`[CLI] Tried to load from: ${addonPath}`);
    console.error(`[CLI] Error: ${e.message || e}`);
    console.error('[CLI] Build it with: cd riscv-vm && npm run build:native');
  }
  return null;
}

/**
 * Create and initialize a Wasm VM instance with multi-hart support:
 * - initializes the WASM module once via `WasmInternal`
 * - constructs `WasmVm` with the kernel bytes and specified hart count
 * - optionally attaches a VirtIO block device from a disk image
 * - optionally connects to a network relay (WebTransport/WebSocket)
 * - starts worker threads for secondary harts
 */
async function createVm(
  kernelPath: string,
  options?: {
    disk?: string;
    harts?: number;
    netWebtransport?: string;
    certHash?: string;
    debug?: boolean;
  },
) {
  let kernelBytes: Uint8Array;

  if (kernelPath.startsWith('http://') || kernelPath.startsWith('https://')) {
    if (options?.debug) {
      console.error(`[CLI] Downloading kernel from ${kernelPath}...`);
    }
    const response = await fetch(kernelPath);
    if (!response.ok) {
      throw new Error(
        `Failed to fetch kernel from ${kernelPath}: ${response.statusText}`,
      );
    }
    const arrayBuffer = await response.arrayBuffer();
    kernelBytes = new Uint8Array(arrayBuffer);
  } else {
    const resolvedKernel = path.resolve(kernelPath);
    if (!fs.existsSync(resolvedKernel)) {
      throw new Error(`Kernel file not found at ${resolvedKernel}`);
    }
    const kernelBuf = fs.readFileSync(resolvedKernel);
    kernelBytes = new Uint8Array(kernelBuf);
  }

  const { WasmInternal } = await import('./');
  const wasm = await WasmInternal();
  const VmCtor = wasm.WasmVm;
  if (!VmCtor) {
    throw new Error('WasmVm class not found in wasm module');
  }

  // Create VM with requested number of harts
  const numHarts = options?.harts ?? 1;
  const vm = VmCtor.new_with_harts 
    ? VmCtor.new_with_harts(kernelBytes, numHarts) 
    : new VmCtor(kernelBytes);

  if (options?.disk) {
    const resolvedDisk = path.resolve(options.disk);
    const diskBuf = fs.readFileSync(resolvedDisk);
    const diskBytes = new Uint8Array(diskBuf);

    if (typeof vm.load_disk === 'function') {
      vm.load_disk(diskBytes);
      if (options?.debug) {
        console.error(`[VM] Loaded disk: ${resolvedDisk}`);
      }
    }
  }

  // Start worker threads for secondary harts (1..numHarts)
  const workers: Worker[] = [];
  if (numHarts > 1 && typeof vm.get_shared_buffer === 'function') {
    const sharedBuffer = vm.get_shared_buffer();
    
    if (sharedBuffer) {
      // Get entry PC for workers
      const entryPc = typeof (vm as any).entry_pc === 'function' ? (vm as any).entry_pc() : 0x80000000;
      
      // Path to WASM file and worker script
      const wasmPath = path.resolve(__dirname, '..', 'pkg', 'riscv_vm_bg.wasm');
      const workerPath = path.resolve(__dirname, 'node-worker.js');
      
      console.error(`[VM] Starting ${numHarts - 1} worker threads...`);
      
      for (let hartId = 1; hartId < numHarts; hartId++) {
        const worker = new Worker(workerPath, {
          workerData: {
            hartId,
            sharedMem: sharedBuffer,
            entryPc: Number(entryPc),
            wasmPath,
          },
        });
        
        worker.on('message', (msg: any) => {
          if (msg.type === 'ready') {
            console.error(`[VM] Worker ${msg.hartId} ready`);
          } else if (msg.type === 'halted') {
            console.error(`[VM] Worker ${msg.hartId} halted (${msg.stepCount} steps)`);
          } else if (msg.type === 'error') {
            console.error(`[VM] Worker ${msg.hartId} error: ${msg.error}`);
          }
        });
        
        worker.on('error', (err) => {
          console.error(`[VM] Worker ${hartId} error:`, err);
        });
        
        worker.on('exit', (code) => {
          if (code !== 0) {
            console.error(`[VM] Worker ${hartId} exited with code ${code}`);
          }
        });
        
        workers.push(worker);
      }
      
      console.error(`[VM] Started ${workers.length} worker threads`);
    } else {
      console.error('[VM] Warning: SharedArrayBuffer not available, running single-threaded');
    }
  }

  // Network setup via native WebTransport addon (Node.js)
  let nativeNetClient: any = null;
  if (options?.netWebtransport) {
    const relayUrl = options.netWebtransport;
    const certHash = options.certHash || DEFAULT_CERT_HASH || undefined;
    
    // Try to use native WebTransport addon
    const WebTransportClient = await loadNativeWebTransport();
    
    if (WebTransportClient) {
      // Use native addon for WebTransport
      nativeNetClient = new WebTransportClient(relayUrl, certHash);
      
      // Get MAC address from native client and set up external network
      const macBytes = nativeNetClient.macBytes();
      if (typeof vm.setup_external_network === 'function') {
        vm.setup_external_network(new Uint8Array(macBytes));
        console.error(`[Network] External network setup with native WebTransport`);
        console.error(`[Network] MAC: ${nativeNetClient.macAddress()}`);
        console.error(`[Network] Connecting to ${relayUrl}...`);
      } else {
        console.error('[Network] VM does not support external network (rebuild WASM)');
        nativeNetClient.shutdown();
        nativeNetClient = null;
      }
    } else {
      // Fall back to WASM WebTransport (won't work in Node.js but try anyway)
      console.error('[Network] Warning: Native WebTransport addon not available');
      console.error('[Network] WebTransport requires the native addon in Node.js');
      console.error('[Network] Build the addon with: cd riscv-vm && npm run build:native');
    }
  }

  return { vm, nativeNetClient, workers };
}

/**
 * Run the VM in a loop and wire stdin/stdout to the UART, similar to the browser loop:
 * - executes a fixed number of instructions per tick
 * - drains the UART output buffer and writes to stdout
 * - feeds raw stdin bytes into the VM's UART input
 * - bridges packets between native WebTransport addon and VM
 * - manages worker threads for secondary harts
 */
function runVmLoop(vm: any, nativeNetClient: any | null, workers: Worker[] = []) {
  let running = true;
  let networkConnected = false;

  const shutdown = (code: number) => {
    if (!running) return;
    running = false;

    // Terminate worker threads
    for (const worker of workers) {
      worker.terminate();
    }

    // Shutdown native network client
    if (nativeNetClient) {
      nativeNetClient.shutdown();
    }

    if (process.stdin.isTTY && (process.stdin as any).setRawMode) {
      (process.stdin as any).setRawMode(false);
    }
    process.stdin.pause();

    process.exit(code);
  };

  // Handle Ctrl+C via signal as a fallback
  process.on('SIGINT', () => {
    shutdown(0);
  });

  // Configure stdin → VM UART input
  if (process.stdin.isTTY && (process.stdin as any).setRawMode) {
    (process.stdin as any).setRawMode(true);
  }
  process.stdin.resume();

  process.stdin.on('data', (chunk) => {
    // In raw mode `chunk` is typically a Buffer; iterate its bytes.
    for (const byte of chunk as any as Uint8Array) {
      // Ctrl+C (ETX) – terminate the VM and exit
      if (byte === 3) {
        shutdown(0);
        return;
      }

      // Map CR to LF as in the React hook
      if (byte === 13) {
        vm.input(10);
      } else if (byte === 127 || byte === 8) {
        // Backspace
        vm.input(8);
      } else {
        vm.input(byte);
      }
    }
  });

  const INSTRUCTIONS_PER_TICK = 100_000;

  const drainOutput = () => {
    // Drain UART output buffer
    // In raw terminal mode, we need \r\n for proper line breaks
    const outChunks: string[] = [];
    let limit = 2000;
    let code = typeof vm.get_output === 'function' ? vm.get_output() : undefined;

    while (code !== undefined && limit-- > 0) {
      const c = Number(code);

      if (c === 8) {
        // Backspace – move cursor back, erase, move back
        outChunks.push('\b \b');
      } else if (c === 10) {
        // LF -> CRLF for raw terminal mode (like native CLI)
        outChunks.push('\r\n');
      } else if (c === 13) {
        // CR - just output CR
        outChunks.push('\r');
      } else {
        // Pass through all other characters including ANSI escape sequences
        outChunks.push(String.fromCharCode(c));
      }

      code = vm.get_output();
    }

    if (outChunks.length) {
      process.stdout.write(outChunks.join(''));
    }
  };

  // Bridge packets between native WebTransport and VM
  const bridgeNetwork = () => {
    if (!nativeNetClient) return;
    
    // Check connection status
    if (!networkConnected && nativeNetClient.isRegistered()) {
      networkConnected = true;
      const ip = nativeNetClient.assignedIp();
      console.error(`\r\n[Network] Connected! IP: ${ip}`);
      
      // Set IP in VM's external network backend
      const ipBytes = nativeNetClient.assignedIpBytes();
      if (ipBytes && typeof vm.set_external_network_ip === 'function') {
        vm.set_external_network_ip(new Uint8Array(ipBytes));
      }
    }
    
    // Forward packets from native client to VM (RX)
    let packet = nativeNetClient.recv();
    while (packet) {
      if (typeof vm.inject_network_packet === 'function') {
        // Convert Buffer to Uint8Array for WASM
        vm.inject_network_packet(new Uint8Array(packet));
      }
      packet = nativeNetClient.recv();
    }
    
    // Forward packets from VM to native client (TX)
    if (typeof vm.extract_network_packet === 'function') {
      let txPacket = vm.extract_network_packet();
      while (txPacket) {
        // txPacket is Uint8Array from WASM, convert to Buffer for native addon
        nativeNetClient.send(Buffer.from(txPacket));
        txPacket = vm.extract_network_packet();
      }
    }
  };

  const loop = () => {
    if (!running) return;

    try {
      // Execute a batch of instructions
      for (let i = 0; i < INSTRUCTIONS_PER_TICK; i++) {
        vm.step();
      }

      // Drain output
      drainOutput();
      
      // Bridge network packets
      bridgeNetwork();

      // Check if VM has halted (e.g., shutdown command)
      if (typeof vm.is_halted === 'function' && vm.is_halted()) {
        // Drain any remaining output
        drainOutput();
        
        const haltCode = typeof vm.halt_code === 'function' ? vm.halt_code() : 0n;
        if (haltCode === 0x5555n) {
          console.log('\r\n[VM] Clean shutdown (PASS)');
        } else {
          console.log(`\r\n[VM] Shutdown with code: 0x${haltCode.toString(16)}`);
        }
        shutdown(0);
        return;
      }
    } catch (err) {
      console.error('\r\n[VM] Error while executing:', err);
      shutdown(1);
      return;
    }

    // Schedule the next tick; run as fast as the event loop allows.
    setImmediate(loop);
  };

  loop();
}

/**
 * Print banner matching native VM output
 */
function printBanner(kernelPath: string, numHarts: number, netWebtransport?: string) {
  const kernelName = path.basename(kernelPath);
  
  console.log();
  console.log('╔══════════════════════════════════════════════════════════════╗');
  console.log('║              RISC-V Emulator (WASM + Worker Threads)         ║');
  console.log('╠══════════════════════════════════════════════════════════════╣');
  console.log(`║  Kernel: ${kernelName.padEnd(50)} ║`);
  console.log(`║  Harts:  ${String(numHarts).padEnd(50)} ║`);
  if (netWebtransport) {
    console.log(`║  Network: ${netWebtransport.padEnd(49)} ║`);
  }
  console.log('╚══════════════════════════════════════════════════════════════╝');
  console.log();
}

const argv = (yargs(hideBin(process.argv)) as any)
  .usage('Usage: $0 [options]')
  .option('kernel', {
    alias: 'k',
    type: 'string',
    describe: 'Path to kernel ELF or binary',
    demandOption: true,
  })
  .option('disk', {
    alias: 'd',
    type: 'string',
    describe: 'Path to disk image (optional)',
  })
  .option('harts', {
    alias: 'n',
    type: 'number',
    describe: 'Number of harts (0 = auto-detect as CPU/2)',
    default: 0,
  })
  .option('net-webtransport', {
    type: 'string',
    describe: 'WebTransport relay URL for networking (e.g., https://127.0.0.1:4433)',
  })
  .option('cert-hash', {
    type: 'string',
    describe: 'Certificate hash for WebTransport (for self-signed certs)',
  })
  .option('debug', {
    type: 'boolean',
    describe: 'Enable debug output',
    default: false,
  })
  .help()
  .version()
  .parseSync();

(async () => {
  const kernelPath = argv.kernel as string;
  const diskPath = argv.disk as string | undefined;
  const hartsArg = argv.harts as number;
  const netWebtransport = argv['net-webtransport'] as string | undefined;
  const certHash = argv['cert-hash'] as string | undefined;
  const debug = argv.debug as boolean;

  // Auto-detect harts if set to 0, otherwise use user-specified value
  const numHarts = hartsArg === 0 ? detectHartCount() : hartsArg;

  // Print banner
  printBanner(kernelPath, numHarts, netWebtransport);

  try {
    const { vm, nativeNetClient, workers } = await createVm(kernelPath, {
      disk: diskPath,
      harts: numHarts,
      netWebtransport,
      certHash,
      debug,
    });
    
    // Signal workers that they can start executing
    // This is done after the main hart has had a chance to initialize
    if (typeof (vm as any).allow_workers_to_start === 'function') {
      // Give hart 0 a head start to initialize kernel data structures
      setTimeout(() => {
        (vm as any).allow_workers_to_start();
        console.error('[VM] Workers allowed to start');
      }, 100);
    }
    
    runVmLoop(vm, nativeNetClient, workers);
  } catch (err) {
    console.error('[CLI] Failed to start VM:', err);
    process.exit(1);
  }
})();
</file>

<file path="riscv-vm/index.ts">
import wasmBuffer from "./pkg/riscv_vm_bg.wasm";

let loaded: typeof import("./pkg/riscv_vm") | undefined;

export async function WasmInternal() {
  if (!loaded) {
    const module = await import("./pkg/riscv_vm");
    const wasmInstance = module.initSync(wasmBuffer);
    await module.default(wasmInstance);
    loaded = module;
  }
  return loaded;
}

export { NetworkStatus, WasmVm } from "./pkg/riscv_vm";

// Re-export worker message types for consumers (from side-effect-free module)
export type {
  WorkerInitMessage,
  WorkerReadyMessage,
  WorkerHaltedMessage,
  WorkerErrorMessage,
  WorkerOutboundMessage,
} from "./worker-utils";

// Re-export worker utilities (from side-effect-free module)
export { isHaltRequested, requestHalt, isHalted } from "./worker-utils";

// ============================================================================
// Multi-Hart Worker Support
// ============================================================================

export interface VmOptions {
  /** Number of harts (auto-detected if not specified) */
  harts?: number;
  /** Path to worker script (default: '/worker.js') */
  workerScript?: string;
}

/**
 * Create a VM instance with optional SMP support.
 *
 * If SharedArrayBuffer is available (requires COOP/COEP headers), the VM
 * will run in true parallel mode with Web Workers for secondary harts.
 *
 * NOTE: In WASM, multi-hart mode is significantly slower due to
 * SharedArrayBuffer/Atomics overhead (see tasks/improvements.md).
 * Default is 1 hart unless explicitly specified.
 *
 * @param kernelData - ELF kernel binary
 * @param options - VM configuration options
 * @returns WasmVm instance
 */
export async function createVM(
  kernelData: Uint8Array,
  options: VmOptions = {}
): Promise<import("./pkg/riscv_vm").WasmVm> {
  const module = await WasmInternal();

  // In WASM, default to 1 hart due to SharedArrayBuffer/Atomics overhead
  // Multi-hart mode is ~8x slower than single hart (see tasks/improvements.md)
  // Users can explicitly request multiple harts if needed
  const defaultHarts = typeof window !== 'undefined' ? 1 : undefined;
  const harts = options.harts ?? defaultHarts;

  // Create VM with specified hart count (0 = auto-detect)
  const vm = harts !== undefined && harts > 0
    ? module.WasmVm.new_with_harts(kernelData, harts)
    : new module.WasmVm(kernelData);

  // Start workers if in SMP mode
  const workerScript = options.workerScript || "/worker.js";
  if (vm.is_smp()) {
    try {
      vm.start_workers(workerScript);
      console.log(`[VM] Started workers for ${vm.num_harts()} harts`);
    } catch (e) {
      console.warn("[VM] Failed to start workers, falling back to single-threaded:", e);
    }
  }

  console.log(`[VM] Created VM instance (SMP: ${vm.is_smp()}, harts: ${vm.num_harts()})`);

  return vm;
}

/**
 * Run the VM with an output callback for UART data.
 *
 * This function manages the main execution loop, stepping hart 0 on the
 * main thread. Secondary harts (if any) run in Web Workers.
 *
 * @param vm - WasmVm instance
 * @param onOutput - Callback for each character output
 * @param options - Run options
 * @returns Stop function to halt execution
 */
export function runVM(
  vm: import("./pkg/riscv_vm").WasmVm,
  onOutput: (char: string) => void,
  options: { stepsPerFrame?: number } = {}
): () => void {
  const stepsPerFrame = options.stepsPerFrame || 10000;
  let running = true;

  const loop = () => {
    if (!running) return;

    // Step primary hart (I/O coordination)
    for (let i = 0; i < stepsPerFrame; i++) {
      if (!vm.step()) {
        console.log("[VM] Halted");
        running = false;
        return;
      }
    }

    // Collect output
    let byte: number | undefined;
    while ((byte = vm.get_output()) !== undefined) {
      onOutput(String.fromCharCode(byte));
    }

    // Schedule next batch
    requestAnimationFrame(loop);
  };

  loop();

  // Return stop function
  return () => {
    running = false;
    vm.terminate_workers();
  };
}

// ============================================================================
// SharedArrayBuffer Support Detection
// ============================================================================

export interface SharedMemorySupport {
  supported: boolean;
  crossOriginIsolated: boolean;
  message: string;
}

/**
 * Check if SharedArrayBuffer is available for multi-threaded execution.
 *
 * SharedArrayBuffer requires Cross-Origin Isolation (COOP/COEP headers).
 * If not available, the VM will run in single-threaded mode.
 */
export function checkSharedMemorySupport(): SharedMemorySupport {
  const crossOriginIsolated = isCrossOriginIsolated();

  if (typeof SharedArrayBuffer === "undefined") {
    return {
      supported: false,
      crossOriginIsolated,
      message: "SharedArrayBuffer not defined. Browser may be too old.",
    };
  }

  if (!crossOriginIsolated) {
    return {
      supported: false,
      crossOriginIsolated,
      message:
        "Not cross-origin isolated. Add headers:\n" +
        "  Cross-Origin-Opener-Policy: same-origin\n" +
        "  Cross-Origin-Embedder-Policy: require-corp",
    };
  }

  // Try to create a SharedArrayBuffer
  try {
    new SharedArrayBuffer(8);
    return {
      supported: true,
      crossOriginIsolated,
      message: "SharedArrayBuffer available for SMP execution",
    };
  } catch (e) {
    return {
      supported: false,
      crossOriginIsolated,
      message: `SharedArrayBuffer blocked: ${e}`,
    };
  }
}

/**
 * Check if the page is cross-origin isolated (required for SharedArrayBuffer).
 */
export function isCrossOriginIsolated(): boolean {
  return typeof crossOriginIsolated !== "undefined" && crossOriginIsolated;
}

// ============================================================================
// COOP/COEP Headers Reference
// ============================================================================

/**
 * Headers required for SharedArrayBuffer support.
 *
 * For Vite dev server, add to vite.config.ts:
 * ```ts
 * server: {
 *   headers: {
 *     "Cross-Origin-Opener-Policy": "same-origin",
 *     "Cross-Origin-Embedder-Policy": "require-corp",
 *   },
 * },
 * ```
 *
 * For production, configure your web server to add these headers.
 */
export const REQUIRED_HEADERS = {
  "Cross-Origin-Opener-Policy": "same-origin",
  "Cross-Origin-Embedder-Policy": "require-corp",
} as const;

// ============================================================================
// Worker Management Utilities
// ============================================================================

/**
 * Manually create and manage workers for advanced use cases.
 *
 * Most users should use createVM() which handles workers automatically.
 */
export interface WorkerManager {
  /** Start a worker for a specific hart */
  startWorker(
    hartId: number,
    sharedMem: SharedArrayBuffer,
    entryPc: number,
    workerScript?: string
  ): Worker;
  /** Terminate all workers */
  terminateAll(): void;
  /** Get number of active workers */
  count(): number;
}

/**
 * Create a worker manager for manual worker control.
 */
export function createWorkerManager(): WorkerManager {
  const workers: Worker[] = [];

  return {
    startWorker(
      hartId: number,
      sharedMem: SharedArrayBuffer,
      entryPc: number,
      workerScript = "/worker.js"
    ): Worker {
      const worker = new Worker(workerScript, { type: "module" });

      worker.onmessage = (event) => {
        const { type, hartId: id, error } = event.data;
        switch (type) {
          case "ready":
            console.log(`[WorkerManager] Hart ${id} ready`);
            break;
          case "halted":
            console.log(`[WorkerManager] Hart ${id} halted`);
            break;
          case "error":
            console.error(`[WorkerManager] Hart ${id} error:`, error);
            break;
        }
      };

      worker.onerror = (e) => {
        console.error(`[WorkerManager] Worker error:`, e);
      };

      // Send init message
      worker.postMessage({
        hartId,
        sharedMem,
        entryPc,
      });

      workers.push(worker);
      return worker;
    },

    terminateAll(): void {
      for (const worker of workers) {
        worker.terminate();
      }
      workers.length = 0;
    },

    count(): number {
      return workers.length;
    },
  };
}
</file>

<file path="riscv-vm/worker.ts">
/**
 * Web Worker entry point for RISC-V hart.
 *
 * This worker runs a secondary RISC-V hart (1, 2, 3, ...) sharing memory
 * with the main thread via SharedArrayBuffer.
 *
 * ## Architecture
 *
 * - Workers run secondary harts (1+)
 * - Hart 0 runs on main thread (handles I/O)
 * - Shared via SharedArrayBuffer:
 *   - Control region (halt flags)
 *   - CLINT (timer, IPI)
 *   - DRAM (kernel memory)
 *
 * ## Communication Protocol
 *
 * Main → Worker: WorkerInitMessage
 * Worker → Main: WorkerReadyMessage | WorkerHaltedMessage | WorkerErrorMessage
 */

// Import WASM as embedded buffer (converted to base64 by tsup wasmPlugin)
import wasmBuffer from "./pkg/riscv_vm_bg.wasm";
import { initSync, WorkerState } from "./pkg/riscv_vm.js";

// WorkerStepResult enum values (must match worker.rs)
// wasm-bindgen exports enums as numeric values
const WorkerStepResult = {
  Continue: 0,
  Halted: 1,
  Shutdown: 2,
  Error: 3,
} as const;

// ============================================================================
// Message Types
// ============================================================================

/** Message sent from main thread to initialize the worker */
export interface WorkerInitMessage {
  hartId: number;
  /** SharedArrayBuffer containing control + CLINT + DRAM */
  sharedMem: SharedArrayBuffer;
  entryPc: number;
}

/** Message sent when worker is ready to execute */
export interface WorkerReadyMessage {
  type: "ready";
  hartId: number;
}

/** Message sent when worker has halted */
export interface WorkerHaltedMessage {
  type: "halted";
  hartId: number;
  stepCount?: number;
}

/** Message sent when an error occurs */
export interface WorkerErrorMessage {
  type: "error";
  hartId?: number;
  error: string;
}

export type WorkerOutboundMessage =
  | WorkerReadyMessage
  | WorkerHaltedMessage
  | WorkerErrorMessage;

// ============================================================================
// Shared Memory Layout (must match shared_mem.rs)
// ============================================================================

/** Control region offsets (i32 indices) */
const CTRL_HALT_REQUESTED = 0;
const CTRL_HALTED = 1;

/** Shared control view for Atomics operations */
let controlView: Int32Array | null = null;

// ============================================================================
// Worker Context
// ============================================================================

// Worker global scope type (avoids needing WebWorker lib which conflicts with DOM)
interface WorkerGlobalScope {
  onmessage: ((event: MessageEvent<WorkerInitMessage>) => void) | null;
  onerror: ((event: ErrorEvent) => void) | null;
  postMessage(message: WorkerOutboundMessage): void;
}

declare const self: WorkerGlobalScope;

let initialized = false;
let currentHartId: number | undefined;
let workerState: WorkerState | null = null;

// Tuning parameters for execution
// Performance Note: Higher BATCH_SIZE reduces JS/WASM boundary crossing overhead.
// Combined with BATCHES_PER_YIELD, this determines how often we check for halt signals.
const BATCH_SIZE = 100_000;      // Instructions per batch (was 1024)

/**
 * Run loop using optimized blocking execution with periodic yields.
 * 
 * This replaces the previous setTimeout-based approach which had significant
 * overhead (~4ms minimum delay per batch in browsers). Instead, we:
 * 1. Execute multiple batches in a tight loop
 * 2. Use Atomics.wait with 0ms timeout to efficiently yield
 * 3. Only check for halt signals periodically
 * 
 * This significantly reduces scheduling overhead while still allowing
 * the worker to respond to external signals.
 */
function runLoop() {
  if (!workerState || currentHartId === undefined || !controlView) {
    console.error('[Worker] runLoop called without workerState, hartId, or controlView');
    return;
  }
  
  const hartId = currentHartId; // Capture for type narrowing
  
  // Number of batches to execute before yielding
  const BATCHES_PER_YIELD = 10;
  
  let shouldContinue = true;
  let batchCount = 0;
  
  while (shouldContinue) {
    const result = workerState.step_batch(BATCH_SIZE);
    
    switch (result) {
      case WorkerStepResult.Continue:
        batchCount++;
        
        // Yield periodically to allow halt signals to be processed
        if (batchCount >= BATCHES_PER_YIELD) {
          batchCount = 0;
          
          // Use Atomics.wait with 0ms timeout for efficient yielding
          // This is much faster than setTimeout(0) which has ~4ms minimum delay
          // Returns immediately but allows the thread to check for updates
          try {
            Atomics.wait(controlView, CTRL_HALT_REQUESTED, 0, 0);
          } catch {
            // Atomics.wait may not be available in all contexts, fall back gracefully
          }
        }
        break;
        
      case WorkerStepResult.Halted:
        console.log(`[Worker ${hartId}] Halted after ${workerState.step_count()} steps`);
        self.postMessage({ type: "halted", hartId });
        cleanup();
        shouldContinue = false;
        break;
        
      case WorkerStepResult.Shutdown:
        console.log(`[Worker ${hartId}] Shutdown after ${workerState.step_count()} steps`);
        self.postMessage({ type: "halted", hartId });
        cleanup();
        shouldContinue = false;
        break;
        
      case WorkerStepResult.Error:
        console.error(`[Worker ${hartId}] Error after ${workerState.step_count()} steps`);
        self.postMessage({ type: "error", hartId, error: "Execution error" });
        cleanup();
        shouldContinue = false;
        break;
    }
  }
}

function cleanup() {
  workerState = null;
  controlView = null;
}

self.onmessage = async (event: MessageEvent<WorkerInitMessage>) => {
  const data = event.data;
  
  // Ignore messages from browser extensions (React DevTools, etc.)
  if (!data || typeof data !== 'object' || 'source' in data) {
    return;
  }
  
  const { hartId, sharedMem, entryPc } = data;
  
  // Validate required fields
  if (hartId === undefined || !sharedMem || entryPc === undefined) {
    console.warn('[Worker] Invalid init message, missing fields');
    return;
  }
  
  currentHartId = hartId;
  console.log(`[Worker ${hartId}] Received init message`);

  if (!initialized) {
    try {
      // Initialize WASM module with embedded buffer
      console.log(`[Worker ${hartId}] Initializing WASM...`);
      initSync(wasmBuffer);
      initialized = true;
      console.log(`[Worker ${hartId}] WASM initialized`);
    } catch (e) {
      console.error(`[Worker ${hartId}] WASM init failed:`, e);
      const msg: WorkerErrorMessage = {
        type: "error",
        hartId,
        error: String(e),
      };
      self.postMessage(msg);
      return;
    }
  }

  // Verify SharedArrayBuffer
  if (!(sharedMem instanceof SharedArrayBuffer)) {
    const msg: WorkerErrorMessage = {
      type: "error",
      hartId,
      error: "sharedMem must be a SharedArrayBuffer",
    };
    self.postMessage(msg);
    return;
  }

  // Notify main thread that we're ready
  const readyMsg: WorkerReadyMessage = { type: "ready", hartId };
  self.postMessage(readyMsg);

  try {
    // Convert entryPc (number/float64) to BigInt for u64
    const pc = BigInt(Math.floor(entryPc));
    console.log(`[Worker ${hartId}] Starting execution at PC=0x${pc.toString(16)}`);
    
    // Set up control view for efficient Atomics.wait-based yielding
    controlView = new Int32Array(sharedMem);
    
    // Create worker state for cooperative scheduling
    workerState = new WorkerState(hartId, sharedMem, pc);
    
    // Start the optimized blocking run loop
    runLoop();
  } catch (e) {
    console.error(`[Worker ${hartId}] Execution error:`, e);
    const msg: WorkerErrorMessage = {
      type: "error",
      hartId,
      error: String(e),
    };
    self.postMessage(msg);
    cleanup();
    return;
  }
};

self.onerror = (e: ErrorEvent) => {
  console.error("[Worker] Uncaught error:", e);
  const msg: WorkerErrorMessage = {
    type: "error",
    hartId: currentHartId,
    error: e.message || String(e),
  };
  self.postMessage(msg);
};

// ============================================================================
// Utility: Check if halt was requested (can be called from JS if needed)
// ============================================================================

/**
 * Check if halt has been requested in the shared control region.
 * This can be used for JS-side polling if needed.
 */
export function isHaltRequested(sharedMem: SharedArrayBuffer): boolean {
  const view = new Int32Array(sharedMem);
  return Atomics.load(view, CTRL_HALT_REQUESTED) !== 0;
}

/**
 * Request halt by setting the flag in shared memory.
 * This can be called from any thread.
 */
export function requestHalt(sharedMem: SharedArrayBuffer): void {
  const view = new Int32Array(sharedMem);
  Atomics.store(view, CTRL_HALT_REQUESTED, 1);
  Atomics.notify(view, CTRL_HALT_REQUESTED);
}

/**
 * Check if VM has halted.
 */
export function isHalted(sharedMem: SharedArrayBuffer): boolean {
  const view = new Int32Array(sharedMem);
  return Atomics.load(view, CTRL_HALTED) !== 0;
}
</file>

<file path="kernel/src/net.rs">
//! Network stack using smoltcp.
//!
//! This module provides the TCP/IP stack for the kernel using the smoltcp crate.

use crate::virtio_net::VirtioNet;
use alloc::vec;
use alloc::vec::Vec;
use alloc::collections::VecDeque;
use smoltcp::iface::{Config, Interface, SocketHandle, SocketSet, SocketStorage};
use smoltcp::phy::{Device, DeviceCapabilities, Medium, RxToken, TxToken};
use smoltcp::socket::{icmp, tcp, udp};
use smoltcp::time::Instant;
use smoltcp::wire::{EthernetAddress, HardwareAddress, IpAddress, IpCidr, IpEndpoint, Ipv4Address};

/// Network configuration
/// Default IP address (used as fallback if no IP is assigned by relay)
pub const DEFAULT_IP_ADDR: Ipv4Address = Ipv4Address::new(10, 0, 2, 15);
pub const GATEWAY: Ipv4Address = Ipv4Address::new(10, 0, 2, 2);
pub const PREFIX_LEN: u8 = 24;

/// Dynamic IP address assigned by the relay/network controller
/// This is set during network initialization
pub static mut MY_IP_ADDR: Ipv4Address = Ipv4Address::new(10, 0, 2, 15);

/// Get the current IP address (safe wrapper)
pub fn get_my_ip() -> Ipv4Address {
    unsafe { MY_IP_ADDR }
}

/// DNS server (Google Public DNS)
pub const DNS_SERVER: Ipv4Address = Ipv4Address::new(8, 8, 8, 8);
/// DNS port
pub const DNS_PORT: u16 = 53;

/// Loopback address
pub const LOOPBACK: Ipv4Address = Ipv4Address::new(127, 0, 0, 1);

/// ICMP identifier for our ping socket
const ICMP_IDENT: u16 = 0x1234;

/// Local port for DNS queries
const DNS_LOCAL_PORT: u16 = 10053;

/// Pending loopback ping reply
struct LoopbackReply {
    from: Ipv4Address,
    ident: u16,
    seq: u16,
}

/// Static storage for sockets
static mut SOCKET_STORAGE: [SocketStorage<'static>; 8] = [SocketStorage::EMPTY; 8];

/// Static storage for ICMP buffers - need larger buffers for proper ICMP
static mut ICMP_RX_META: [icmp::PacketMetadata; 8] = [icmp::PacketMetadata::EMPTY; 8];
static mut ICMP_TX_META: [icmp::PacketMetadata; 8] = [icmp::PacketMetadata::EMPTY; 8];
static mut ICMP_RX_DATA: [u8; 512] = [0; 512];
static mut ICMP_TX_DATA: [u8; 512] = [0; 512];

/// Static storage for UDP buffers (for DNS queries)
static mut UDP_RX_META: [udp::PacketMetadata; 8] = [udp::PacketMetadata::EMPTY; 8];
static mut UDP_TX_META: [udp::PacketMetadata; 8] = [udp::PacketMetadata::EMPTY; 8];
static mut UDP_RX_DATA: [u8; 1024] = [0; 1024];
static mut UDP_TX_DATA: [u8; 1024] = [0; 1024];

/// Static storage for TCP buffers (for HTTP connections)
static mut TCP_RX_DATA: [u8; 8192] = [0; 8192];
static mut TCP_TX_DATA: [u8; 4096] = [0; 4096];

/// Cached ARP entry
struct ArpCache {
    ip: [u8; 4],
    mac: [u8; 6],
}

/// Global network state
pub struct NetState {
    device: VirtioNet,
    iface: Interface,
    sockets: SocketSet<'static>,
    icmp_handle: SocketHandle,
    udp_handle: SocketHandle,
    tcp_handle: SocketHandle,
    arp_cache: Option<ArpCache>,
    /// Pending loopback ping replies (delivered on next poll)
    loopback_replies: VecDeque<LoopbackReply>,
}

impl NetState {
    /// Initialize the network stack
    /// Note: After storing this in a static, call finalize() to complete RX buffer setup!
    /// Returns Err if no IP is assigned by the relay (networking will be disabled).
    pub fn new(mut device: VirtioNet) -> Result<Self, &'static str> {
        // Initialize the VirtIO device (phase 1 - configures queues but doesn't populate RX)
        device.init()?;
        
        // --- IP ADDRESS DISCOVERY ---
        // Wait for an IP assignment from the host/relay
        // In WASM, async tasks need the JS event loop to run, so we use many
        // short iterations to give the browser more chances to process events
        let mut my_ip = DEFAULT_IP_ADDR; // Fallback default
        let mut got_ip = false;
        
        crate::uart::write_str("    \x1b[0;90m├─\x1b[0m Waiting for IP assignment");
        // 200 iterations with shorter delays = more chances for async tasks in WASM
        // Total wait time is roughly 2-3 seconds
        for i in 0..200 {
            if let Some(ip_bytes) = device.get_config_ip() {
                my_ip = Ipv4Address::from_bytes(&ip_bytes);
                got_ip = true;
                crate::uart::write_line(" \x1b[1;32m[OK]\x1b[0m");
                break;
            }
            // Print a dot every 10 iterations to show progress
            if i % 10 == 0 {
                crate::uart::write_str(".");
            }
            // Shorter delay to allow more frequent checks and JS event loop to run in WASM
            for _ in 0..200_000 { core::hint::spin_loop(); } 
        }
        
        // If we didn't get an IP, network is unavailable - return error
        if !got_ip {
            crate::uart::write_line(" \x1b[1;31m[FAILED]\x1b[0m");
            crate::uart::write_line("    \x1b[1;31m[✗]\x1b[0m No IP address assigned by relay");
            crate::uart::write_line("    \x1b[0;90m    └─ Check relay connection and certificate hash\x1b[0m");
            return Err("No IP address assigned - networking disabled");
        }
        
        // Save to global for other modules to use
        unsafe { MY_IP_ADDR = my_ip; }
        
        let mac = device.mac;
        let hw_addr = HardwareAddress::Ethernet(EthernetAddress(mac));
        
        // Create interface config
        let config = Config::new(hw_addr);
        
        // Create the interface
        let mut iface = Interface::new(config, &mut DeviceWrapper(&mut device), Instant::from_millis(0));
        
        // Configure IP address using the dynamic IP
        iface.update_ip_addrs(|addrs| {
            addrs.push(IpCidr::new(IpAddress::v4(my_ip.0[0], my_ip.0[1], my_ip.0[2], my_ip.0[3]), PREFIX_LEN)).ok();
        });
        
        // Set default gateway
        iface.routes_mut().add_default_ipv4_route(GATEWAY).ok();
        
        // Create socket set with static storage
        let sockets = unsafe {
            SocketSet::new(&mut SOCKET_STORAGE[..])
        };
        
        // Create ICMP socket for ping
        let icmp_rx_buffer = unsafe {
            icmp::PacketBuffer::new(&mut ICMP_RX_META[..], &mut ICMP_RX_DATA[..])
        };
        let icmp_tx_buffer = unsafe {
            icmp::PacketBuffer::new(&mut ICMP_TX_META[..], &mut ICMP_TX_DATA[..])
        };
        let mut icmp_socket = icmp::Socket::new(icmp_rx_buffer, icmp_tx_buffer);
        
        // Bind the ICMP socket to receive echo replies for our identifier
        icmp_socket.bind(icmp::Endpoint::Ident(ICMP_IDENT)).ok();
        
        // Create UDP socket for DNS queries
        let udp_rx_buffer = unsafe {
            udp::PacketBuffer::new(&mut UDP_RX_META[..], &mut UDP_RX_DATA[..])
        };
        let udp_tx_buffer = unsafe {
            udp::PacketBuffer::new(&mut UDP_TX_META[..], &mut UDP_TX_DATA[..])
        };
        let mut udp_socket = udp::Socket::new(udp_rx_buffer, udp_tx_buffer);
        
        // Bind UDP socket to local port for DNS
        udp_socket.bind(DNS_LOCAL_PORT).ok();
        
        // Create TCP socket for HTTP connections
        let tcp_rx_buffer = unsafe {
            tcp::SocketBuffer::new(&mut TCP_RX_DATA[..])
        };
        let tcp_tx_buffer = unsafe {
            tcp::SocketBuffer::new(&mut TCP_TX_DATA[..])
        };
        let tcp_socket = tcp::Socket::new(tcp_rx_buffer, tcp_tx_buffer);
        
        let mut state = NetState {
            device,
            iface,
            sockets,
            icmp_handle: SocketHandle::default(),
            udp_handle: SocketHandle::default(),
            tcp_handle: SocketHandle::default(),
            arp_cache: None,
            loopback_replies: VecDeque::new(),
        };
        
        state.icmp_handle = state.sockets.add(icmp_socket);
        state.udp_handle = state.sockets.add(udp_socket);
        state.tcp_handle = state.sockets.add(tcp_socket);
        
        Ok(state)
    }
    
    /// Finalize initialization (must be called AFTER the NetState is in its final memory location)
    pub fn finalize(&mut self) {
        self.device.finalize_init();
    }
    
    /// Poll the network stack (call frequently)
    pub fn poll(&mut self, timestamp_ms: i64) {
        let timestamp = Instant::from_millis(timestamp_ms);
        
        // Poll the device
        self.device.poll();
        
        // Poll the interface
        self.iface.poll(timestamp, &mut DeviceWrapper(&mut self.device), &mut self.sockets);
    }
    
    /// Send a raw ARP request
    fn send_arp_request(&mut self, target_ip: [u8; 4]) -> Result<(), &'static str> {
        let my_ip = get_my_ip();
        let mut frame = [0u8; 42]; // 14 (eth) + 28 (arp)
        
        // Ethernet header
        frame[0..6].copy_from_slice(&[0xff, 0xff, 0xff, 0xff, 0xff, 0xff]); // dst = broadcast
        frame[6..12].copy_from_slice(&self.device.mac); // src = our MAC
        frame[12..14].copy_from_slice(&[0x08, 0x06]); // ethertype = ARP
        
        // ARP header
        frame[14..16].copy_from_slice(&[0x00, 0x01]); // hardware type = ethernet
        frame[16..18].copy_from_slice(&[0x08, 0x00]); // protocol type = IPv4
        frame[18] = 6; // hardware addr len
        frame[19] = 4; // protocol addr len
        frame[20..22].copy_from_slice(&[0x00, 0x01]); // operation = request
        frame[22..28].copy_from_slice(&self.device.mac); // sender hardware addr
        frame[28..32].copy_from_slice(&my_ip.0); // sender protocol addr
        frame[32..38].copy_from_slice(&[0x00; 6]); // target hardware addr (unknown)
        frame[38..42].copy_from_slice(&target_ip); // target protocol addr
        
        self.device.send(&frame)
    }
    
    /// Compute ICMP checksum
    fn icmp_checksum(data: &[u8]) -> u16 {
        let mut sum: u32 = 0;
        let mut i = 0;
        while i + 1 < data.len() {
            sum += u16::from_be_bytes([data[i], data[i + 1]]) as u32;
            i += 2;
        }
        if i < data.len() {
            sum += (data[i] as u32) << 8;
        }
        while sum > 0xFFFF {
            sum = (sum & 0xFFFF) + (sum >> 16);
        }
        !(sum as u16)
    }
    
    /// Resolve MAC address for an IP via ARP (with caching)
    fn resolve_mac(&mut self, target_ip: [u8; 4]) -> Option<[u8; 6]> {
        // Check cache first
        if let Some(ref cache) = self.arp_cache {
            if cache.ip == target_ip {
                return Some(cache.mac);
            }
        }
        
        // Try multiple times with increasing waits
        for attempt in 0..5 {
            // Send ARP request
            if attempt == 0 || attempt == 2 {
                // Resend ARP on first attempt and after some retries
                if self.send_arp_request(target_ip).is_err() {
                    continue;
                }
            }
            
            // Wait with increasing delay (100k, 200k, 400k, 800k, 1600k spins)
            let wait_cycles = 100_000 << attempt;
            for _ in 0..wait_cycles { 
                core::hint::spin_loop(); 
            }
            self.device.poll();
            
            // Check for ARP reply
            if let Some((desc_idx, data)) = self.device.recv_with_desc() {
                if data.len() >= 42 && data[12] == 0x08 && data[13] == 0x06 {
                    // ARP packet - extract sender MAC
                    let mut mac = [0u8; 6];
                    mac.copy_from_slice(&data[22..28]);
                    
                    // Recycle the buffer
                    self.device.recycle_rx(desc_idx);
                    
                    // Cache the result
                    self.arp_cache = Some(ArpCache { ip: target_ip, mac });
                    
                    return Some(mac);
                }
                // Not an ARP reply, recycle and keep trying
                self.device.recycle_rx(desc_idx);
            }
        }
        
        None
    }
    
    /// Check if an address is a loopback address (127.x.x.x)
    fn is_loopback(addr: &Ipv4Address) -> bool {
        addr.0[0] == 127
    }
    
    /// Check if an address is our own IP
    fn is_self(addr: &Ipv4Address) -> bool {
        let my_ip = get_my_ip();
        addr.0 == my_ip.0
    }
    
    /// Check if an address is on the local subnet (10.0.2.x/24)
    fn is_on_local_subnet(addr: &Ipv4Address) -> bool {
        let my_ip = get_my_ip();
        addr.0[0] == my_ip.0[0] && 
        addr.0[1] == my_ip.0[1] && 
        addr.0[2] == my_ip.0[2]
    }
    
    /// Send an ICMP echo request (ping) - directly via VirtIO or loopback
    pub fn send_ping(&mut self, target: Ipv4Address, seq: u16, _timestamp_ms: i64) -> Result<(), &'static str> {
        // Handle loopback addresses (127.x.x.x) and self-ping locally
        if Self::is_loopback(&target) || Self::is_self(&target) {
            // Queue an immediate reply for loopback
            self.loopback_replies.push_back(LoopbackReply {
                from: target,
                ident: ICMP_IDENT,
                seq,
            });
            return Ok(());
        }
        
        let target_bytes = target.0;
        
        // For external IPs (not on local subnet), route through gateway
        let next_hop = if Self::is_on_local_subnet(&target) {
            target_bytes
        } else {
            GATEWAY.0  // Use gateway for external destinations
        };
        
        // Resolve MAC address for the next hop (gateway or direct target)
        let dst_mac = self.resolve_mac(next_hop)
            .ok_or("Failed to resolve MAC address")?;
        
        // Build Ethernet + IP + ICMP packet
        let icmp_data = b"RISCV_PING";
        let icmp_len = 8 + icmp_data.len(); // ICMP header (8) + data
        let ip_len = 20 + icmp_len; // IP header (20) + ICMP
        let frame_len = 14 + ip_len; // Ethernet header (14) + IP
        
        let mut frame = vec![0u8; frame_len];
        
        // Ethernet header
        frame[0..6].copy_from_slice(&dst_mac); // dst MAC
        frame[6..12].copy_from_slice(&self.device.mac); // src MAC
        frame[12..14].copy_from_slice(&[0x08, 0x00]); // ethertype = IPv4
        
        // IP header
        let my_ip = get_my_ip();
        frame[14] = 0x45; // version + IHL
        frame[15] = 0; // TOS
        frame[16..18].copy_from_slice(&(ip_len as u16).to_be_bytes()); // total length
        frame[18..20].copy_from_slice(&ICMP_IDENT.to_be_bytes()); // identification
        frame[20..22].copy_from_slice(&[0x00, 0x00]); // flags + fragment
        frame[22] = 64; // TTL
        frame[23] = 1; // protocol = ICMP
        frame[24..26].copy_from_slice(&[0x00, 0x00]); // checksum (fill later)
        frame[26..30].copy_from_slice(&my_ip.0); // src IP
        frame[30..34].copy_from_slice(&target_bytes); // dst IP
        
        // IP checksum
        let ip_header = &frame[14..34];
        let mut sum: u32 = 0;
        for i in (0..20).step_by(2) {
            sum += u16::from_be_bytes([ip_header[i], ip_header[i + 1]]) as u32;
        }
        while sum > 0xFFFF {
            sum = (sum & 0xFFFF) + (sum >> 16);
        }
        let ip_cksum = !(sum as u16);
        frame[24..26].copy_from_slice(&ip_cksum.to_be_bytes());
        
        // ICMP header
        frame[34] = 8; // type = echo request
        frame[35] = 0; // code
        frame[36..38].copy_from_slice(&[0x00, 0x00]); // checksum (fill later)
        frame[38..40].copy_from_slice(&ICMP_IDENT.to_be_bytes()); // identifier
        frame[40..42].copy_from_slice(&seq.to_be_bytes()); // sequence
        frame[42..].copy_from_slice(icmp_data); // data
        
        // ICMP checksum
        let icmp_cksum = Self::icmp_checksum(&frame[34..]);
        frame[36..38].copy_from_slice(&icmp_cksum.to_be_bytes());
        
        // Send the ICMP request
        self.device.send(&frame)?;
        
        Ok(())
    }
    
    /// Get MAC address
    #[allow(dead_code)]
    pub fn mac(&self) -> [u8; 6] {
        self.device.mac
    }
    
    /// Get MAC address as string
    pub fn mac_str(&self) -> [u8; 17] {
        self.device.mac_str()
    }
    
    /// Check for ICMP echo reply by directly examining received packets
    /// Also handles loopback replies
    pub fn check_ping_reply(&mut self) -> Option<(Ipv4Address, u16, u16)> {
        // First check for loopback replies (highest priority, instant)
        if let Some(reply) = self.loopback_replies.pop_front() {
            return Some((reply.from, reply.ident, reply.seq));
        }
        
        // Poll the VirtIO device for incoming packets
        self.device.poll();
        
        // Check for received packet
        if let Some((desc_idx, data)) = self.device.recv_with_desc() {
            // Must be at least: eth(14) + ip(20) + icmp(8) = 42 bytes
            if data.len() >= 42 {
                // Check for IPv4 (ethertype 0x0800)
                if data[12] == 0x08 && data[13] == 0x00 {
                    // Check IP protocol is ICMP (1)
                    if data[23] == 1 {
                        // Check ICMP type is echo reply (0)
                        if data[34] == 0 {
                            // Parse ICMP echo reply
                            let ident = u16::from_be_bytes([data[38], data[39]]);
                            let seq = u16::from_be_bytes([data[40], data[41]]);
                            let src_ip = Ipv4Address::new(data[26], data[27], data[28], data[29]);
                            
                            // Recycle the buffer
                            self.device.recycle_rx(desc_idx);
                            
                            // Check if this is for our identifier
                            if ident == ICMP_IDENT {
                                return Some((src_ip, ident, seq));
                            }
                        }
                    }
                }
            }
            
            // Recycle buffer if we didn't return earlier
            self.device.recycle_rx(desc_idx);
        }
        None
    }
    
    /// Send a UDP packet to the specified destination
    pub fn udp_send(&mut self, dest_ip: Ipv4Address, dest_port: u16, data: &[u8], timestamp_ms: i64) -> Result<(), &'static str> {
        let timestamp = Instant::from_millis(timestamp_ms);
        
        // Get the UDP socket
        let socket = self.sockets.get_mut::<udp::Socket>(self.udp_handle);
        
        // Create destination endpoint
        let endpoint = IpEndpoint::new(IpAddress::Ipv4(dest_ip), dest_port);
        
        // Check if socket can send
        if !socket.can_send() {
            return Err("UDP socket cannot send");
        }
        
        // Send the data
        socket.send_slice(data, endpoint)
            .map_err(|_| "Failed to send UDP packet")?;
        
        // Poll to actually transmit
        self.iface.poll(timestamp, &mut DeviceWrapper(&mut self.device), &mut self.sockets);
        
        Ok(())
    }
    
    /// Receive a UDP packet (non-blocking)
    /// Returns (source_ip, source_port, data) if a packet is available
    pub fn udp_recv(&mut self, buf: &mut [u8], timestamp_ms: i64) -> Option<(Ipv4Address, u16, usize)> {
        let timestamp = Instant::from_millis(timestamp_ms);
        
        // Poll to receive any pending packets
        self.iface.poll(timestamp, &mut DeviceWrapper(&mut self.device), &mut self.sockets);
        
        // Get the UDP socket
        let socket = self.sockets.get_mut::<udp::Socket>(self.udp_handle);
        
        // Check if we can receive
        if !socket.can_recv() {
            return None;
        }
        
        // Try to receive
        match socket.recv_slice(buf) {
            Ok((len, meta)) => {
                let IpAddress::Ipv4(src_ip) = meta.endpoint.addr;
                Some((src_ip, meta.endpoint.port, len))
            }
            Err(_) => None,
        }
    }
    
    /// Check if UDP socket can receive data
    pub fn udp_can_recv(&mut self) -> bool {
        let socket = self.sockets.get_mut::<udp::Socket>(self.udp_handle);
        socket.can_recv()
    }
    
    // ═══════════════════════════════════════════════════════════════════════════
    // TCP METHODS (for HTTP connections)
    // ═══════════════════════════════════════════════════════════════════════════
    
    /// Connect TCP socket to a remote host
    pub fn tcp_connect(&mut self, dest_ip: Ipv4Address, dest_port: u16, timestamp_ms: i64) -> Result<(), &'static str> {
        let timestamp = Instant::from_millis(timestamp_ms);
        
        // Get the TCP socket
        let socket = self.sockets.get_mut::<tcp::Socket>(self.tcp_handle);
        
        // Close any existing connection
        if socket.state() != tcp::State::Closed {
            socket.abort();
            // Poll to process the abort
            self.iface.poll(timestamp, &mut DeviceWrapper(&mut self.device), &mut self.sockets);
        }
        
        // Use a random-ish local port based on timestamp
        let local_port = 49152 + ((timestamp_ms as u16) % 16383);
        
        // Create destination endpoint
        let remote = IpEndpoint::new(IpAddress::Ipv4(dest_ip), dest_port);
        
        // Get the socket again after the iface poll
        let socket = self.sockets.get_mut::<tcp::Socket>(self.tcp_handle);
        
        // Connect to remote
        socket.connect(self.iface.context(), remote, local_port)
            .map_err(|_| "Failed to initiate TCP connection")?;
        
        Ok(())
    }
    
    /// Check if TCP socket is connected
    pub fn tcp_is_connected(&mut self) -> bool {
        let socket = self.sockets.get_mut::<tcp::Socket>(self.tcp_handle);
        socket.state() == tcp::State::Established
    }
    
    /// Check if TCP socket is connecting (SYN sent)
    pub fn tcp_is_connecting(&mut self) -> bool {
        let socket = self.sockets.get_mut::<tcp::Socket>(self.tcp_handle);
        matches!(socket.state(), tcp::State::SynSent | tcp::State::SynReceived)
    }
    
    /// Check if TCP connection failed
    pub fn tcp_connection_failed(&mut self) -> bool {
        let socket = self.sockets.get_mut::<tcp::Socket>(self.tcp_handle);
        matches!(socket.state(), tcp::State::Closed | tcp::State::TimeWait)
    }
    
    /// Send data over TCP connection
    pub fn tcp_send(&mut self, data: &[u8], timestamp_ms: i64) -> Result<usize, &'static str> {
        let timestamp = Instant::from_millis(timestamp_ms);
        
        // Get the TCP socket
        let socket = self.sockets.get_mut::<tcp::Socket>(self.tcp_handle);
        
        if !socket.may_send() {
            return Err("TCP socket cannot send");
        }
        
        let sent = socket.send_slice(data)
            .map_err(|_| "Failed to send TCP data")?;
        
        // Poll to transmit
        self.iface.poll(timestamp, &mut DeviceWrapper(&mut self.device), &mut self.sockets);
        
        Ok(sent)
    }
    
    /// Receive data from TCP connection (non-blocking)
    pub fn tcp_recv(&mut self, buf: &mut [u8], timestamp_ms: i64) -> Result<usize, &'static str> {
        let timestamp = Instant::from_millis(timestamp_ms);
        
        // Poll to receive any pending packets
        self.iface.poll(timestamp, &mut DeviceWrapper(&mut self.device), &mut self.sockets);
        
        // Get the TCP socket
        let socket = self.sockets.get_mut::<tcp::Socket>(self.tcp_handle);
        
        if !socket.may_recv() {
            if socket.state() == tcp::State::CloseWait || socket.state() == tcp::State::Closed {
                return Err("Connection closed by peer");
            }
            return Ok(0);
        }
        
        match socket.recv_slice(buf) {
            Ok(len) => Ok(len),
            Err(_) => Ok(0),
        }
    }
    
    /// Check if TCP socket can receive data
    pub fn tcp_can_recv(&mut self) -> bool {
        let socket = self.sockets.get_mut::<tcp::Socket>(self.tcp_handle);
        socket.may_recv() && socket.recv_queue() > 0
    }
    
    /// Close TCP connection gracefully
    pub fn tcp_close(&mut self, timestamp_ms: i64) {
        let timestamp = Instant::from_millis(timestamp_ms);
        
        let socket = self.sockets.get_mut::<tcp::Socket>(self.tcp_handle);
        socket.close();
        
        // Poll to process the close
        self.iface.poll(timestamp, &mut DeviceWrapper(&mut self.device), &mut self.sockets);
    }
    
    /// Abort TCP connection immediately
    pub fn tcp_abort(&mut self) {
        let socket = self.sockets.get_mut::<tcp::Socket>(self.tcp_handle);
        socket.abort();
    }
    
    /// Get TCP socket state (for debugging)
    pub fn tcp_state(&mut self) -> &'static str {
        let socket = self.sockets.get_mut::<tcp::Socket>(self.tcp_handle);
        match socket.state() {
            tcp::State::Closed => "Closed",
            tcp::State::Listen => "Listen",
            tcp::State::SynSent => "SynSent",
            tcp::State::SynReceived => "SynReceived",
            tcp::State::Established => "Established",
            tcp::State::FinWait1 => "FinWait1",
            tcp::State::FinWait2 => "FinWait2",
            tcp::State::CloseWait => "CloseWait",
            tcp::State::Closing => "Closing",
            tcp::State::LastAck => "LastAck",
            tcp::State::TimeWait => "TimeWait",
        }
    }
}

/// Wrapper for VirtioNet to implement smoltcp Device trait
struct DeviceWrapper<'a>(&'a mut VirtioNet);

impl Device for DeviceWrapper<'_> {
    type RxToken<'a> = VirtioRxToken where Self: 'a;
    type TxToken<'a> = VirtioTxToken<'a> where Self: 'a;
    
    fn capabilities(&self) -> DeviceCapabilities {
        let mut caps = DeviceCapabilities::default();
        caps.medium = Medium::Ethernet;
        caps.max_transmission_unit = 1500; // Standard Ethernet MTU (IP payload size)
        caps.max_burst_size = Some(1);
        caps
    }
    
    fn receive(&mut self, _timestamp: Instant) -> Option<(Self::RxToken<'_>, Self::TxToken<'_>)> {
        // Check if there's a received packet
        if let Some((desc_idx, data)) = self.0.recv_with_desc() {
            // Copy data since we need to recycle the buffer
            let mut buf = vec![0u8; data.len()];
            buf.copy_from_slice(data);
            
            // Recycle the RX buffer immediately
            self.0.recycle_rx(desc_idx);
            
            Some((
                VirtioRxToken { buffer: buf },
                VirtioTxToken { device: self.0 },
            ))
        } else {
            None
        }
    }
    
    fn transmit(&mut self, _timestamp: Instant) -> Option<Self::TxToken<'_>> {
        // Always allow transmit (the device will handle buffer exhaustion)
        Some(VirtioTxToken { device: self.0 })
    }
}

/// RX token for received packets
struct VirtioRxToken {
    buffer: Vec<u8>,
}

impl RxToken for VirtioRxToken {
    fn consume<R, F>(self, f: F) -> R
    where
        F: FnOnce(&mut [u8]) -> R,
    {
        let mut buffer = self.buffer;
        f(&mut buffer)
    }
}

/// TX token for transmitting packets
struct VirtioTxToken<'a> {
    device: &'a mut VirtioNet,
}

impl TxToken for VirtioTxToken<'_> {
    fn consume<R, F>(self, len: usize, f: F) -> R
    where
        F: FnOnce(&mut [u8]) -> R,
    {
        let mut buffer = vec![0u8; len];
        let result = f(&mut buffer);
        
        // Send the packet
        if let Err(e) = self.device.send(&buffer) {
            // Log error but don't fail (network errors are recoverable)
            crate::uart::write_str("TX error: ");
            crate::uart::write_line(e);
        }
        
        result
    }
}

/// Parse an IPv4 address from bytes
pub fn parse_ipv4(s: &[u8]) -> Option<Ipv4Address> {
    let mut octets = [0u8; 4];
    let mut octet_idx = 0;
    let mut current = 0u16;
    let mut has_digit = false;
    
    for &b in s {
        if b >= b'0' && b <= b'9' {
            current = current * 10 + (b - b'0') as u16;
            has_digit = true;
            if current > 255 {
                return None;
            }
        } else if b == b'.' {
            if !has_digit || octet_idx >= 3 {
                return None;
            }
            octets[octet_idx] = current as u8;
            octet_idx += 1;
            current = 0;
            has_digit = false;
        } else {
            return None;
        }
    }
    
    if !has_digit || octet_idx != 3 {
        return None;
    }
    octets[3] = current as u8;
    
    Some(Ipv4Address::new(octets[0], octets[1], octets[2], octets[3]))
}

/// Format an IPv4 address to a buffer
pub fn format_ipv4(addr: Ipv4Address, buf: &mut [u8]) -> usize {
    let octets = addr.0;
    let mut pos = 0;
    
    for (i, &octet) in octets.iter().enumerate() {
        // Write octet
        if octet >= 100 {
            buf[pos] = b'0' + (octet / 100);
            pos += 1;
        }
        if octet >= 10 {
            buf[pos] = b'0' + ((octet / 10) % 10);
            pos += 1;
        }
        buf[pos] = b'0' + (octet % 10);
        pos += 1;
        
        // Write dot (except after last octet)
        if i < 3 {
            buf[pos] = b'.';
            pos += 1;
        }
    }
    
    pos
}
</file>

<file path="riscv-vm/src/dram.rs">
// WASM builds use SharedArrayBuffer
#[cfg(target_arch = "wasm32")]
use js_sys::{Atomics, DataView, Int32Array, SharedArrayBuffer, Uint8Array};

use thiserror::Error;
#[cfg(not(target_arch = "wasm32"))]
use std::cell::UnsafeCell;
#[cfg(not(target_arch = "wasm32"))]
use std::sync::atomic::{AtomicU32, AtomicU64, Ordering};

/// Base physical address of DRAM as seen by devices that work directly with
/// physical addresses (VirtIO, etc.).
///
/// This matches the DRAM base used by the `SystemBus` in `bus.rs` and the
/// Phase-0 virt memory map.
pub const DRAM_BASE: u64 = 0x8000_0000;

/// Device-local memory access errors.
///
/// These are mapped into architectural traps (`Trap`) by higher layers
/// (e.g., the system bus) where appropriate.
#[derive(Debug, Error)]
pub enum MemoryError {
    #[error("Out-of-bounds memory access at {0:#x}")]
    OutOfBounds(u64),

    #[error("Invalid or misaligned access at {0:#x}")]
    InvalidAlignment(u64),
}

/// High-performance DRAM backing store.
///
/// On native: Uses UnsafeCell for lock-free memory access. This is safe because:
/// - RISC-V memory model allows concurrent reads/writes without synchronization
/// - Each hart operates on different memory regions most of the time
/// - Atomicity is only required for LR/SC and AMO instructions (handled at CPU level)
///
/// On WASM: Uses SharedArrayBuffer with DataView for typed array access.
///
/// Offsets passed to the load/store helpers are **physical offsets from
/// `DRAM_BASE`**, not full guest physical addresses. Callers typically use
/// `DRAM_BASE` and subtract it via a helper (see `virtio.rs`).
///
/// # Safety
/// 
/// Native: The RISC-V weak memory model permits data races on regular loads/stores.
/// Only atomic operations (AMO, LR/SC) require synchronization, which is handled
/// by the CPU emulation. This matches how real hardware works.
///
/// WASM: SharedArrayBuffer is designed for sharing between Web Workers.
/// Each worker creates its own Dram instance via from_shared(), pointing to the
/// same underlying buffer.
pub struct Dram {
    pub base: u64,

    #[cfg(not(target_arch = "wasm32"))]
    size: usize, // Cached size (immutable after creation)
    #[cfg(not(target_arch = "wasm32"))]
    data: UnsafeCell<Vec<u8>>, // Lock-free memory access

    #[cfg(target_arch = "wasm32")]
    buffer: SharedArrayBuffer,
    #[cfg(target_arch = "wasm32")]
    view: Uint8Array,
    #[cfg(target_arch = "wasm32")]
    data_view: DataView,
    /// Int32Array view for atomic operations (JavaScript Atomics API requires typed arrays)
    #[cfg(target_arch = "wasm32")]
    atomic_view: Int32Array,
    /// Byte offset of DRAM region within the SharedArrayBuffer
    #[cfg(target_arch = "wasm32")]
    byte_offset: usize,
    /// DRAM size in bytes (may be less than buffer.byte_length() when using shared memory)
    #[cfg(target_arch = "wasm32")]
    dram_size: usize,
}

// SAFETY: Dram uses lock-free memory access which is safe for RISC-V emulation:
// - Regular loads/stores don't require synchronization (RISC-V weak memory model)
// - Atomic operations (LR/SC, AMO) are emulated with proper synchronization at CPU level
// - WASM: SharedArrayBuffer is designed for multi-threaded access
unsafe impl Send for Dram {}
unsafe impl Sync for Dram {}

// ============================================================================
// NATIVE IMPLEMENTATION - Lock-Free High Performance
// ============================================================================

#[cfg(not(target_arch = "wasm32"))]
impl Dram {
    /// Create a new DRAM image of `size` bytes, zero-initialised.
    pub fn new(base: u64, size: usize) -> Self {
        Self {
            base,
            size,
            data: UnsafeCell::new(vec![0; size]),
        }
    }

    /// Get the size of DRAM in bytes.
    #[inline(always)]
    pub fn size(&self) -> usize {
        self.size
    }

    /// Get direct pointer to memory for maximum performance.
    /// 
    /// # Safety
    /// Caller must ensure proper synchronization for atomic operations.
    #[inline(always)]
    unsafe fn mem_ptr(&self) -> *mut u8 {
        // SAFETY: UnsafeCell::get() returns a raw pointer which we dereference
        // to get the Vec's data pointer. This is safe because the Vec lives
        // for the lifetime of Dram.
        unsafe { (*self.data.get()).as_mut_ptr() }
    }

    #[inline(always)]
    pub fn offset(&self, addr: u64) -> Option<usize> {
        // Use wrapping_sub to avoid branch on underflow check
        let off = addr.wrapping_sub(self.base) as usize;
        if off < self.size {
            Some(off)
        } else {
            None
        }
    }

    /// Load data into DRAM at the given offset.
    pub fn load(&self, data: &[u8], offset: u64) -> Result<(), MemoryError> {
        self.write_bytes(offset, data)
    }

    pub fn zero_range(&self, offset: usize, len: usize) -> Result<(), MemoryError> {
        if offset + len > self.size {
            return Err(MemoryError::OutOfBounds(offset as u64));
        }
        // SAFETY: Bounds checked above, and this is used during initialization
        unsafe {
            let ptr = self.mem_ptr().add(offset);
            std::ptr::write_bytes(ptr, 0, len);
        }
        Ok(())
    }

    // ========== READ METHODS (Lock-Free) ==========

    #[inline(always)]
    pub fn load_8(&self, offset: u64) -> Result<u8, MemoryError> {
        let off = offset as usize;
        if off >= self.size {
            return Err(MemoryError::OutOfBounds(offset));
        }
        // SAFETY: Bounds checked, lock-free read is safe for RISC-V memory model
        unsafe {
            Ok(*self.mem_ptr().add(off))
        }
    }

    #[inline(always)]
    pub fn load_16(&self, offset: u64) -> Result<u16, MemoryError> {
        if offset % 2 != 0 {
            return Err(MemoryError::InvalidAlignment(offset));
        }
        let off = offset as usize;
        if off + 2 > self.size {
            return Err(MemoryError::OutOfBounds(offset));
        }
        // SAFETY: Alignment and bounds checked, use unaligned read for portability
        unsafe {
            let ptr = self.mem_ptr().add(off) as *const u16;
            Ok(ptr.read_unaligned().to_le())
        }
    }

    #[inline(always)]
    pub fn load_32(&self, offset: u64) -> Result<u32, MemoryError> {
        if offset % 4 != 0 {
            return Err(MemoryError::InvalidAlignment(offset));
        }
        let off = offset as usize;
        if off + 4 > self.size {
            return Err(MemoryError::OutOfBounds(offset));
        }
        // Use atomic load with SeqCst to ensure visibility across threads.
        // This is crucial for spinlock synchronization in SMP mode.
        unsafe {
            let ptr = self.mem_ptr().add(off) as *const AtomicU32;
            Ok((*ptr).load(Ordering::SeqCst).to_le())
        }
    }

    #[inline(always)]
    pub fn load_64(&self, offset: u64) -> Result<u64, MemoryError> {
        if offset % 8 != 0 {
            return Err(MemoryError::InvalidAlignment(offset));
        }
        let off = offset as usize;
        if off + 8 > self.size {
            return Err(MemoryError::OutOfBounds(offset));
        }
        // Use atomic load with SeqCst to ensure visibility across threads.
        // This is crucial for spinlock synchronization in SMP mode.
        unsafe {
            let ptr = self.mem_ptr().add(off) as *const AtomicU64;
            Ok((*ptr).load(Ordering::SeqCst).to_le())
        }
    }

    // ========== WRITE METHODS (Lock-Free) ==========

    #[inline(always)]
    pub fn store_8(&self, offset: u64, value: u64) -> Result<(), MemoryError> {
        let off = offset as usize;
        if off >= self.size {
            return Err(MemoryError::OutOfBounds(offset));
        }
        // SAFETY: Bounds checked, lock-free write is safe for RISC-V memory model
        unsafe {
            *self.mem_ptr().add(off) = (value & 0xff) as u8;
        }
        Ok(())
    }

    #[inline(always)]
    pub fn store_16(&self, offset: u64, value: u64) -> Result<(), MemoryError> {
        if offset % 2 != 0 {
            return Err(MemoryError::InvalidAlignment(offset));
        }
        let off = offset as usize;
        if off + 2 > self.size {
            return Err(MemoryError::OutOfBounds(offset));
        }
        // SAFETY: Alignment and bounds checked
        unsafe {
            let ptr = self.mem_ptr().add(off) as *mut u16;
            ptr.write_unaligned((value as u16).to_le());
        }
        Ok(())
    }

    #[inline(always)]
    pub fn store_32(&self, offset: u64, value: u64) -> Result<(), MemoryError> {
        if offset % 4 != 0 {
            return Err(MemoryError::InvalidAlignment(offset));
        }
        let off = offset as usize;
        if off + 4 > self.size {
            return Err(MemoryError::OutOfBounds(offset));
        }
        // Use atomic store with SeqCst to ensure visibility across threads.
        // This is crucial for spinlock synchronization in SMP mode.
        unsafe {
            let ptr = self.mem_ptr().add(off) as *const AtomicU32;
            (*ptr).store((value as u32).to_le(), Ordering::SeqCst);
        }
        Ok(())
    }

    #[inline(always)]
    pub fn store_64(&self, offset: u64, value: u64) -> Result<(), MemoryError> {
        if offset % 8 != 0 {
            return Err(MemoryError::InvalidAlignment(offset));
        }
        let off = offset as usize;
        if off + 8 > self.size {
            return Err(MemoryError::OutOfBounds(offset));
        }
        // Use atomic store with SeqCst to ensure visibility across threads.
        // This is crucial for spinlock synchronization in SMP mode.
        unsafe {
            let ptr = self.mem_ptr().add(off) as *const AtomicU64;
            (*ptr).store(value.to_le(), Ordering::SeqCst);
        }
        Ok(())
    }

    /// Write an arbitrary slice into DRAM starting at `offset`.
    pub fn write_bytes(&self, offset: u64, data: &[u8]) -> Result<(), MemoryError> {
        let off = offset as usize;
        if off + data.len() > self.size {
            return Err(MemoryError::OutOfBounds(offset));
        }
        // SAFETY: Bounds checked
        unsafe {
            let dst = self.mem_ptr().add(off);
            std::ptr::copy_nonoverlapping(data.as_ptr(), dst, data.len());
        }
        Ok(())
    }

    // ========== SNAPSHOT HELPERS ==========

    /// Read a range of bytes from DRAM (for signature extraction, snapshots).
    pub fn read_range(&self, offset: usize, len: usize) -> Result<Vec<u8>, MemoryError> {
        if offset + len > self.size {
            return Err(MemoryError::OutOfBounds(offset as u64));
        }
        // SAFETY: Bounds checked
        unsafe {
            let mem = &*self.data.get();
            Ok(mem[offset..offset + len].to_vec())
        }
    }

    /// Get a clone of all DRAM contents (for snapshots).
    pub fn get_data(&self) -> Vec<u8> {
        // SAFETY: Clone is atomic enough for snapshots
        unsafe {
            (*self.data.get()).clone()
        }
    }

    /// Replace all DRAM contents (for snapshot restore).
    pub fn set_data(&self, data: &[u8]) -> Result<(), MemoryError> {
        if data.len() != self.size {
            return Err(MemoryError::OutOfBounds(data.len() as u64));
        }
        // SAFETY: Size checked, restore should be done while VM is paused
        unsafe {
            (*self.data.get()).clone_from_slice(data);
        }
        Ok(())
    }
}

// ============================================================================
// WASM IMPLEMENTATION (SharedArrayBuffer + DataView for Performance)
// ============================================================================

#[cfg(target_arch = "wasm32")]
impl Dram {
    /// Create new DRAM backed by SharedArrayBuffer.
    pub fn new(base: u64, size: usize) -> Self {
        let buffer = SharedArrayBuffer::new(size as u32);
        let view = Uint8Array::new(&buffer);
        let data_view = DataView::new_with_shared_array_buffer(&buffer, 0, size);
        // Int32Array view for atomic operations (covers entire buffer)
        let atomic_view = Int32Array::new(&buffer);
        // Zero-initialize
        view.fill(0, 0, size as u32);
        Self { base, buffer, view, data_view, atomic_view, byte_offset: 0, dram_size: size }
    }

    /// Create DRAM from existing SharedArrayBuffer with a byte offset.
    ///
    /// Used by Web Workers to attach to shared memory created by main thread.
    /// The `byte_offset` specifies where DRAM data starts within the SharedArrayBuffer.
    /// The DRAM size is calculated as (buffer.byte_length - byte_offset).
    ///
    /// IMPORTANT: This creates views into the SAME buffer, not a copy.
    /// SharedArrayBuffer::slice() creates a copy, which breaks shared memory!
    pub fn from_shared(base: u64, buffer: SharedArrayBuffer, byte_offset: usize) -> Self {
        let total_size = buffer.byte_length() as usize;
        let dram_size = total_size.saturating_sub(byte_offset);
        
        // Create views with byte offset into the shared buffer
        // This is the key fix: we use the SAME buffer with an offset, not a sliced copy
        let view = Uint8Array::new_with_byte_offset_and_length(
            &buffer, 
            byte_offset as u32, 
            dram_size as u32
        );
        let data_view = DataView::new_with_shared_array_buffer(&buffer, byte_offset, dram_size);
        
        // Int32Array view for atomic operations (covers entire buffer including headers)
        // The index conversion must account for byte_offset when doing atomic ops
        let atomic_view = Int32Array::new(&buffer);
        
        Self { base, buffer, view, data_view, atomic_view, byte_offset, dram_size }
    }

    /// Get the underlying SharedArrayBuffer (for passing to workers).
    pub fn shared_buffer(&self) -> SharedArrayBuffer {
        self.buffer.clone()
    }

    /// Get the size of DRAM in bytes.
    #[inline(always)]
    pub fn size(&self) -> usize {
        self.dram_size
    }

    /// Check if an address is within DRAM and return offset.
    #[inline(always)]
    pub fn offset(&self, addr: u64) -> Option<usize> {
        let off = addr.wrapping_sub(self.base) as usize;
        if off < self.size() {
            Some(off)
        } else {
            None
        }
    }

    // ========== READ METHODS (DataView for typed access) ==========

    #[inline(always)]
    pub fn load_8(&self, offset: u64) -> Result<u8, MemoryError> {
        let off = offset as usize;
        if off >= self.size() {
            return Err(MemoryError::OutOfBounds(offset));
        }
        Ok(self.data_view.get_uint8(off))
    }

    #[inline(always)]
    pub fn load_16(&self, offset: u64) -> Result<u16, MemoryError> {
        if offset % 2 != 0 {
            return Err(MemoryError::InvalidAlignment(offset));
        }
        let off = offset as usize;
        if off + 2 > self.size() {
            return Err(MemoryError::OutOfBounds(offset));
        }
        // DataView with little_endian=true for direct u16 read
        Ok(self.data_view.get_uint16_endian(off, true))
    }

    #[inline(always)]
    pub fn load_32(&self, offset: u64) -> Result<u32, MemoryError> {
        if offset % 4 != 0 {
            return Err(MemoryError::InvalidAlignment(offset));
        }
        let off = offset as usize;
        if off + 4 > self.size() {
            return Err(MemoryError::OutOfBounds(offset));
        }
        // CRITICAL: Use Atomics.load() for cross-worker visibility!
        // Non-atomic DataView reads may be cached by JavaScript engines,
        // breaking spinlock synchronization in SMP mode.
        let idx = self.atomic_index(off);
        let val = Atomics::load(&self.atomic_view, idx).unwrap_or(0);
        Ok(val as u32)
    }

    #[inline(always)]
    pub fn load_64(&self, offset: u64) -> Result<u64, MemoryError> {
        if offset % 8 != 0 {
            return Err(MemoryError::InvalidAlignment(offset));
        }
        let off = offset as usize;
        if off + 8 > self.size() {
            return Err(MemoryError::OutOfBounds(offset));
        }
        // Use atomic loads for cross-worker visibility
        let idx_lo = self.atomic_index(off);
        let idx_hi = self.atomic_index(off + 4);
        let lo = Atomics::load(&self.atomic_view, idx_lo).unwrap_or(0) as u32 as u64;
        let hi = Atomics::load(&self.atomic_view, idx_hi).unwrap_or(0) as u32 as u64;
        Ok(lo | (hi << 32))
    }

    // ========== WRITE METHODS (DataView for typed access) ==========

    #[inline(always)]
    pub fn store_8(&self, offset: u64, value: u64) -> Result<(), MemoryError> {
        let off = offset as usize;
        if off >= self.size() {
            return Err(MemoryError::OutOfBounds(offset));
        }
        self.data_view.set_uint8(off, (value & 0xff) as u8);
        Ok(())
    }

    #[inline(always)]
    pub fn store_16(&self, offset: u64, value: u64) -> Result<(), MemoryError> {
        if offset % 2 != 0 {
            return Err(MemoryError::InvalidAlignment(offset));
        }
        let off = offset as usize;
        if off + 2 > self.size() {
            return Err(MemoryError::OutOfBounds(offset));
        }
        // DataView with little_endian=true for direct u16 write
        self.data_view.set_uint16_endian(off, value as u16, true);
        Ok(())
    }

    #[inline(always)]
    pub fn store_32(&self, offset: u64, value: u64) -> Result<(), MemoryError> {
        if offset % 4 != 0 {
            return Err(MemoryError::InvalidAlignment(offset));
        }
        let off = offset as usize;
        if off + 4 > self.size() {
            return Err(MemoryError::OutOfBounds(offset));
        }
        // CRITICAL: Use Atomics.store() for cross-worker visibility!
        // Non-atomic DataView writes may not be visible to other workers,
        // breaking spinlock synchronization in SMP mode.
        let idx = self.atomic_index(off);
        let _ = Atomics::store(&self.atomic_view, idx, value as i32);
        Ok(())
    }

    #[inline(always)]
    pub fn store_64(&self, offset: u64, value: u64) -> Result<(), MemoryError> {
        if offset % 8 != 0 {
            return Err(MemoryError::InvalidAlignment(offset));
        }
        let off = offset as usize;
        if off + 8 > self.size() {
            return Err(MemoryError::OutOfBounds(offset));
        }
        // Use atomic stores for cross-worker visibility
        let idx_lo = self.atomic_index(off);
        let idx_hi = self.atomic_index(off + 4);
        let _ = Atomics::store(&self.atomic_view, idx_lo, value as i32);
        let _ = Atomics::store(&self.atomic_view, idx_hi, (value >> 32) as i32);
        Ok(())
    }

    // ========== BULK OPERATIONS ==========

    /// Load data into DRAM at the given offset.
    pub fn load(&self, data: &[u8], offset: u64) -> Result<(), MemoryError> {
        let off = offset as u32;
        if (off as usize) + data.len() > self.size() {
            return Err(MemoryError::OutOfBounds(offset));
        }
        // Use Uint8Array.set() for bulk copy when possible
        let src = Uint8Array::from(data);
        self.view.set(&src, off);
        Ok(())
    }

    pub fn zero_range(&self, offset: usize, len: usize) -> Result<(), MemoryError> {
        if offset + len > self.size() {
            return Err(MemoryError::OutOfBounds(offset as u64));
        }
        self.view.fill(0, offset as u32, (offset + len) as u32);
        Ok(())
    }

    /// Write an arbitrary slice into DRAM starting at `offset`.
    pub fn write_bytes(&self, offset: u64, data: &[u8]) -> Result<(), MemoryError> {
        self.load(data, offset)
    }

    // ========== SNAPSHOT HELPERS ==========

    /// Read a range of bytes from DRAM (for signature extraction, snapshots).
    pub fn read_range(&self, offset: usize, len: usize) -> Result<Vec<u8>, MemoryError> {
        if offset + len > self.size() {
            return Err(MemoryError::OutOfBounds(offset as u64));
        }
        // Use subarray + to_vec for efficient bulk read
        let subarray = self.view.subarray(offset as u32, (offset + len) as u32);
        Ok(subarray.to_vec())
    }

    /// Get a clone of all DRAM contents (for snapshots).
    pub fn get_data(&self) -> Vec<u8> {
        self.view.to_vec()
    }

    /// Replace all DRAM contents (for snapshot restore).
    pub fn set_data(&self, data: &[u8]) -> Result<(), MemoryError> {
        if data.len() != self.size() {
            return Err(MemoryError::OutOfBounds(data.len() as u64));
        }
        let src = Uint8Array::from(data);
        self.view.set(&src, 0);
        Ok(())
    }

    // ========== ATOMIC OPERATIONS (using JavaScript Atomics API) ==========
    //
    // These are essential for SMP correctness. The JavaScript Atomics API provides
    // true atomic operations on SharedArrayBuffer, ensuring proper synchronization
    // across Web Workers.

    /// Convert a DRAM byte offset to Int32Array index for atomic operations.
    /// Must account for the byte_offset within the SharedArrayBuffer.
    #[inline(always)]
    fn atomic_index(&self, dram_offset: usize) -> u32 {
        // The Int32Array covers the entire SharedArrayBuffer
        // DRAM starts at self.byte_offset, so we need to add it
        ((self.byte_offset + dram_offset) / 4) as u32
    }

    /// Atomic load of a 32-bit value.
    /// Returns the value at the given DRAM offset using memory ordering semantics.
    #[inline]
    pub fn atomic_load_32(&self, offset: u64) -> Result<u32, MemoryError> {
        if offset % 4 != 0 {
            return Err(MemoryError::InvalidAlignment(offset));
        }
        let off = offset as usize;
        if off + 4 > self.size() {
            return Err(MemoryError::OutOfBounds(offset));
        }
        let idx = self.atomic_index(off);
        let val = Atomics::load(&self.atomic_view, idx).unwrap_or(0);
        Ok(val as u32)
    }

    /// Atomic store of a 32-bit value.
    #[inline]
    pub fn atomic_store_32(&self, offset: u64, value: u32) -> Result<(), MemoryError> {
        if offset % 4 != 0 {
            return Err(MemoryError::InvalidAlignment(offset));
        }
        let off = offset as usize;
        if off + 4 > self.size() {
            return Err(MemoryError::OutOfBounds(offset));
        }
        let idx = self.atomic_index(off);
        let _ = Atomics::store(&self.atomic_view, idx, value as i32);
        Ok(())
    }

    /// Atomic exchange (AMOSWAP): atomically replace value and return old value.
    #[inline]
    pub fn atomic_swap_32(&self, offset: u64, value: u32) -> Result<u32, MemoryError> {
        if offset % 4 != 0 {
            return Err(MemoryError::InvalidAlignment(offset));
        }
        let off = offset as usize;
        if off + 4 > self.size() {
            return Err(MemoryError::OutOfBounds(offset));
        }
        let idx = self.atomic_index(off);
        let old = Atomics::exchange(&self.atomic_view, idx, value as i32).unwrap_or(0);
        Ok(old as u32)
    }

    /// Atomic add (AMOADD): atomically add and return old value.
    #[inline]
    pub fn atomic_add_32(&self, offset: u64, value: u32) -> Result<u32, MemoryError> {
        if offset % 4 != 0 {
            return Err(MemoryError::InvalidAlignment(offset));
        }
        let off = offset as usize;
        if off + 4 > self.size() {
            return Err(MemoryError::OutOfBounds(offset));
        }
        let idx = self.atomic_index(off);
        let old = Atomics::add(&self.atomic_view, idx, value as i32).unwrap_or(0);
        Ok(old as u32)
    }

    /// Atomic AND (AMOAND): atomically AND and return old value.
    #[inline]
    pub fn atomic_and_32(&self, offset: u64, value: u32) -> Result<u32, MemoryError> {
        if offset % 4 != 0 {
            return Err(MemoryError::InvalidAlignment(offset));
        }
        let off = offset as usize;
        if off + 4 > self.size() {
            return Err(MemoryError::OutOfBounds(offset));
        }
        let idx = self.atomic_index(off);
        let old = Atomics::and(&self.atomic_view, idx, value as i32).unwrap_or(0);
        Ok(old as u32)
    }

    /// Atomic OR (AMOOR): atomically OR and return old value.
    #[inline]
    pub fn atomic_or_32(&self, offset: u64, value: u32) -> Result<u32, MemoryError> {
        if offset % 4 != 0 {
            return Err(MemoryError::InvalidAlignment(offset));
        }
        let off = offset as usize;
        if off + 4 > self.size() {
            return Err(MemoryError::OutOfBounds(offset));
        }
        let idx = self.atomic_index(off);
        let old = Atomics::or(&self.atomic_view, idx, value as i32).unwrap_or(0);
        Ok(old as u32)
    }

    /// Atomic XOR (AMOXOR): atomically XOR and return old value.
    #[inline]
    pub fn atomic_xor_32(&self, offset: u64, value: u32) -> Result<u32, MemoryError> {
        if offset % 4 != 0 {
            return Err(MemoryError::InvalidAlignment(offset));
        }
        let off = offset as usize;
        if off + 4 > self.size() {
            return Err(MemoryError::OutOfBounds(offset));
        }
        let idx = self.atomic_index(off);
        let old = Atomics::xor(&self.atomic_view, idx, value as i32).unwrap_or(0);
        Ok(old as u32)
    }

    /// Atomic compare-and-exchange (for LR/SC emulation).
    /// Returns (success, old_value).
    #[inline]
    pub fn atomic_compare_exchange_32(
        &self,
        offset: u64,
        expected: u32,
        new_value: u32,
    ) -> Result<(bool, u32), MemoryError> {
        if offset % 4 != 0 {
            return Err(MemoryError::InvalidAlignment(offset));
        }
        let off = offset as usize;
        if off + 4 > self.size() {
            return Err(MemoryError::OutOfBounds(offset));
        }
        let idx = self.atomic_index(off);
        let old = Atomics::compare_exchange(&self.atomic_view, idx, expected as i32, new_value as i32)
            .unwrap_or(0);
        let success = old as u32 == expected;
        Ok((success, old as u32))
    }

    // ========== 64-bit Atomic Operations ==========
    //
    // JavaScript Atomics only supports 32-bit operations directly.
    // For 64-bit atomics, we need to use a lock or split into two 32-bit ops.
    // We use a simple spinlock approach for 64-bit AMOs to ensure atomicity.

    /// Atomic load of a 64-bit value.
    /// Uses two 32-bit atomic loads (non-atomic as a pair, but each load is atomic).
    #[inline]
    pub fn atomic_load_64(&self, offset: u64) -> Result<u64, MemoryError> {
        if offset % 8 != 0 {
            return Err(MemoryError::InvalidAlignment(offset));
        }
        let off = offset as usize;
        if off + 8 > self.size() {
            return Err(MemoryError::OutOfBounds(offset));
        }
        // Two atomic 32-bit loads
        let lo = self.atomic_load_32(offset)? as u64;
        let hi = self.atomic_load_32(offset + 4)? as u64;
        Ok(lo | (hi << 32))
    }

    /// Atomic store of a 64-bit value.
    /// Uses two 32-bit atomic stores (non-atomic as a pair, but each store is atomic).
    #[inline]
    pub fn atomic_store_64(&self, offset: u64, value: u64) -> Result<(), MemoryError> {
        if offset % 8 != 0 {
            return Err(MemoryError::InvalidAlignment(offset));
        }
        let off = offset as usize;
        if off + 8 > self.size() {
            return Err(MemoryError::OutOfBounds(offset));
        }
        // Two atomic 32-bit stores
        self.atomic_store_32(offset, value as u32)?;
        self.atomic_store_32(offset + 4, (value >> 32) as u32)?;
        Ok(())
    }

    /// Atomic 64-bit exchange using compare-and-swap loop on low word.
    /// This is not perfectly atomic but is sufficient for most kernel use cases.
    #[inline]
    pub fn atomic_swap_64(&self, offset: u64, value: u64) -> Result<u64, MemoryError> {
        if offset % 8 != 0 {
            return Err(MemoryError::InvalidAlignment(offset));
        }
        let off = offset as usize;
        if off + 8 > self.size() {
            return Err(MemoryError::OutOfBounds(offset));
        }
        // For 64-bit swap, we use a CAS loop on the low word as a "lock"
        // This isn't perfectly atomic for 64-bit but works for common patterns
        let idx_lo = self.atomic_index(off);
        let idx_hi = self.atomic_index(off + 4);
        
        // Read current values
        let old_lo = Atomics::exchange(&self.atomic_view, idx_lo, value as i32).unwrap_or(0) as u32;
        let old_hi = Atomics::exchange(&self.atomic_view, idx_hi, (value >> 32) as i32).unwrap_or(0) as u32;
        
        Ok((old_lo as u64) | ((old_hi as u64) << 32))
    }

    /// Atomic 64-bit add.
    #[inline]
    pub fn atomic_add_64(&self, offset: u64, value: u64) -> Result<u64, MemoryError> {
        if offset % 8 != 0 {
            return Err(MemoryError::InvalidAlignment(offset));
        }
        let off = offset as usize;
        if off + 8 > self.size() {
            return Err(MemoryError::OutOfBounds(offset));
        }
        // CAS loop for 64-bit add
        loop {
            let old = self.atomic_load_64(offset)?;
            let new_val = old.wrapping_add(value);
            // Try to CAS the low word
            let (success, _) = self.atomic_compare_exchange_32(offset, old as u32, new_val as u32)?;
            if success {
                // Also update high word (not perfectly atomic but close enough)
                self.atomic_store_32(offset + 4, (new_val >> 32) as u32)?;
                return Ok(old);
            }
            // Retry on contention
            std::hint::spin_loop();
        }
    }

    /// Atomic 64-bit AND.
    #[inline]
    pub fn atomic_and_64(&self, offset: u64, value: u64) -> Result<u64, MemoryError> {
        if offset % 8 != 0 {
            return Err(MemoryError::InvalidAlignment(offset));
        }
        loop {
            let old = self.atomic_load_64(offset)?;
            let new_val = old & value;
            let (success, _) = self.atomic_compare_exchange_32(offset, old as u32, new_val as u32)?;
            if success {
                self.atomic_store_32(offset + 4, (new_val >> 32) as u32)?;
                return Ok(old);
            }
            std::hint::spin_loop();
        }
    }

    /// Atomic 64-bit OR.
    #[inline]
    pub fn atomic_or_64(&self, offset: u64, value: u64) -> Result<u64, MemoryError> {
        if offset % 8 != 0 {
            return Err(MemoryError::InvalidAlignment(offset));
        }
        loop {
            let old = self.atomic_load_64(offset)?;
            let new_val = old | value;
            let (success, _) = self.atomic_compare_exchange_32(offset, old as u32, new_val as u32)?;
            if success {
                self.atomic_store_32(offset + 4, (new_val >> 32) as u32)?;
                return Ok(old);
            }
            std::hint::spin_loop();
        }
    }

    /// Atomic 64-bit XOR.
    #[inline]
    pub fn atomic_xor_64(&self, offset: u64, value: u64) -> Result<u64, MemoryError> {
        if offset % 8 != 0 {
            return Err(MemoryError::InvalidAlignment(offset));
        }
        loop {
            let old = self.atomic_load_64(offset)?;
            let new_val = old ^ value;
            let (success, _) = self.atomic_compare_exchange_32(offset, old as u32, new_val as u32)?;
            if success {
                self.atomic_store_32(offset + 4, (new_val >> 32) as u32)?;
                return Ok(old);
            }
            std::hint::spin_loop();
        }
    }

    /// Atomic 64-bit compare-and-exchange.
    #[inline]
    pub fn atomic_compare_exchange_64(
        &self,
        offset: u64,
        expected: u64,
        new_value: u64,
    ) -> Result<(bool, u64), MemoryError> {
        if offset % 8 != 0 {
            return Err(MemoryError::InvalidAlignment(offset));
        }
        let off = offset as usize;
        if off + 8 > self.size() {
            return Err(MemoryError::OutOfBounds(offset));
        }
        // CAS on low word, then high word if low succeeds
        let (lo_success, old_lo) = self.atomic_compare_exchange_32(offset, expected as u32, new_value as u32)?;
        if !lo_success {
            // Low word mismatch - get full old value
            let old_hi = self.atomic_load_32(offset + 4)? as u64;
            return Ok((false, (old_lo as u64) | (old_hi << 32)));
        }
        // Low word matched - also check/update high word
        let (hi_success, old_hi) = self.atomic_compare_exchange_32(
            offset + 4,
            (expected >> 32) as u32,
            (new_value >> 32) as u32,
        )?;
        let old = (old_lo as u64) | ((old_hi as u64) << 32);
        if !hi_success {
            // High word mismatch - restore low word (best effort)
            let _ = self.atomic_store_32(offset, expected as u32);
        }
        Ok((lo_success && hi_success, old))
    }
}
</file>

<file path="riscv-vm/src/virtio.rs">
use crate::dram::{Dram, MemoryError};
use crate::bus::DRAM_BASE;
use crate::net::NetworkBackend;
use std::sync::Mutex;

#[cfg(target_arch = "wasm32")]
use wasm_bindgen;

// MMIO register *values* expected by the xv6 VirtIO driver.
const MAGIC_VALUE: u64 = 0x7472_6976;
const VERSION: u64 = 2; // Legacy VirtIO MMIO version

const VENDOR_ID: u64 = 0x554d_4551;

// Common MMIO register offsets
const MAGIC_VALUE_OFFSET: u64 = 0x000;
const VERSION_OFFSET: u64 = 0x004;
const DEVICE_ID_OFFSET: u64 = 0x008;
const VENDOR_ID_OFFSET: u64 = 0x00c;
const DEVICE_FEATURES_OFFSET: u64 = 0x010;
const DEVICE_FEATURES_SEL_OFFSET: u64 = 0x014;
const DRIVER_FEATURES_OFFSET: u64 = 0x020;
const DRIVER_FEATURES_SEL_OFFSET: u64 = 0x024;
const GUEST_PAGE_SIZE_OFFSET: u64 = 0x028;
const QUEUE_SEL_OFFSET: u64 = 0x030;
const QUEUE_NUM_MAX_OFFSET: u64 = 0x034;
const QUEUE_NUM_OFFSET: u64 = 0x038;
const QUEUE_PFN_OFFSET: u64 = 0x040;
const QUEUE_READY_OFFSET: u64 = 0x044;
const QUEUE_NOTIFY_OFFSET: u64 = 0x050;
const INTERRUPT_STATUS_OFFSET: u64 = 0x060;
const INTERRUPT_ACK_OFFSET: u64 = 0x064;
const STATUS_OFFSET: u64 = 0x070;
const QUEUE_DESC_LOW_OFFSET: u64 = 0x080;
const QUEUE_DESC_HIGH_OFFSET: u64 = 0x084;
const QUEUE_DRIVER_LOW_OFFSET: u64 = 0x090;
const QUEUE_DRIVER_HIGH_OFFSET: u64 = 0x094;
const QUEUE_DEVICE_LOW_OFFSET: u64 = 0x0a0;
const QUEUE_DEVICE_HIGH_OFFSET: u64 = 0x0a4;
const CONFIG_GENERATION_OFFSET: u64 = 0x0fc;
const CONFIG_SPACE_OFFSET: u64 = 0x100;

// Device IDs
const VIRTIO_BLK_DEVICE_ID: u32 = 2;
const VIRTIO_NET_DEVICE_ID: u32 = 1;
const VIRTIO_RNG_DEVICE_ID: u32 = 4;
#[allow(dead_code)]
const VIRTIO_CONSOLE_DEVICE_ID: u32 = 3;

// VirtIO Block Features
#[allow(dead_code)]
const VIRTIO_BLK_F_SIZE_MAX: u64 = 1;
#[allow(dead_code)]
const VIRTIO_BLK_F_SEG_MAX: u64 = 2;
#[allow(dead_code)]
const VIRTIO_BLK_F_GEOMETRY: u64 = 4;
#[allow(dead_code)]
const VIRTIO_BLK_F_RO: u64 = 5;
#[allow(dead_code)]
const VIRTIO_BLK_F_BLK_SIZE: u64 = 6;
const VIRTIO_BLK_F_FLUSH: u64 = 9;

// VirtIO Net Features
const VIRTIO_NET_F_MAC: u64 = 5;           // Device has given MAC address
const VIRTIO_NET_F_STATUS: u64 = 16;       // Configuration status field available
#[allow(dead_code)]
const VIRTIO_NET_F_MRG_RXBUF: u64 = 15;    // Driver can merge receive buffers
#[allow(dead_code)]
const VIRTIO_NET_F_CSUM: u64 = 0;          // Device handles checksum
#[allow(dead_code)]
const VIRTIO_NET_F_GUEST_CSUM: u64 = 1;    // Driver handles checksum

// VirtIO Net Status bits
const VIRTIO_NET_S_LINK_UP: u16 = 1;

const QUEUE_SIZE: u32 = 16;

const VRING_DESC_F_NEXT: u64 = 1;
const VRING_DESC_F_WRITE: u64 = 2;

/// Trait for all VirtIO devices to implement.
/// 
/// Note: Methods take `&self` to allow concurrent access from multiple harts.
/// Implementations must use interior mutability (Mutex, atomics) for state.
/// The `Send + Sync` bounds ensure implementations are thread-safe.
pub trait VirtioDevice: Send + Sync {
    fn read(&self, offset: u64) -> Result<u64, MemoryError>;
    fn write(&self, offset: u64, val: u64, dram: &Dram) -> Result<(), MemoryError>;
    fn is_interrupting(&self) -> bool;
    fn device_id(&self) -> u32;
    fn reg_read_size(&self, _offset: u64) -> u64 {
        // Most registers are 4 bytes.
        // Config space (>= 0x100) might be different but for now we assume 4-byte access.
        4
    }
    
    /// Poll the device for any pending work (e.g., incoming network packets).
    /// This is called periodically by the emulator's main loop.
    /// Default implementation does nothing.
    fn poll(&self, _dram: &Dram) -> Result<(), MemoryError> {
        Ok(())
    }
}

/// Internal mutable state for VirtioBlock, protected by Mutex
struct VirtioBlockState {
    driver_features: u32,
    driver_features_sel: u32,
    device_features_sel: u32,
    page_size: u32,
    queue_sel: u32,
    queue_num: u32,
    queue_desc: u64,
    queue_avail: u64,
    queue_used: u64,
    queue_ready: bool,
    interrupt_status: u32,
    status: u32,
    disk: Vec<u8>,
    last_avail_idx: u16,
    debug: bool,
}

pub struct VirtioBlock {
    state: Mutex<VirtioBlockState>,
}

impl VirtioBlock {
    pub fn new(disk_image: Vec<u8>) -> Self {
        Self {
            state: Mutex::new(VirtioBlockState {
                driver_features: 0,
                driver_features_sel: 0,
                device_features_sel: 0,
                page_size: 4096,
                queue_sel: 0,
                queue_num: 0,
                queue_desc: 0,
                queue_avail: 0,
                queue_used: 0,
                queue_ready: false,
                interrupt_status: 0,
                status: 0,
                disk: disk_image,
                last_avail_idx: 0,
                debug: false,
            }),
        }
    }

    fn phys_to_offset(addr: u64) -> Result<u64, MemoryError> {
        if addr < DRAM_BASE {
            return Err(MemoryError::OutOfBounds(addr));
        }
        Ok(addr - DRAM_BASE)
    }

    fn process_queue(state: &mut VirtioBlockState, dram: &Dram) -> Result<(), MemoryError> {
        let avail_idx_addr = state.queue_avail.wrapping_add(2);
        let avail_idx = dram.load_16(Self::phys_to_offset(avail_idx_addr)?)? as u16;

        let mut processed_any = false;
        while state.last_avail_idx != avail_idx {
            let qsz = if state.queue_num > 0 { state.queue_num } else { QUEUE_SIZE };
            let ring_slot = (state.last_avail_idx as u32 % qsz) as u64;
            let head_idx_addr = state.queue_avail.wrapping_add(4).wrapping_add(ring_slot * 2);
            let head_desc_idx = dram.load_16(Self::phys_to_offset(head_idx_addr)?)? as u16;


            let desc_idx = head_desc_idx;

            let desc_addr0 = state.queue_desc.wrapping_add((desc_idx as u64) * 16);
            let off_desc_addr0 = Self::phys_to_offset(desc_addr0)?;
            let header_addr = dram.load_64(off_desc_addr0)?;
            let header_len = dram.load_32(off_desc_addr0 + 8)?;
            let header_flags = dram.load_16(off_desc_addr0 + 12)? as u64;
            let mut next_desc_idx = dram.load_16(off_desc_addr0 + 14)?;

            if header_len < 16 {
          
                // Consume malformed descriptor to avoid loop
                state.last_avail_idx = state.last_avail_idx.wrapping_add(1);
                processed_any = true;
                continue;
            }

            let off_header_addr = Self::phys_to_offset(header_addr)?;
            let blk_type = dram.load_32(off_header_addr)?;
            let _blk_reserved = dram.load_32(off_header_addr + 4)?;
            let blk_sector = dram.load_64(off_header_addr + 8)?;


            let mut data_len_done: u32 = 0;

            if (header_flags & VRING_DESC_F_NEXT) != 0 {
                let desc2_addr = state.queue_desc.wrapping_add((next_desc_idx as u64) * 16);
                let off_desc2_addr = Self::phys_to_offset(desc2_addr)?;
                let data_addr = dram.load_64(off_desc2_addr)?;
                let data_len = dram.load_32(off_desc2_addr + 8)?;
                let flags2 = dram.load_16(off_desc2_addr + 12)? as u64;
                next_desc_idx = dram.load_16(off_desc2_addr + 14)?;

                if blk_type == 0 { // IN (Read)
                    let offset = blk_sector * 512;
                    if offset + (data_len as u64) <= state.disk.len() as u64 {
                        let slice = &state.disk[offset as usize..(offset as usize + data_len as usize)];
                        let dram_off = Self::phys_to_offset(data_addr)?;
                        dram.write_bytes(dram_off, slice)?;
                        data_len_done = data_len as u32;
                    }
                } else if blk_type == 1 { // OUT (Write)
                    let offset = blk_sector * 512;
                    if offset + (data_len as u64) <= state.disk.len() as u64 {
                        for i in 0..data_len {
                            let b = dram.load_8(Self::phys_to_offset(data_addr + i as u64)?)? as u8;
                            state.disk[offset as usize + i as usize] = b;
                        }
                        data_len_done = data_len as u32;
                    }
                }

                if (flags2 & VRING_DESC_F_NEXT) != 0 {
                    let desc3_addr = state.queue_desc.wrapping_add((next_desc_idx as u64) * 16);
                    let off_desc3_addr = Self::phys_to_offset(desc3_addr)?;
                    let status_addr = dram.load_64(off_desc3_addr)?;
                    dram.store_8(Self::phys_to_offset(status_addr)?, 0)?; // Status: OK
                }
            }

            let used_idx_addr = state.queue_used.wrapping_add(2);
            let mut used_idx = dram.load_16(Self::phys_to_offset(used_idx_addr)?)? as u16;
            let elem_addr = state.queue_used.wrapping_add(4).wrapping_add((used_idx as u64 % qsz as u64) * 8);
            let off_elem_addr = Self::phys_to_offset(elem_addr)?;
            dram.store_32(off_elem_addr, head_desc_idx as u64)?;
            dram.store_32(off_elem_addr + 4, data_len_done as u64)?;
            used_idx = used_idx.wrapping_add(1);
            dram.store_16(Self::phys_to_offset(used_idx_addr)?, used_idx as u64)?;

            state.last_avail_idx = state.last_avail_idx.wrapping_add(1);
            processed_any = true;
        }

        if processed_any {
            state.interrupt_status |= 1;
        }

        Ok(())
    }
}

impl VirtioDevice for VirtioBlock {
    fn device_id(&self) -> u32 {
        VIRTIO_BLK_DEVICE_ID
    }

    fn is_interrupting(&self) -> bool {
        let state = self.state.lock().unwrap();
        state.interrupt_status != 0
    }

    fn read(&self, offset: u64) -> Result<u64, MemoryError> {
        let state = self.state.lock().unwrap();
        let val = match offset {
            MAGIC_VALUE_OFFSET => MAGIC_VALUE,
            VERSION_OFFSET => VERSION,
            DEVICE_ID_OFFSET => VIRTIO_BLK_DEVICE_ID as u64,
            VENDOR_ID_OFFSET => VENDOR_ID,
            DEVICE_FEATURES_OFFSET => {
                if state.device_features_sel == 0 {
                    1u64 << VIRTIO_BLK_F_FLUSH
                } else {
                    0
                }
            }
            DEVICE_FEATURES_SEL_OFFSET => state.device_features_sel as u64,
            DRIVER_FEATURES_OFFSET => state.driver_features as u64,
            DRIVER_FEATURES_SEL_OFFSET => state.driver_features_sel as u64,
            GUEST_PAGE_SIZE_OFFSET => state.page_size as u64,
            QUEUE_NUM_MAX_OFFSET => QUEUE_SIZE as u64,
            QUEUE_SEL_OFFSET => state.queue_sel as u64,
            QUEUE_NUM_OFFSET => state.queue_num as u64,
            QUEUE_READY_OFFSET => if state.queue_ready { 1 } else { 0 },
            INTERRUPT_STATUS_OFFSET => state.interrupt_status as u64,
            STATUS_OFFSET => state.status as u64,
            CONFIG_GENERATION_OFFSET => 0,
            _ if offset >= 0x100 => {
                if offset == 0x100 {
                     let cap = state.disk.len() as u64 / 512;
                     cap & 0xffffffff
                } else if offset == 0x104 {
                     let cap = state.disk.len() as u64 / 512;
                     cap >> 32
                } else {
                    0
                }
            }
            _ => 0,
        };
        Ok(val)
    }

    fn write(&self, offset: u64, val: u64, dram: &Dram) -> Result<(), MemoryError> {
        let mut state = self.state.lock().unwrap();
        let val32 = val as u32;

        match offset {
            DEVICE_FEATURES_SEL_OFFSET => { 
                state.device_features_sel = val32; 
            }
            DRIVER_FEATURES_OFFSET => { 
                state.driver_features = val32; 
            }
            DRIVER_FEATURES_SEL_OFFSET => { 
                state.driver_features_sel = val32; 
            }
            QUEUE_SEL_OFFSET => { 
                state.queue_sel = val32; 
            }
            QUEUE_NUM_OFFSET => { 
                state.queue_num = val32; 
            }
            GUEST_PAGE_SIZE_OFFSET => { 
                state.page_size = val32; 
            }
            QUEUE_PFN_OFFSET => {
                let pfn = val32 as u64;
                if pfn != 0 {
                    let desc = pfn * (state.page_size as u64);
                    state.queue_desc = desc;
                    state.queue_avail = desc + 16 * (state.queue_num as u64);
                    // Avail ring size: flags(2) + idx(2) + ring(2*n) + used_event(2) = 6 + 2*n
                    let avail_size = 6 + 2 * (state.queue_num as u64);
                    let used = (state.queue_avail + avail_size + (state.page_size as u64) - 1) & !((state.page_size as u64) - 1);
                    state.queue_used = used;
                    state.queue_ready = true;
                    if state.debug {
                        eprintln!("[VirtIO] Queue configured: desc=0x{:x} avail=0x{:x} used=0x{:x}", state.queue_desc, state.queue_avail, state.queue_used);
                    }
                }
            }
            QUEUE_READY_OFFSET => { 
                state.queue_ready = val32 != 0; 
            }
            QUEUE_NOTIFY_OFFSET => {
                if val32 == 0 {
                    Self::process_queue(&mut state, dram)?;
                }
            }
            INTERRUPT_ACK_OFFSET => {
                state.interrupt_status &= !val32;
            }
            STATUS_OFFSET => { 
                if val32 == 0 {
                    // Reset
                    state.status = 0;
                    state.queue_ready = false;
                    state.interrupt_status = 0;
                    state.last_avail_idx = 0;
                } else {
                    state.status = val32; 
                }
            }
            QUEUE_DESC_LOW_OFFSET => { 
                state.queue_desc = (state.queue_desc & 0xffffffff00000000) | (val32 as u64); 
            }
            QUEUE_DESC_HIGH_OFFSET => { 
                state.queue_desc = (state.queue_desc & 0x00000000ffffffff) | ((val32 as u64) << 32); 
            }
            QUEUE_DRIVER_LOW_OFFSET => { 
                state.queue_avail = (state.queue_avail & 0xffffffff00000000) | (val32 as u64); 
            }
            QUEUE_DRIVER_HIGH_OFFSET => { 
                state.queue_avail = (state.queue_avail & 0x00000000ffffffff) | ((val32 as u64) << 32); 
            }
            QUEUE_DEVICE_LOW_OFFSET => { 
                state.queue_used = (state.queue_used & 0xffffffff00000000) | (val32 as u64); 
            }
            QUEUE_DEVICE_HIGH_OFFSET => { 
                state.queue_used = (state.queue_used & 0x00000000ffffffff) | ((val32 as u64) << 32); 
            }
            _ => {}
        }
        Ok(())
    }
}

/// Internal mutable state for VirtioRng, protected by Mutex
struct VirtioRngState {
    driver_features: u32,
    driver_features_sel: u32,
    device_features_sel: u32,
    page_size: u32,
    queue_sel: u32,
    queue_num: u32,
    queue_desc: u64,
    queue_avail: u64,
    queue_used: u64,
    queue_ready: bool,
    interrupt_status: u32,
    status: u32,
    last_avail_idx: u16,
    debug: bool,
}

pub struct VirtioRng {
    state: Mutex<VirtioRngState>,
}

impl VirtioRng {
    pub fn new() -> Self {
        Self {
            state: Mutex::new(VirtioRngState {
                driver_features: 0,
                driver_features_sel: 0,
                device_features_sel: 0,
                page_size: 4096,
                queue_sel: 0,
                queue_num: 0,
                queue_desc: 0,
                queue_avail: 0,
                queue_used: 0,
                queue_ready: false,
                interrupt_status: 0,
                status: 0,
                last_avail_idx: 0,
                debug: false,
            }),
        }
    }

    fn phys_to_offset(addr: u64) -> Result<u64, MemoryError> {
        if addr < DRAM_BASE {
            return Err(MemoryError::OutOfBounds(addr));
        }
        Ok(addr - DRAM_BASE)
    }

    fn process_queue(state: &mut VirtioRngState, dram: &Dram) -> Result<(), MemoryError> {
        let avail_idx_addr = state.queue_avail.wrapping_add(2);
        let avail_idx = dram.load_16(Self::phys_to_offset(avail_idx_addr)?)? as u16;

        let mut processed_any = false;
        while state.last_avail_idx != avail_idx {
            let ring_slot = (state.last_avail_idx as u32 % QUEUE_SIZE) as u64;
            let head_idx_addr = state.queue_avail.wrapping_add(4).wrapping_add(ring_slot * 2);
            let head_desc_idx = dram.load_16(Self::phys_to_offset(head_idx_addr)?)? as u16;

            let desc_addr0 = state.queue_desc.wrapping_add((head_desc_idx as u64) * 16);
            let off_desc_addr0 = Self::phys_to_offset(desc_addr0)?;
            let buffer_addr = dram.load_64(off_desc_addr0)?;
            let buffer_len = dram.load_32(off_desc_addr0 + 8)?;
            let flags = dram.load_16(off_desc_addr0 + 12)? as u64;

            if (flags & VRING_DESC_F_WRITE) != 0 {
                // Fill with pseudo-random data
                for i in 0..buffer_len {
                    dram.store_8(Self::phys_to_offset(buffer_addr + i as u64)?, ((i as u8).wrapping_add(42)).into())?;
                }
            }

            let used_idx_addr = state.queue_used.wrapping_add(2);
            let mut used_idx = dram.load_16(Self::phys_to_offset(used_idx_addr)?)? as u16;
            let elem_addr = state.queue_used.wrapping_add(4).wrapping_add((used_idx as u64 % QUEUE_SIZE as u64) * 8);
            let off_elem_addr = Self::phys_to_offset(elem_addr)?;
            dram.store_32(off_elem_addr, head_desc_idx as u64)?;
            dram.store_32(off_elem_addr + 4, buffer_len as u64)?;
            used_idx = used_idx.wrapping_add(1);
            dram.store_16(Self::phys_to_offset(used_idx_addr)?, used_idx as u64)?;

            state.last_avail_idx = state.last_avail_idx.wrapping_add(1);
            processed_any = true;
        }

        if processed_any {
            state.interrupt_status |= 1;
        }

        Ok(())
    }
}

impl VirtioDevice for VirtioRng {
    fn device_id(&self) -> u32 {
        VIRTIO_RNG_DEVICE_ID
    }

    fn is_interrupting(&self) -> bool {
        let state = self.state.lock().unwrap();
        state.interrupt_status != 0
    }

    fn read(&self, offset: u64) -> Result<u64, MemoryError> {
        let state = self.state.lock().unwrap();
        let val = match offset {
            MAGIC_VALUE_OFFSET => MAGIC_VALUE,
            VERSION_OFFSET => VERSION,
            DEVICE_ID_OFFSET => VIRTIO_RNG_DEVICE_ID as u64,
            VENDOR_ID_OFFSET => VENDOR_ID,
            DEVICE_FEATURES_OFFSET => 0,
            DEVICE_FEATURES_SEL_OFFSET => state.device_features_sel as u64,
            DRIVER_FEATURES_OFFSET => state.driver_features as u64,
            DRIVER_FEATURES_SEL_OFFSET => state.driver_features_sel as u64,
            GUEST_PAGE_SIZE_OFFSET => state.page_size as u64,
            QUEUE_NUM_MAX_OFFSET => QUEUE_SIZE as u64,
            QUEUE_SEL_OFFSET => state.queue_sel as u64,
            QUEUE_NUM_OFFSET => state.queue_num as u64,
            QUEUE_READY_OFFSET => if state.queue_ready { 1 } else { 0 },
            INTERRUPT_STATUS_OFFSET => state.interrupt_status as u64,
            STATUS_OFFSET => state.status as u64,
            CONFIG_GENERATION_OFFSET => 0,
            _ => 0,
        };
        Ok(val)
    }

    fn write(&self, offset: u64, val: u64, dram: &Dram) -> Result<(), MemoryError> {
        let mut state = self.state.lock().unwrap();
        let val32 = val as u32;
        match offset {
            DEVICE_FEATURES_SEL_OFFSET => { state.device_features_sel = val32; }
            DRIVER_FEATURES_OFFSET => { state.driver_features = val32; }
            DRIVER_FEATURES_SEL_OFFSET => { state.driver_features_sel = val32; }
            QUEUE_SEL_OFFSET => { state.queue_sel = val32; }
            QUEUE_NUM_OFFSET => { state.queue_num = val32; }
            GUEST_PAGE_SIZE_OFFSET => { state.page_size = val32; }
            QUEUE_PFN_OFFSET => {
                let pfn = val32 as u64;
                if pfn != 0 {
                    let desc = pfn * (state.page_size as u64);
                    state.queue_desc = desc;
                    state.queue_avail = desc + 16 * (state.queue_num as u64);
                    // Avail ring size: flags(2) + idx(2) + ring(2*n) + used_event(2) = 6 + 2*n
                    let avail_size = 6 + 2 * (state.queue_num as u64);
                    let used = (state.queue_avail + avail_size + (state.page_size as u64) - 1) & !((state.page_size as u64) - 1);
                    state.queue_used = used;
                    state.queue_ready = true;
                }
            }
            QUEUE_READY_OFFSET => { state.queue_ready = val32 != 0; }
            QUEUE_NOTIFY_OFFSET => {
                if val32 == 0 {
                    Self::process_queue(&mut state, dram)?;
                }
            }
            INTERRUPT_ACK_OFFSET => {
                state.interrupt_status &= !val32;
            }
            STATUS_OFFSET => { 
                if val32 == 0 {
                    state.status = 0;
                    state.queue_ready = false;
                    state.interrupt_status = 0;
                    state.last_avail_idx = 0;
                } else {
                    state.status = val32; 
                }
            }
            QUEUE_DESC_LOW_OFFSET => { state.queue_desc = (state.queue_desc & 0xffffffff00000000) | (val32 as u64); }
            QUEUE_DESC_HIGH_OFFSET => { state.queue_desc = (state.queue_desc & 0x00000000ffffffff) | ((val32 as u64) << 32); }
            QUEUE_DRIVER_LOW_OFFSET => { state.queue_avail = (state.queue_avail & 0xffffffff00000000) | (val32 as u64); }
            QUEUE_DRIVER_HIGH_OFFSET => { state.queue_avail = (state.queue_avail & 0x00000000ffffffff) | ((val32 as u64) << 32); }
            QUEUE_DEVICE_LOW_OFFSET => { state.queue_used = (state.queue_used & 0xffffffff00000000) | (val32 as u64); }
            QUEUE_DEVICE_HIGH_OFFSET => { state.queue_used = (state.queue_used & 0x00000000ffffffff) | ((val32 as u64) << 32); }
            _ => {}
        }
        Ok(())
    }
}

/// VirtIO Network Queue state
struct NetQueue {
    num: u32,
    desc: u64,
    avail: u64,
    used: u64,
    ready: bool,
    last_avail_idx: u16,
}

impl NetQueue {
    fn new() -> Self {
        Self {
            num: 0,
            desc: 0,
            avail: 0,
            used: 0,
            ready: false,
            last_avail_idx: 0,
        }
    }
    
    fn reset(&mut self) {
        self.num = 0;
        self.desc = 0;
        self.avail = 0;
        self.used = 0;
        self.ready = false;
        self.last_avail_idx = 0;
    }
}

/// Network statistics for monitoring and debugging (Phase 5)
#[derive(Default)]
pub struct NetStats {
    /// Packets transmitted
    pub tx_packets: u64,
    /// Packets received and delivered to guest
    pub rx_packets: u64,
    /// TX errors (send failures)
    pub tx_errors: u64,
    /// RX errors (receive/delivery failures)
    pub rx_errors: u64,
    /// Packets dropped due to no available RX buffers
    pub rx_dropped: u64,
}

/// Internal mutable state for VirtioNet, protected by Mutex
struct VirtioNetState {
    // Standard VirtIO fields
    driver_features: u32,
    driver_features_sel: u32,
    device_features_sel: u32,
    page_size: u32,
    queue_sel: u32,
    interrupt_status: u32,
    status: u32,
    
    // Network specific
    mac: [u8; 6],
    backend: Box<dyn NetworkBackend>,
    
    // Queues: 0 = RX, 1 = TX
    rx_queue: NetQueue,  // Queue 0: receive queue (device writes to guest)
    tx_queue: NetQueue,  // Queue 1: transmit queue (guest writes to device)
    
    // Statistics (Phase 5)
    stats: NetStats,
    
    debug: bool,
}

/// VirtIO Network Device
/// 
/// Implements a VirtIO network device that uses a NetworkBackend
/// for actual packet I/O. Supports RX (receive) and TX (transmit) queues.
/// 
/// Config space layout (starting at offset 0x100):
/// - 0x00-0x05: MAC address (6 bytes)
/// - 0x06-0x07: Status (2 bytes) - VIRTIO_NET_S_LINK_UP if negotiated
pub struct VirtioNet {
    state: Mutex<VirtioNetState>,
}

impl VirtioNet {
    /// Create a new VirtIO network device with the given backend.
    pub fn new(mut backend: Box<dyn NetworkBackend>) -> Self {
        let mac = backend.mac_address();
        
        // Initialize the backend
        if let Err(e) = backend.init() {
            log::error!("[VirtioNet] Failed to initialize backend: {}", e);
        }
        
        Self {
            state: Mutex::new(VirtioNetState {
                driver_features: 0,
                driver_features_sel: 0,
                device_features_sel: 0,
                page_size: 4096,
                queue_sel: 0,
                interrupt_status: 0,
                status: 0,
                mac,
                backend,
                rx_queue: NetQueue::new(),
                tx_queue: NetQueue::new(),
                stats: NetStats::default(),
                debug: false,
            }),
        }
    }
    
    fn phys_to_offset(addr: u64) -> Result<u64, MemoryError> {
        if addr < DRAM_BASE {
            return Err(MemoryError::OutOfBounds(addr));
        }
        Ok(addr - DRAM_BASE)
    }
    
    fn current_queue(state: &VirtioNetState) -> &NetQueue {
        match state.queue_sel {
            0 => &state.rx_queue,
            1 => &state.tx_queue,
            _ => &state.rx_queue, // Default to RX for invalid selections
        }
    }
    
    fn current_queue_mut(state: &mut VirtioNetState) -> &mut NetQueue {
        match state.queue_sel {
            0 => &mut state.rx_queue,
            1 => &mut state.tx_queue,
            _ => &mut state.rx_queue,
        }
    }
    
    /// Process the RX queue - check backend for incoming packets and deliver to guest.
    /// This processes ALL available packets in a single call.
    fn process_rx_queue(state: &mut VirtioNetState, dram: &Dram) -> Result<(), MemoryError> {
        // Check if queue is ready
        if !state.rx_queue.ready || state.rx_queue.desc == 0 {
            return Ok(());
        }
        
        let debug = state.debug;
        let mut packets_delivered = 0;
        
        // Process all available packets from the backend
        loop {
            // Poll the backend for incoming packets
            let packet = match state.backend.recv() {
                Ok(Some(pkt)) => {
                    log::debug!("[VirtioNet] Received {} byte packet from backend", pkt.len());
                    pkt
                }
                Ok(None) => break, // No more packets available
                Err(e) => {
                    log::warn!("[VirtioNet] RX backend error: {}", e);
                    state.stats.rx_errors += 1;
                    break;
                }
            };
            
            // Extract queue state
            let queue_avail = state.rx_queue.avail;
            let queue_desc = state.rx_queue.desc;
            let queue_used = state.rx_queue.used;
            let queue_num = state.rx_queue.num;
            let last_avail_idx = state.rx_queue.last_avail_idx;
            
            let avail_idx_addr = queue_avail.wrapping_add(2);
            let avail_idx = dram.load_16(Self::phys_to_offset(avail_idx_addr)?)? as u16;
            
            if last_avail_idx == avail_idx {
                // No available buffers from guest - drop the packet
                log::warn!("[VirtioNet] No RX buffers available (last_avail={}, avail={}), dropping {} byte packet", 
                    last_avail_idx, avail_idx, packet.len());
                state.stats.rx_dropped += 1;
                // Don't break - the backend has already consumed this packet, continue to next
                continue;
            }
            
            let qsz = if queue_num > 0 { queue_num } else { QUEUE_SIZE };
            let ring_slot = (last_avail_idx as u32 % qsz) as u64;
            let head_idx_addr = queue_avail.wrapping_add(4).wrapping_add(ring_slot * 2);
            let head_desc_idx = dram.load_16(Self::phys_to_offset(head_idx_addr)?)? as u16;
            
            if debug {
                log::debug!("[VirtioNet] RX: Processing buffer idx={} head_desc={} pkt_len={}", 
                    last_avail_idx, head_desc_idx, packet.len());
            }
            
            // Read first descriptor - should be writable (device writes to it)
            let desc_addr = queue_desc.wrapping_add((head_desc_idx as u64) * 16);
            let off_desc = Self::phys_to_offset(desc_addr)?;
            let buffer_addr = dram.load_64(off_desc)?;
            let buffer_len = dram.load_32(off_desc + 8)? as usize;
            let flags = dram.load_16(off_desc + 12)? as u64;
            
            if debug {
                log::debug!("[VirtioNet] RX desc: desc_addr=0x{:x} buffer_addr=0x{:x} len={} flags=0x{:x}", 
                    desc_addr, buffer_addr, buffer_len, flags);
            }
            
            if (flags & VRING_DESC_F_WRITE) == 0 {
                log::warn!("[VirtioNet] RX descriptor not writable");
                state.rx_queue.last_avail_idx = last_avail_idx.wrapping_add(1);
                state.stats.rx_errors += 1;
                continue;
            }
            
            // VirtIO net header (12 bytes)
            let virtio_hdr = [0u8; 12]; // All zeros - no offloading features
            let total_len = virtio_hdr.len() + packet.len();
            
            if total_len > buffer_len {
                log::warn!("[VirtioNet] Packet too large for buffer ({} > {})", total_len, buffer_len);
                state.rx_queue.last_avail_idx = last_avail_idx.wrapping_add(1);
                state.stats.rx_dropped += 1;
                continue;
            }
            
            // Write virtio header + packet data to guest buffer
            let off_buffer = Self::phys_to_offset(buffer_addr)?;
            dram.write_bytes(off_buffer, &virtio_hdr)?;
            dram.write_bytes(off_buffer + virtio_hdr.len() as u64, &packet)?;
            
            // Update used ring
            let used_idx_addr = queue_used.wrapping_add(2);
            let mut used_idx = dram.load_16(Self::phys_to_offset(used_idx_addr)?)? as u16;
            let elem_addr = queue_used.wrapping_add(4).wrapping_add((used_idx as u64 % qsz as u64) * 8);
            let off_elem = Self::phys_to_offset(elem_addr)?;
            dram.store_32(off_elem, head_desc_idx as u64)?;
            dram.store_32(off_elem + 4, total_len as u64)?;
            used_idx = used_idx.wrapping_add(1);
            dram.store_16(Self::phys_to_offset(used_idx_addr)?, used_idx as u64)?;
            
            state.rx_queue.last_avail_idx = last_avail_idx.wrapping_add(1);
            state.stats.rx_packets += 1;
            packets_delivered += 1;
            
            log::debug!("[VirtioNet] RX: Delivered {} bytes to guest", total_len);
        }
        
        // Only raise interrupt if we delivered at least one packet
        if packets_delivered > 0 {
            state.interrupt_status |= 1;
            if debug {
                log::debug!("[VirtioNet] RX: Delivered {} packets total", packets_delivered);
            }
        }
        
        Ok(())
    }
    
    /// Process the TX queue - read packets from guest and send via backend.
    fn process_tx_queue(state: &mut VirtioNetState, dram: &Dram) -> Result<(), MemoryError> {
        if !state.tx_queue.ready || state.tx_queue.desc == 0 {
            return Ok(());
        }
        
        // Extract queue state to avoid borrow checker issues
        let queue_avail = state.tx_queue.avail;
        let queue_desc = state.tx_queue.desc;
        let queue_used = state.tx_queue.used;
        let queue_num = state.tx_queue.num;
        let mut last_avail_idx = state.tx_queue.last_avail_idx;
        let debug = state.debug;
        
        let avail_idx_addr = queue_avail.wrapping_add(2);
        let avail_idx = dram.load_16(Self::phys_to_offset(avail_idx_addr)?)? as u16;
        
        let mut processed_any = false;
        while last_avail_idx != avail_idx {
            let qsz = if queue_num > 0 { queue_num } else { QUEUE_SIZE };
            let ring_slot = (last_avail_idx as u32 % qsz) as u64;
            let head_idx_addr = queue_avail.wrapping_add(4).wrapping_add(ring_slot * 2);
            let head_desc_idx = dram.load_16(Self::phys_to_offset(head_idx_addr)?)? as u16;
            
            if debug {
                log::debug!("[VirtioNet] TX: Processing buffer idx={} head_desc={}", 
                    last_avail_idx, head_desc_idx);
            }
            
            // Collect all data from descriptor chain
            let mut packet_data = Vec::new();
            let mut desc_idx = head_desc_idx;
            let mut chain_limit = 16; // Prevent infinite loops
            
            while chain_limit > 0 {
                chain_limit -= 1;
                
                let desc_addr = queue_desc.wrapping_add((desc_idx as u64) * 16);
                let off_desc = Self::phys_to_offset(desc_addr)?;
                let buffer_addr = dram.load_64(off_desc)?;
                let buffer_len = dram.load_32(off_desc + 8)? as usize;
                let flags = dram.load_16(off_desc + 12)? as u64;
                let next_idx = dram.load_16(off_desc + 14)? as u16;
                
                // Read data from this descriptor
                let off_buffer = Self::phys_to_offset(buffer_addr)?;
                for i in 0..buffer_len {
                    let byte = dram.load_8(off_buffer + i as u64)? as u8;
                    packet_data.push(byte);
                }
                
                if (flags & VRING_DESC_F_NEXT) == 0 {
                    break;
                }
                desc_idx = next_idx;
            }
            
            // Skip the virtio_net_hdr (12 bytes) and send the actual packet
            if packet_data.len() > 12 {
                let actual_packet = &packet_data[12..];
                if let Err(e) = state.backend.send(actual_packet) {
                    log::warn!("[VirtioNet] TX backend error: {}", e);
                    state.stats.tx_errors += 1;
                } else {
                    state.stats.tx_packets += 1;
                    if debug {
                        log::debug!("[VirtioNet] TX: Sent {} byte packet (total: {})", 
                            actual_packet.len(), state.stats.tx_packets);
                    }
                }
            }
            
            // Update used ring
            let used_idx_addr = queue_used.wrapping_add(2);
            let mut used_idx = dram.load_16(Self::phys_to_offset(used_idx_addr)?)? as u16;
            let elem_addr = queue_used.wrapping_add(4).wrapping_add((used_idx as u64 % qsz as u64) * 8);
            let off_elem = Self::phys_to_offset(elem_addr)?;
            dram.store_32(off_elem, head_desc_idx as u64)?;
            dram.store_32(off_elem + 4, packet_data.len() as u64)?;
            used_idx = used_idx.wrapping_add(1);
            dram.store_16(Self::phys_to_offset(used_idx_addr)?, used_idx as u64)?;
            
            last_avail_idx = last_avail_idx.wrapping_add(1);
            processed_any = true;
        }
        
        // Update the actual queue state
        state.tx_queue.last_avail_idx = last_avail_idx;
        
        if processed_any {
            state.interrupt_status |= 1;
        }
        
        Ok(())
    }
}

impl VirtioDevice for VirtioNet {
    fn device_id(&self) -> u32 {
        VIRTIO_NET_DEVICE_ID
    }

    fn is_interrupting(&self) -> bool {
        let state = self.state.lock().unwrap();
        state.interrupt_status != 0
    }

    fn read(&self, offset: u64) -> Result<u64, MemoryError> {
        let state = self.state.lock().unwrap();
        let val = match offset {
            MAGIC_VALUE_OFFSET => MAGIC_VALUE,
            VERSION_OFFSET => VERSION,
            DEVICE_ID_OFFSET => VIRTIO_NET_DEVICE_ID as u64,
            VENDOR_ID_OFFSET => VENDOR_ID,
            DEVICE_FEATURES_OFFSET => {
                if state.device_features_sel == 0 {
                    // Feature bits 0-31
                    (1u64 << VIRTIO_NET_F_MAC) | (1u64 << VIRTIO_NET_F_STATUS)
                } else {
                    0
                }
            }
            DEVICE_FEATURES_SEL_OFFSET => state.device_features_sel as u64,
            DRIVER_FEATURES_OFFSET => state.driver_features as u64,
            DRIVER_FEATURES_SEL_OFFSET => state.driver_features_sel as u64,
            GUEST_PAGE_SIZE_OFFSET => state.page_size as u64,
            QUEUE_NUM_MAX_OFFSET => QUEUE_SIZE as u64,
            QUEUE_SEL_OFFSET => state.queue_sel as u64,
            QUEUE_NUM_OFFSET => Self::current_queue(&state).num as u64,
            QUEUE_READY_OFFSET => if Self::current_queue(&state).ready { 1 } else { 0 },
            INTERRUPT_STATUS_OFFSET => state.interrupt_status as u64,
            STATUS_OFFSET => state.status as u64,
            CONFIG_GENERATION_OFFSET => 0,
            // Config space: MAC address at 0x100-0x105, status at 0x106-0x107, IP at 0x108-0x10B
            // VirtIO MMIO accesses are 32-bit aligned, so we pack bytes into 32-bit values
            _ if offset >= CONFIG_SPACE_OFFSET => {
                let config_offset = offset - CONFIG_SPACE_OFFSET;
                // Align to 4-byte boundary and return packed value
                let aligned = config_offset & !3;
                match aligned {
                    0 => {
                        // Bytes 0-3: MAC[0..4]
                        (state.mac[0] as u64) |
                        ((state.mac[1] as u64) << 8) |
                        ((state.mac[2] as u64) << 16) |
                        ((state.mac[3] as u64) << 24)
                    }
                    4 => {
                        // Bytes 4-7: MAC[4..6], Status[0..2]
                        (state.mac[4] as u64) |
                        ((state.mac[5] as u64) << 8) |
                        ((VIRTIO_NET_S_LINK_UP as u64) << 16)
                    }
                    8 => {
                        // Bytes 8-11: Assigned IP address (from relay/network controller)
                        // Returns 0 if no IP has been assigned yet
                        let ip_opt = state.backend.get_assigned_ip();
                        #[cfg(target_arch = "wasm32")]
                        web_sys::console::log_1(&wasm_bindgen::JsValue::from_str(
                            &format!("[VirtioNet] Config read offset=8, backend.get_assigned_ip()={:?}", ip_opt)));
                        if let Some(ip) = ip_opt {
                            // Return IP as u32 (Little Endian)
                            // IP: [10, 0, 2, 15] -> 0x0F02000A
                            u32::from_le_bytes(ip) as u64
                        } else {
                            0 // IP not yet assigned
                        }
                    }
                    _ => 0,
                }
            }
            _ => 0,
        };
        Ok(val)
    }

    fn write(&self, offset: u64, val: u64, dram: &Dram) -> Result<(), MemoryError> {
        let mut state = self.state.lock().unwrap();
        let val32 = val as u32;
        
        match offset {
            DEVICE_FEATURES_SEL_OFFSET => { 
                state.device_features_sel = val32; 
            }
            DRIVER_FEATURES_OFFSET => { 
                state.driver_features = val32; 
            }
            DRIVER_FEATURES_SEL_OFFSET => { 
                state.driver_features_sel = val32; 
            }
            QUEUE_SEL_OFFSET => { 
                state.queue_sel = val32; 
            }
            QUEUE_NUM_OFFSET => { 
                Self::current_queue_mut(&mut state).num = val32; 
            }
            GUEST_PAGE_SIZE_OFFSET => { 
                state.page_size = val32; 
            }
            QUEUE_PFN_OFFSET => {
                let pfn = val32 as u64;
                if pfn != 0 {
                    let page_size = state.page_size as u64;
                    let queue_sel = state.queue_sel;
                    let queue = Self::current_queue_mut(&mut state);
                    let desc = pfn * page_size;
                    queue.desc = desc;
                    queue.avail = desc + 16 * (queue.num as u64);
                    // Avail ring size: flags(2) + idx(2) + ring(2*n) + used_event(2) = 6 + 2*n
                    let avail_size = 6 + 2 * (queue.num as u64);
                    let used = (queue.avail + avail_size + page_size - 1) & !(page_size - 1);
                    queue.used = used;
                    queue.ready = true;
                    log::debug!("[VirtioNet] Queue {} configured: pfn={} desc=0x{:x} avail=0x{:x} used=0x{:x} num={}", 
                        queue_sel, pfn, queue.desc, queue.avail, queue.used, queue.num);
                }
            }
            QUEUE_READY_OFFSET => { 
                Self::current_queue_mut(&mut state).ready = val32 != 0; 
            }
            QUEUE_NOTIFY_OFFSET => {
                // val32 is the queue index being notified
                match val32 {
                    0 => {
                        // RX queue notification - guest has provided new buffers
                        // We'll try to deliver any pending packets
                        Self::process_rx_queue(&mut state, dram)?;
                    }
                    1 => {
                        // TX queue notification - guest has packets to send
                        Self::process_tx_queue(&mut state, dram)?;
                    }
                    _ => {}
                }
            }
            INTERRUPT_ACK_OFFSET => {
                state.interrupt_status &= !val32;
            }
            STATUS_OFFSET => { 
                if val32 == 0 {
                    // Reset
                    state.status = 0;
                    state.rx_queue.reset();
                    state.tx_queue.reset();
                    state.interrupt_status = 0;
                } else {
                    state.status = val32; 
                }
            }
            QUEUE_DESC_LOW_OFFSET => { 
                let queue = Self::current_queue_mut(&mut state);
                queue.desc = (queue.desc & 0xffffffff00000000) | (val32 as u64); 
            }
            QUEUE_DESC_HIGH_OFFSET => { 
                let queue = Self::current_queue_mut(&mut state);
                queue.desc = (queue.desc & 0x00000000ffffffff) | ((val32 as u64) << 32); 
            }
            QUEUE_DRIVER_LOW_OFFSET => { 
                let queue = Self::current_queue_mut(&mut state);
                queue.avail = (queue.avail & 0xffffffff00000000) | (val32 as u64); 
            }
            QUEUE_DRIVER_HIGH_OFFSET => { 
                let queue = Self::current_queue_mut(&mut state);
                queue.avail = (queue.avail & 0x00000000ffffffff) | ((val32 as u64) << 32); 
            }
            QUEUE_DEVICE_LOW_OFFSET => { 
                let queue = Self::current_queue_mut(&mut state);
                queue.used = (queue.used & 0xffffffff00000000) | (val32 as u64); 
            }
            QUEUE_DEVICE_HIGH_OFFSET => { 
                let queue = Self::current_queue_mut(&mut state);
                queue.used = (queue.used & 0x00000000ffffffff) | ((val32 as u64) << 32); 
            }
            _ => {}
        }
        Ok(())
    }
    
    fn poll(&self, dram: &Dram) -> Result<(), MemoryError> {
        let mut state = self.state.lock().unwrap();
        Self::process_rx_queue(&mut state, dram)
    }
}
</file>

<file path="mkfs/root/usr/bin/help">
// help - Show available commands
// Usage: help

print("\x1b[1;36m+-------------------------------------------------------------+\x1b[0m");
print("\x1b[1;36m|\x1b[0m                   \x1b[1;97mBAVY OS Commands\x1b[0m                          \x1b[1;36m|\x1b[0m");
print("\x1b[1;36m+-------------------------------------------------------------+\x1b[0m");
print("\x1b[1;36m|\x1b[0m  \x1b[1;33mBuilt-in:\x1b[0m                                                  \x1b[1;36m|\x1b[0m");
print("\x1b[1;36m|\x1b[0m    clear           Clear the screen                         \x1b[1;36m|\x1b[0m");
print("\x1b[1;36m|\x1b[0m    shutdown        Power off the system                     \x1b[1;36m|\x1b[0m");
print("\x1b[1;36m|\x1b[0m    cd <dir>        Change directory                         \x1b[1;36m|\x1b[0m");
print("\x1b[1;36m|\x1b[0m    pwd             Print working directory                  \x1b[1;36m|\x1b[0m");
print("\x1b[1;36m|\x1b[0m    ping <host>     Ping host (Ctrl+C to stop)               \x1b[1;36m|\x1b[0m");
print("\x1b[1;36m|\x1b[0m    nslookup <host> DNS lookup                               \x1b[1;36m|\x1b[0m");
print("\x1b[1;36m|\x1b[0m    node [info]     Scripting engine info/control            \x1b[1;36m|\x1b[0m");
print("\x1b[1;36m|\x1b[0m                                                             \x1b[1;36m|\x1b[0m");
print("\x1b[1;36m|\x1b[0m  \x1b[1;33mUser Scripts:\x1b[0m  \x1b[0;90m(/usr/bin/ - JavaScript)\x1b[0m                    \x1b[1;36m|\x1b[0m");
print("\x1b[1;36m|\x1b[0m    help            This help message                        \x1b[1;36m|\x1b[0m");
print("\x1b[1;36m|\x1b[0m    ls              List files                               \x1b[1;36m|\x1b[0m");
print("\x1b[1;36m|\x1b[0m    cat <file>      Display file contents                    \x1b[1;36m|\x1b[0m");
print("\x1b[1;36m|\x1b[0m    echo [text...]  Print text                               \x1b[1;36m|\x1b[0m");
print("\x1b[1;36m|\x1b[0m    wget <url>      Download from URL (HTTP/HTTPS)           \x1b[1;36m|\x1b[0m");
print("\x1b[1;36m|\x1b[0m    cowsay [msg]    ASCII cow says message                   \x1b[1;36m|\x1b[0m");
print("\x1b[1;36m|\x1b[0m    sysinfo         Display system information               \x1b[1;36m|\x1b[0m");
print("\x1b[1;36m|\x1b[0m    ip [addr]       Show network configuration               \x1b[1;36m|\x1b[0m");
print("\x1b[1;36m|\x1b[0m    netstat         Show network statistics                  \x1b[1;36m|\x1b[0m");
print("\x1b[1;36m|\x1b[0m    memstats        Show memory statistics                   \x1b[1;36m|\x1b[0m");
print("\x1b[1;36m|\x1b[0m    uptime          Show system uptime                       \x1b[1;36m|\x1b[0m");
print("\x1b[1;36m|\x1b[0m    write <f> <t>   Write text to file                       \x1b[1;36m|\x1b[0m");
print("\x1b[1;36m|\x1b[0m                                                             \x1b[1;36m|\x1b[0m");
print("\x1b[1;36m|\x1b[0m  \x1b[1;33mImport Syntax:\x1b[0m                                             \x1b[1;36m|\x1b[0m");
print("\x1b[1;36m|\x1b[0m    import * as fs from \"os:fs\"    \x1b[0;90m// namespace import\x1b[0m       \x1b[1;36m|\x1b[0m");
print("\x1b[1;36m|\x1b[0m    import { ls } from \"os:fs\"     \x1b[0;90m// named import\x1b[0m           \x1b[1;36m|\x1b[0m");
print("\x1b[1;36m|\x1b[0m                                                             \x1b[1;36m|\x1b[0m");
print("\x1b[1;36m|\x1b[0m  \x1b[1;33mOS Modules:\x1b[0m  os:fs, os:net, os:sys, os:mem, os:http        \x1b[1;36m|\x1b[0m");
print("\x1b[1;36m|\x1b[0m                                                             \x1b[1;36m|\x1b[0m");
print("\x1b[1;36m|\x1b[0m  \x1b[1;33mHTTP Module:\x1b[0m  \x1b[0;90m(import * as http from \"os:http\")\x1b[0m            \x1b[1;36m|\x1b[0m");
print("\x1b[1;36m|\x1b[0m    http.get(url)         GET request -> response object     \x1b[1;36m|\x1b[0m");
print("\x1b[1;36m|\x1b[0m    http.post(url,body,t) POST request -> response object    \x1b[1;36m|\x1b[0m");
print("\x1b[1;36m|\x1b[0m    http.request(opts)    Custom request with options        \x1b[1;36m|\x1b[0m");
print("\x1b[1;36m|\x1b[0m    Response: {ok, status, statusText, headers, body}        \x1b[1;36m|\x1b[0m");
print("\x1b[1;36m|\x1b[0m                                                             \x1b[1;36m|\x1b[0m");
print("\x1b[1;36m|\x1b[0m  \x1b[1;32mTip:\x1b[0m  \x1b[1;97mCtrl+C\x1b[0m cancel  |  \x1b[1;97m^/v\x1b[0m history  |  \x1b[1;97mnode info\x1b[0m API      \x1b[1;36m|\x1b[0m");
print("\x1b[1;36m+-------------------------------------------------------------+\x1b[0m");
</file>

<file path="riscv-vm/src/cpu.rs">
use crate::bus::Bus;
use crate::clint::{CLINT_BASE, MTIME_OFFSET};
use crate::csr::{
    Mode, CSR_MCAUSE, CSR_MEPC, CSR_MISA, CSR_MSTATUS, CSR_MTVEC, CSR_MTVAL, CSR_MIDELEG,
    CSR_MIE, CSR_MIP, CSR_SATP, CSR_MEDELEG, CSR_STVEC, CSR_SEPC, CSR_SCAUSE, CSR_STVAL, CSR_SIE,
    CSR_SSTATUS, CSR_SIP, CSR_TIME, CSR_MENVCFG, CSR_STIMECMP, CSR_MHARTID,
};
use crate::decoder::{self, Op, Register};
use crate::mmu::{self, AccessType as MmuAccessType, Tlb};
use crate::Trap;
use std::collections::HashMap;


/// Cached decode result.
/// Stores (pc, raw_instruction, decoded_op) for cache hit checking.
type DecodeCacheEntry = (u64, u32, Op);

/// Cache size (power of 2 for fast modulo)
const DECODE_CACHE_SIZE: usize = 256;
const DECODE_CACHE_MASK: usize = DECODE_CACHE_SIZE - 1;

/// RISC-V CPU core.
///
/// Aligned to 128 bytes to prevent false sharing when multiple CPUs are
/// allocated in an array or Vec. Most x86-64 cache lines are 64 bytes,
/// but Apple M1/M2 uses 128-byte cache lines.
#[repr(align(128))]
pub struct Cpu {
    pub regs: [u64; 32],
    pub pc: u64,
    /// Reservation set address for LR/SC (granule-aligned), or None if no reservation.
    reservation: Option<u64>,
    /// Simple CSR storage for Zicsr (12-bit CSR address space).
    csrs: [u64; 4096],
    /// Current privilege mode (Machine/Supervisor/User).
    pub mode: Mode,
    /// Per-hart TLB for Sv39/Sv48 translation.
    pub tlb: Tlb,
    /// Poll counter for batching interrupt checks (rolls over every 256 instructions).
    /// Exposed for testing to force immediate interrupt polling.
    pub poll_counter: u8,
    /// Instruction decode cache.
    /// Key: pc & DECODE_CACHE_MASK
    /// Value: Some((full_pc, raw_insn, decoded_op)) or None
    decode_cache: [Option<DecodeCacheEntry>; DECODE_CACHE_SIZE],
}

impl Cpu {
    /// Create a new CPU with the given entry point and hart ID.
    /// 
    /// # Arguments
    /// * `pc` - Initial program counter (kernel entry point)
    /// * `hart_id` - Hardware thread ID (0 for primary, 1+ for secondary)
    pub fn new(pc: u64, hart_id: u64) -> Self {
        let mut csrs = [0u64; 4096];
        // misa: rv64imac_zicsr_zifencei (value from phase-0.md)
        const MISA_RV64IMAC_ZICSR_ZIFENCEI: u64 = 0x4000_0000_0018_1125;
        csrs[CSR_MISA as usize] = MISA_RV64IMAC_ZICSR_ZIFENCEI;
        csrs[CSR_MHARTID as usize] = hart_id;  // Initialize hart ID

        // mstatus initial value: all zeros except UXL/SXL can be left as 0 (WARL).
        csrs[CSR_MSTATUS as usize] = 0;

        Self {
            regs: [0; 32],
            pc,
            reservation: None,
            csrs,
            mode: Mode::Machine,
            tlb: Tlb::new(),
            poll_counter: 0,
            decode_cache: [None; DECODE_CACHE_SIZE],
        }
    }

    /// Export the current CSR image into a compact map suitable for
    /// serialization in snapshots.
    pub fn export_csrs(&self) -> HashMap<u16, u64> {
        let mut map = HashMap::new();
        for (idx, &val) in self.csrs.iter().enumerate() {
            if val != 0 {
                map.insert(idx as u16, val);
            }
        }
        map
    }

    /// Restore CSRs from a previously exported map.
    ///
    /// Any CSR not present in the map is reset to 0. This is intentionally
    /// low-level and bypasses architectural WARL checks; it is only used for
    /// snapshot/restore.
    pub fn import_csrs(&mut self, map: &HashMap<u16, u64>) {
        self.csrs = [0u64; 4096];
        for (&addr, &val) in map.iter() {
            let idx = addr as usize;
            if idx < self.csrs.len() {
                self.csrs[idx] = val;
            }
        }
    }

    /// Look up instruction in decode cache
    #[inline]
    fn decode_cache_lookup(&self, pc: u64, raw: u32) -> Option<Op> {
        let idx = (pc as usize) & DECODE_CACHE_MASK;
        if let Some((cached_pc, cached_raw, op)) = self.decode_cache[idx] {
            if cached_pc == pc && cached_raw == raw {
                return Some(op);
            }
        }
        None
    }

    /// Insert decoded instruction into cache
    #[inline]
    fn decode_cache_insert(&mut self, pc: u64, raw: u32, op: Op) {
        let idx = (pc as usize) & DECODE_CACHE_MASK;
        self.decode_cache[idx] = Some((pc, raw, op));
    }

    /// Invalidate entire decode cache (call on TLB flush, context switch)
    pub fn invalidate_decode_cache(&mut self) {
        self.decode_cache = [None; DECODE_CACHE_SIZE];
    }

    pub fn read_reg(&self, reg: Register) -> u64 {
        if reg == Register::X0 {
            0
        } else {
            self.regs[reg.to_usize()]
        }
    }

    pub fn write_reg(&mut self, reg: Register, val: u64) {
        if reg != Register::X0 {
            self.regs[reg.to_usize()] = val;
        }
    }

    fn reservation_granule(addr: u64) -> u64 {
        const GRANULE: u64 = 64;
        addr & !(GRANULE - 1)
    }

    fn clear_reservation_if_conflict(&mut self, addr: u64) {
        if let Some(res) = self.reservation {
            if Self::reservation_granule(res) == Self::reservation_granule(addr) {
                self.reservation = None;
            }
        }
    }

    pub fn read_csr(&self, addr: u16) -> Result<u64, Trap> {
        // Privilege checks per RISC-V privileged spec:
        // CSR address bits [9:8] encode the lowest privilege level that can access:
        //   00 = User, 01 = Supervisor, 10 = Hypervisor (reserved), 11 = Machine
        let required_priv = (addr >> 8) & 0x3;
        let current_priv = match self.mode {
            Mode::User => 0,
            Mode::Supervisor => 1,
            Mode::Machine => 3,
        };
        if current_priv < required_priv {
            return Err(Trap::IllegalInstruction(addr as u64));
        }

        match addr {
            CSR_SSTATUS => {
                let mstatus = self.csrs[CSR_MSTATUS as usize];
                // Mask for sstatus view: SIE(1), SPIE(5), SPP(8), FS(13:14), XS(15:16), SUM(18), MXR(19), UXL(32:33), SD(63)
                // Simplified mask for this emulator:
                let mask = (1 << 1) | (1 << 5) | (1 << 8) | (3 << 13) | (1 << 18) | (1 << 19);
                Ok(mstatus & mask)
            }
            CSR_SIE => {
                let mie = self.csrs[CSR_MIE as usize];
                // Mask delegated interrupts: SSIP(1), STIP(5), SEIP(9)
                let mask = (1 << 1) | (1 << 5) | (1 << 9);
                Ok(mie & mask)
            }
            CSR_SIP => {
                let mip = self.csrs[CSR_MIP as usize];
                let mask = (1 << 1) | (1 << 5) | (1 << 9);
                Ok(mip & mask)
            }
            _ => Ok(self.csrs[addr as usize]),
        }
    }

    pub fn write_csr(&mut self, addr: u16, val: u64) -> Result<(), Trap> {
        // Read-only CSRs have bits [11:10] == 0b11
        let read_only = (addr >> 10) & 0x3 == 0x3;
        if read_only {
            // Writes to read-only CSRs are ignored (WARL behavior for some, illegal for others)
            // For simplicity, we just ignore the write
            return Ok(());
        }
        
        // Privilege checks per RISC-V privileged spec:
        // CSR address bits [9:8] encode the lowest privilege level that can access
        let required_priv = (addr >> 8) & 0x3;
        let current_priv = match self.mode {
            Mode::User => 0,
            Mode::Supervisor => 1,
            Mode::Machine => 3,
        };
        if current_priv < required_priv {
            return Err(Trap::IllegalInstruction(addr as u64));
        }

        match addr {
            CSR_SSTATUS => {
                let mut mstatus = self.csrs[CSR_MSTATUS as usize];
                let mask = (1 << 1) | (1 << 5) | (1 << 8) | (3 << 13) | (1 << 18) | (1 << 19);
                mstatus = (mstatus & !mask) | (val & mask);
                self.csrs[CSR_MSTATUS as usize] = mstatus;
                Ok(())
            }
            CSR_SIE => {
                let mut mie = self.csrs[CSR_MIE as usize];
                let mask = (1 << 1) | (1 << 5) | (1 << 9);
                mie = (mie & !mask) | (val & mask);
                self.csrs[CSR_MIE as usize] = mie;
                Ok(())
            }
            CSR_SIP => {
                let mut mip = self.csrs[CSR_MIP as usize];
                // Only SSIP is writable in SIP
                let mask = 1 << 1;
                mip = (mip & !mask) | (val & mask);
                self.csrs[CSR_MIP as usize] = mip;
                Ok(())
            }
            _ => {
                self.csrs[addr as usize] = val;
                Ok(())
            }
        }
    }

    /// Map a `Trap` into (is_interrupt, cause, tval) per privileged spec, or `None` if it's a host-only error.
    fn trap_to_cause_tval(trap: &Trap) -> Option<(bool, u64, u64)> {
        match *trap {
            Trap::InstructionAddressMisaligned(addr) => Some((false, 0, addr)),
            Trap::InstructionAccessFault(addr) => Some((false, 1, addr)),
            Trap::IllegalInstruction(bits) => Some((false, 2, bits)),
            Trap::Breakpoint => Some((false, 3, 0)),
            Trap::LoadAddressMisaligned(addr) => Some((false, 4, addr)),
            Trap::LoadAccessFault(addr) => Some((false, 5, addr)),
            Trap::StoreAddressMisaligned(addr) => Some((false, 6, addr)),
            Trap::StoreAccessFault(addr) => Some((false, 7, addr)),
            Trap::EnvironmentCallFromU => Some((false, 8, 0)),
            Trap::EnvironmentCallFromS => Some((false, 9, 0)),
            Trap::EnvironmentCallFromM => Some((false, 11, 0)),
            Trap::InstructionPageFault(addr) => Some((false, 12, addr)),
            Trap::LoadPageFault(addr) => Some((false, 13, addr)),
            Trap::StorePageFault(addr) => Some((false, 15, addr)),
            
            Trap::SupervisorSoftwareInterrupt => Some((true, 1, 0)),
            Trap::MachineSoftwareInterrupt => Some((true, 3, 0)),
            Trap::SupervisorTimerInterrupt => Some((true, 5, 0)),
            Trap::MachineTimerInterrupt => Some((true, 7, 0)),
            Trap::SupervisorExternalInterrupt => Some((true, 9, 0)),
            Trap::MachineExternalInterrupt => Some((true, 11, 0)),

            Trap::RequestedTrap(_) | Trap::Fatal(_) => None,
        }
    }

    fn handle_trap<T>(&mut self, trap: Trap, pc: u64, _insn_raw: Option<u32>) -> Result<T, Trap> {
        // Fatal/host-only traps bypass architectural trap entry.
        if let Some((is_interrupt, cause, tval)) = Self::trap_to_cause_tval(&trap) {
            // Determine delegation target per medeleg/mideleg
            let medeleg = self.csrs[CSR_MEDELEG as usize];
            let mideleg = self.csrs[CSR_MIDELEG as usize];
            let deleg_bit = 1u64 << (cause as u64);

            let deleg_to_s = match self.mode {
                // Delegation to a lower privilege is only meaningful when not in Machine mode
                Mode::Machine => false,
                _ => {
                    if is_interrupt {
                        (mideleg & deleg_bit) != 0
                    } else {
                        (medeleg & deleg_bit) != 0
                    }
                }
            };

            if deleg_to_s {
                // Supervisor trap entry (do not modify M-mode CSRs)
                // Save faulting PC and tval to supervisor CSRs
                self.csrs[CSR_SEPC as usize] = pc;
                self.csrs[CSR_STVAL as usize] = tval;
                let scause_val = ((is_interrupt as u64) << 63) | (cause & 0x7FFF_FFFF_FFFF_FFFF);
                self.csrs[CSR_SCAUSE as usize] = scause_val;

                // Update mstatus: SPP, SPIE, clear SIE
                let mut mstatus = self.csrs[CSR_MSTATUS as usize];
                if log::log_enabled!(log::Level::Trace) {
                    log::trace!("Trap to S-mode: mstatus_before={:x}", mstatus);
                }
                
                let sie = (mstatus >> 1) & 1;
                // SPIE <= SIE
                mstatus = (mstatus & !(1 << 5)) | (sie << 5);
                // SIE <= 0
                mstatus &= !(1 << 1);
                // SPP <= current privilege (1 if S, 0 if U)
                let spp = match self.mode {
                    Mode::Supervisor => 1,
                    _ => 0,
                };
                mstatus = (mstatus & !(1 << 8)) | (spp << 8);
                self.csrs[CSR_MSTATUS as usize] = mstatus;
                
                if log::log_enabled!(log::Level::Trace) {
                    log::trace!("Trap to S-mode: mstatus_after={:x}", mstatus);
                }

                self.mode = Mode::Supervisor;

                // Set PC to stvec (vectored if interrupt and mode==1)
                let stvec = self.csrs[CSR_STVEC as usize];
                let base = stvec & !0b11;
                let mode = stvec & 0b11;
                let vectored = mode == 1;
                let target_pc = if is_interrupt && vectored {
                    base.wrapping_add(4 * cause)
                } else {
                    base
                };
                self.pc = target_pc;
            } else {
                // Machine trap entry (default)
                // Save faulting PC and tval.
                self.csrs[CSR_MEPC as usize] = pc;
                self.csrs[CSR_MTVAL as usize] = tval;

                let mcause_val = ((is_interrupt as u64) << 63) | (cause & 0x7FFF_FFFF_FFFF_FFFF);
                self.csrs[CSR_MCAUSE as usize] = mcause_val;

                // Update mstatus: MPP, MPIE, clear MIE
                let mut mstatus = self.csrs[CSR_MSTATUS as usize];
                let mie = (mstatus >> 3) & 1;
                // MPIE <= MIE, MIE <= 0
                mstatus = (mstatus & !(1 << 7)) | (mie << 7);
                mstatus &= !(1 << 3);
                // MPP <= current mode.
                let mpp = self.mode.to_mpp();
                mstatus = (mstatus & !(0b11 << 11)) | (mpp << 11);
                self.csrs[CSR_MSTATUS as usize] = mstatus;
                self.mode = Mode::Machine;

                // Set PC to mtvec (vectored if interrupt and mode==1)
                let mtvec = self.csrs[CSR_MTVEC as usize];
                let base = mtvec & !0b11;
                let mode = mtvec & 0b11;
                let vectored = mode == 1;
                let target_pc = if is_interrupt && vectored {
                    base.wrapping_add(4 * cause)
                } else {
                    base
                };
                self.pc = target_pc;
            }
        }

        Err(trap)
    }

    /// Translate a virtual address to a physical address using the MMU.
    ///
    /// On translation failure, this enters the trap handler and returns the
    /// trap via `Err`.
    fn translate_addr(
        &mut self,
        bus: &dyn Bus,
        vaddr: u64,
        access: MmuAccessType,
        pc: u64,
        insn_raw: Option<u32>,
    ) -> Result<u64, Trap> {
        let satp = self.csrs[CSR_SATP as usize];
        let mstatus = self.csrs[CSR_MSTATUS as usize];
        match mmu::translate(bus, &mut self.tlb, self.mode, satp, mstatus, vaddr, access) {
            Ok(pa) => Ok(pa),
            Err(trap) => self.handle_trap(trap, pc, insn_raw),
        }
    }

    #[inline]
    fn fetch_and_expand(&mut self, bus: &dyn Bus) -> Result<(u32, u8), Trap> {
        let pc = self.pc;
        if pc % 2 != 0 {
            return self.handle_trap(Trap::InstructionAddressMisaligned(pc), pc, None);
        }

        // Optimization: if PC is 4-byte aligned, try to read 32 bits at once
        if pc % 4 == 0 {
            let pa = self.translate_addr(bus, pc, MmuAccessType::Instruction, pc, None)?;
            if let Ok(word) = bus.read32(pa) {
                // Check if it's a compressed instruction (bits [1:0] != 0b11)
                if word & 0x3 != 0x3 {
                    // Compressed: expand lower 16 bits
                    let insn32 = match decoder::expand_compressed((word & 0xFFFF) as u16) {
                        Ok(v) => v,
                        Err(trap) => return self.handle_trap(trap, pc, None),
                    };
                    return Ok((insn32, 2));
                }
                // Full 32-bit instruction
                return Ok((word, 4));
            }
            // Fall through to 16-bit fetch on read32 failure
        }

        // Fetch first halfword via MMU (instruction access).
        let pa_low = self.translate_addr(bus, pc, MmuAccessType::Instruction, pc, None)?;
        let half = match bus.read16(pa_low) {
            Ok(v) => v,
            Err(e) => {
                // Map load faults from the bus into instruction faults.
                let mapped = match e {
                    Trap::LoadAccessFault(_) => Trap::InstructionAccessFault(pc),
                    Trap::LoadAddressMisaligned(_) => Trap::InstructionAddressMisaligned(pc),
                    other => other,
                };
                return self.handle_trap(mapped, pc, None);
            }
        };

        if half & 0x3 != 0x3 {
            // Compressed 16-bit instruction
            let insn32 = match decoder::expand_compressed(half) {
                Ok(v) => v,
                Err(trap) => return self.handle_trap(trap, pc, None),
            };
            Ok((insn32, 2))
        } else {
            // 32-bit instruction; fetch high half via MMU as well.
            let pc_hi = pc.wrapping_add(2);
            let pa_hi = self.translate_addr(bus, pc_hi, MmuAccessType::Instruction, pc, None)?;
            let hi = match bus.read16(pa_hi) {
                Ok(v) => v,
                Err(e) => {
                    let mapped = match e {
                        Trap::LoadAccessFault(_) => Trap::InstructionAccessFault(pc),
                        Trap::LoadAddressMisaligned(_) => Trap::InstructionAddressMisaligned(pc),
                        other => other,
                    };
                    return self.handle_trap(mapped, pc, None);
                }
            };
            let insn32 = (half as u32) | ((hi as u32) << 16);
            Ok((insn32, 4))
        }
    }

    fn check_pending_interrupt(&self) -> Option<Trap> {
        let mstatus = self.csrs[CSR_MSTATUS as usize];
        let mip = self.csrs[CSR_MIP as usize];
        let mie = self.csrs[CSR_MIE as usize];
        let mideleg = self.csrs[CSR_MIDELEG as usize];

        // SIE is a shadow of MIE for supervisor interrupt bits (SSIP=1, STIP=5, SEIP=9)
        let sie_mask: u64 = (1 << 1) | (1 << 5) | (1 << 9);
        let sie = mie & sie_mask;

        // Mask delegated interrupts out of machine set, and into supervisor set.
        let m_pending = (mip & mie) & !mideleg;
        let s_pending = (mip & sie) & mideleg;

        // Machine mode global enable:
        // Enabled if (currently in Machine and MIE==1) OR (currently below Machine).
        let m_enabled = match self.mode {
            Mode::Machine => ((mstatus >> 3) & 1) == 1, // MIE
            _ => true,
        };
        if m_enabled {
            if (m_pending & (1 << 11)) != 0 { return Some(Trap::MachineExternalInterrupt); } // MEIP
            if (m_pending & (1 << 3)) != 0 { return Some(Trap::MachineSoftwareInterrupt); }   // MSIP
            if (m_pending & (1 << 7)) != 0 { return Some(Trap::MachineTimerInterrupt); }      // MTIP
        }

        // Supervisor mode global enable:
        // Enabled if (currently in Supervisor and SIE==1) OR (currently in User).
        let s_enabled = match self.mode {
            Mode::Machine => false,
            Mode::Supervisor => ((mstatus >> 1) & 1) == 1, // SIE
            Mode::User => true,
        };
        
        // DEBUG: Check if we are about to trap for interrupt when we shouldn't
        if s_enabled && s_pending != 0 {
             if log::log_enabled!(log::Level::Trace) {
                 log::trace!("Interrupt pending: s_pending={:x} mstatus={:x} mode={:?}", s_pending, mstatus, self.mode);
             }
        }

        if s_enabled {
            if (s_pending & (1 << 9)) != 0 { return Some(Trap::SupervisorExternalInterrupt); } // SEIP
            if (s_pending & (1 << 1)) != 0 { return Some(Trap::SupervisorSoftwareInterrupt); } // SSIP
            if (s_pending & (1 << 5)) != 0 { return Some(Trap::SupervisorTimerInterrupt); }    // STIP
        }

        None
    }

    /// Execute one instruction.
    ///
    /// Takes shared reference to bus; the bus uses interior mutability
    /// for any state changes.
    pub fn step(&mut self, bus: &dyn Bus) -> Result<(), Trap> {
        // Batch interrupt polling: only check every 256 instructions for performance.
        // This significantly reduces overhead while maintaining responsiveness.
        self.poll_counter = self.poll_counter.wrapping_add(1);
        
        if self.poll_counter == 0 {
            // Poll device-driven interrupts into MIP mask.
            // Each hart must check its own interrupts to receive IPIs correctly.
            let hart_id = self.csrs[CSR_MHARTID as usize] as usize;
            let mut hw_mip = bus.poll_interrupts_for_hart(hart_id);

            // Sstc support: raise STIP (bit 5) when time >= stimecmp and Sstc enabled.
            // menvcfg[63] gate is optional; xv6 enables it.
            let menvcfg = self.csrs[CSR_MENVCFG as usize];
            let sstc_enabled = ((menvcfg >> 63) & 1) == 1;
            let stimecmp = self.csrs[CSR_STIMECMP as usize];
            if sstc_enabled && stimecmp != 0 {
                // Read CLINT MTIME directly (physical address).
                if let Ok(now) = bus.read64(CLINT_BASE + MTIME_OFFSET) {
                    if now >= stimecmp {
                        hw_mip |= 1 << 5; // STIP
                    }
                }
            }

            // Update MIP: preserve software-writable bits (SSIP=bit1, STIP=bit5 if not Sstc),
            // but always update hardware-driven bits (MSIP=3, MTIP=7, SEIP=9, MEIP=11).
            // SSIP (bit 1) is software-writable and should be preserved.
            // STIP (bit 5) is normally read-only but Sstc makes it hardware-driven.
            let hw_bits: u64 = (1 << 3) | (1 << 7) | (1 << 9) | (1 << 11); // MSIP, MTIP, SEIP, MEIP
            let hw_bits_with_stip: u64 = hw_bits | (1 << 5); // Include STIP when Sstc enabled
            
            let mask = if sstc_enabled { hw_bits_with_stip } else { hw_bits };
            let old_mip = self.csrs[CSR_MIP as usize];
            self.csrs[CSR_MIP as usize] = (old_mip & !mask) | (hw_mip & mask);
            
            if let Some(trap) = self.check_pending_interrupt() {
                return self.handle_trap(trap, self.pc, None);
            }
        }

        let pc = self.pc;
        // Fetch (supports compressed 16-bit and regular 32-bit instructions)
        let (insn_raw, insn_len) = self.fetch_and_expand(bus)?;

        // Try decode cache first
        let op = if let Some(cached_op) = self.decode_cache_lookup(pc, insn_raw) {
            cached_op
        } else {
            // Cache miss: decode and insert
            let op = match decoder::decode(insn_raw) {
                Ok(v) => v,
                Err(trap) => return self.handle_trap(trap, pc, Some(insn_raw)),
            };
            self.decode_cache_insert(pc, insn_raw, op);
            op
        };

        let mut next_pc = pc.wrapping_add(insn_len as u64);

        match op {
            Op::Lui { rd, imm } => {
                self.write_reg(rd, imm as u64);
            }
            Op::Auipc { rd, imm } => {
                self.write_reg(rd, pc.wrapping_add(imm as u64));
            }
            Op::Jal { rd, imm } => {
                self.write_reg(rd, pc.wrapping_add(insn_len as u64));
                next_pc = pc.wrapping_add(imm as u64);
                if next_pc % 2 != 0 {
                    return self.handle_trap(
                        Trap::InstructionAddressMisaligned(next_pc),
                        pc,
                        Some(insn_raw),
                    );
                }
            }
            Op::Jalr { rd, rs1, imm } => {
                let target = self.read_reg(rs1).wrapping_add(imm as u64) & !1;
                self.write_reg(rd, pc.wrapping_add(insn_len as u64));
                next_pc = target;
                if next_pc % 2 != 0 {
                    return self.handle_trap(
                        Trap::InstructionAddressMisaligned(next_pc),
                        pc,
                        Some(insn_raw),
                    );
                }
            }
            Op::Branch {
                rs1,
                rs2,
                imm,
                funct3,
            } => {
                let val1 = self.read_reg(rs1);
                let val2 = self.read_reg(rs2);
                let taken = match funct3 {
                    0 => val1 == val2,                   // BEQ
                    1 => val1 != val2,                   // BNE
                    4 => (val1 as i64) < (val2 as i64),  // BLT
                    5 => (val1 as i64) >= (val2 as i64), // BGE
                    6 => val1 < val2,                    // BLTU
                    7 => val1 >= val2,                   // BGEU
                    _ => {
                        return self.handle_trap(
                            Trap::IllegalInstruction(insn_raw as u64),
                            pc,
                            Some(insn_raw),
                        )
                    }
                };
                if taken {
                    next_pc = pc.wrapping_add(imm as u64);
                    if next_pc % 2 != 0 {
                        return self.handle_trap(
                            Trap::InstructionAddressMisaligned(next_pc),
                            pc,
                            Some(insn_raw),
                        );
                    }
                }
            }
            Op::Load {
                rd,
                rs1,
                imm,
                funct3,
            } => {
                let addr = self.read_reg(rs1).wrapping_add(imm as u64);
                let val = match funct3 {
                    0 => {
                        let pa = self.translate_addr(bus, addr, MmuAccessType::Load, pc, Some(insn_raw))?;
                        match bus.read8(pa) {
                        Ok(v) => (v as i8) as i64 as u64, // LB
                        Err(e) => return self.handle_trap(e, pc, Some(insn_raw)),
                    }}
                    1 => {
                        let pa = self.translate_addr(bus, addr, MmuAccessType::Load, pc, Some(insn_raw))?;
                        match bus.read16(pa) {
                        Ok(v) => (v as i16) as i64 as u64, // LH
                        Err(e) => return self.handle_trap(e, pc, Some(insn_raw)),
                    }}
                    2 => {
                        let pa = self.translate_addr(bus, addr, MmuAccessType::Load, pc, Some(insn_raw))?;
                        match bus.read32(pa) {
                        Ok(v) => (v as i32) as i64 as u64, // LW
                        Err(e) => return self.handle_trap(e, pc, Some(insn_raw)),
                    }}
                    3 => {
                        let pa = self.translate_addr(bus, addr, MmuAccessType::Load, pc, Some(insn_raw))?;
                        match bus.read64(pa) {
                        Ok(v) => v, // LD
                        Err(e) => return self.handle_trap(e, pc, Some(insn_raw)),
                    }}
                    4 => {
                        let pa = self.translate_addr(bus, addr, MmuAccessType::Load, pc, Some(insn_raw))?;
                        match bus.read8(pa) {
                        Ok(v) => v as u64, // LBU
                        Err(e) => return self.handle_trap(e, pc, Some(insn_raw)),
                    }}
                    5 => {
                        let pa = self.translate_addr(bus, addr, MmuAccessType::Load, pc, Some(insn_raw))?;
                        match bus.read16(pa) {
                        Ok(v) => v as u64, // LHU
                        Err(e) => return self.handle_trap(e, pc, Some(insn_raw)),
                    }}
                    6 => {
                        let pa = self.translate_addr(bus, addr, MmuAccessType::Load, pc, Some(insn_raw))?;
                        match bus.read32(pa) {
                        Ok(v) => v as u64, // LWU
                        Err(e) => return self.handle_trap(e, pc, Some(insn_raw)),
                    }}
                    _ => {
                        return self.handle_trap(
                            Trap::IllegalInstruction(insn_raw as u64),
                            pc,
                            Some(insn_raw),
                        )
                    }
                };
                self.write_reg(rd, val);
            }
            Op::Store {
                rs1,
                rs2,
                imm,
                funct3,
            } => {
                let addr = self.read_reg(rs1).wrapping_add(imm as u64);
                let pa = self.translate_addr(bus, addr, MmuAccessType::Store, pc, Some(insn_raw))?;
                // Any store to the reservation granule clears LR/SC reservation.
                self.clear_reservation_if_conflict(addr);
                let val = self.read_reg(rs2);
                let res = match funct3 {
                    0 => bus.write8(pa, val as u8),   // SB
                    1 => bus.write16(pa, val as u16), // SH
                    2 => bus.write32(pa, val as u32), // SW
                    3 => bus.write64(pa, val),        // SD
                    _ => {
                        return self.handle_trap(
                            Trap::IllegalInstruction(insn_raw as u64),
                            pc,
                            Some(insn_raw),
                        )
                    }
                };
                if let Err(e) = res {
                    return self.handle_trap(e, pc, Some(insn_raw));
                }
            }
            Op::OpImm {
                rd,
                rs1,
                imm,
                funct3,
                funct7,
            } => {
                let val1 = self.read_reg(rs1);
                let res = match funct3 {
                    0 => val1.wrapping_add(imm as u64), // ADDI
                    2 => {
                        if (val1 as i64) < imm {
                            1
                        } else {
                            0
                        }
                    } // SLTI
                    3 => {
                        if val1 < (imm as u64) {
                            1
                        } else {
                            0
                        }
                    } // SLTIU
                    4 => val1 ^ (imm as u64),           // XORI
                    6 => val1 | (imm as u64),           // ORI
                    7 => val1 & (imm as u64),           // ANDI
                    1 => {
                        // SLLI
                        let shamt = imm & 0x3F;
                        val1 << shamt
                    }
                    5 => {
                        // SRLI / SRAI
                        let shamt = imm & 0x3F;
                        if funct7 & 0x20 != 0 {
                            // SRAI
                            ((val1 as i64) >> shamt) as u64
                        } else {
                            // SRLI
                            val1 >> shamt
                        }
                    }
                    _ => {
                        return self.handle_trap(
                            Trap::IllegalInstruction(insn_raw as u64),
                            pc,
                            Some(insn_raw),
                        )
                    }
                };
                self.write_reg(rd, res);
            }
            Op::Op {
                rd,
                rs1,
                rs2,
                funct3,
                funct7,
            } => {
                let val1 = self.read_reg(rs1);
                let val2 = self.read_reg(rs2);
                let res = match (funct3, funct7) {
                    (0, 0x00) => val1.wrapping_add(val2), // ADD
                    (0, 0x20) => val1.wrapping_sub(val2), // SUB
                    // M-extension (RV64M) - MUL/DIV/REM on XLEN=64
                    (0, 0x01) => {
                        // MUL: low 64 bits of signed(rs1) * signed(rs2)
                        let a = val1 as i64 as i128;
                        let b = val2 as i64 as i128;
                        (a.wrapping_mul(b) as i64) as u64
                    }
                    (1, 0x00) => val1 << (val2 & 0x3F), // SLL
                    (1, 0x01) => {
                        // MULH: high 64 bits of signed * signed
                        let a = val1 as i64 as i128;
                        let b = val2 as i64 as i128;
                        ((a.wrapping_mul(b) >> 64) as i64) as u64
                    }
                    (2, 0x00) => {
                        if (val1 as i64) < (val2 as i64) {
                            1
                        } else {
                            0
                        }
                    } // SLT
                    (2, 0x01) => {
                        // MULHSU: high 64 bits of signed * unsigned
                        let a = val1 as i64 as i128;
                        let b = val2 as u64 as i128;
                        ((a.wrapping_mul(b) >> 64) as i64) as u64
                    }
                    (3, 0x00) => {
                        if val1 < val2 {
                            1
                        } else {
                            0
                        }
                    } // SLTU
                    (3, 0x01) => {
                        // MULHU: high 64 bits of unsigned * unsigned
                        let a = val1 as u128;
                        let b = val2 as u128;
                        ((a.wrapping_mul(b) >> 64) as u64) as u64
                    }
                    (4, 0x00) => val1 ^ val2, // XOR
                    (4, 0x01) => {
                        // DIV (signed)
                        let a = val1 as i64;
                        let b = val2 as i64;
                        let q = if b == 0 {
                            -1i64
                        } else if a == i64::MIN && b == -1 {
                            i64::MIN
                        } else {
                            a / b
                        };
                        q as u64
                    }
                    (5, 0x00) => val1 >> (val2 & 0x3F), // SRL
                    (5, 0x01) => {
                        // DIVU (unsigned)
                        let a = val1;
                        let b = val2;
                        let q = if b == 0 { u64::MAX } else { a / b };
                        q
                    }
                    (5, 0x20) => ((val1 as i64) >> (val2 & 0x3F)) as u64, // SRA
                    (6, 0x00) => val1 | val2,                              // OR
                    (6, 0x01) => {
                        // REM (signed)
                        let a = val1 as i64;
                        let b = val2 as i64;
                        let r = if b == 0 {
                            a
                        } else if a == i64::MIN && b == -1 {
                            0
                        } else {
                            a % b
                        };
                        r as u64
                    }
                    (7, 0x00) => val1 & val2, // AND
                    (7, 0x01) => {
                        // REMU (unsigned)
                        let a = val1;
                        let b = val2;
                        let r = if b == 0 { a } else { a % b };
                        r
                    }
                    _ => {
                        return self.handle_trap(
                            Trap::IllegalInstruction(insn_raw as u64),
                            pc,
                            Some(insn_raw),
                        )
                    }
                };
                self.write_reg(rd, res);
            }
            Op::OpImm32 {
                rd,
                rs1,
                imm,
                funct3,
                funct7,
            } => {
                let val1 = self.read_reg(rs1);
                let res = match funct3 {
                    0 => (val1.wrapping_add(imm as u64) as i32) as i64 as u64, // ADDIW
                    1 => ((val1 as u32) << (imm & 0x1F)) as i32 as i64 as u64, // SLLIW
                    5 => {
                        let shamt = imm & 0x1F;
                        if funct7 & 0x20 != 0 {
                            // SRAIW
                            ((val1 as i32) >> shamt) as i64 as u64
                        } else {
                            // SRLIW
                            ((val1 as u32) >> shamt) as i32 as i64 as u64
                        }
                    }
                    _ => {
                        return self.handle_trap(
                            Trap::IllegalInstruction(insn_raw as u64),
                            pc,
                            Some(insn_raw),
                        )
                    }
                };
                self.write_reg(rd, res);
            }
            Op::Op32 {
                rd,
                rs1,
                rs2,
                funct3,
                funct7,
            } => {
                let val1 = self.read_reg(rs1);
                let val2 = self.read_reg(rs2);
                let res = match (funct3, funct7) {
                    (0, 0x00) => (val1.wrapping_add(val2) as i32) as i64 as u64, // ADDW
                    (0, 0x20) => (val1.wrapping_sub(val2) as i32) as i64 as u64, // SUBW
                    (0, 0x01) => {
                        // MULW: low 32 bits of signed* signed, sign-extended to 64
                        let a = val1 as i32 as i64;
                        let b = val2 as i32 as i64;
                        let prod = (a as i128).wrapping_mul(b as i128);
                        (prod as i32) as i64 as u64
                    }
                    (1, 0x00) => ((val1 as u32) << (val2 & 0x1F)) as i32 as i64 as u64, // SLLW
                    (5, 0x00) => ((val1 as u32) >> (val2 & 0x1F)) as i32 as i64 as u64, // SRLW
                    (4, 0x01) => {
                        // DIVW (signed 32-bit)
                        let a = val1 as i32 as i64;
                        let b = val2 as i32 as i64;
                        let q = if b == 0 {
                            -1i64
                        } else if a == i64::from(i32::MIN) && b == -1 {
                            i64::from(i32::MIN)
                        } else {
                            a / b
                        };
                        (q as i32) as i64 as u64
                    }
                    (5, 0x20) => ((val1 as i32) >> (val2 & 0x1F)) as i64 as u64, // SRAW
                    (5, 0x01) => {
                        // DIVUW (unsigned 32-bit)
                        let a = val1 as u32 as u64;
                        let b = val2 as u32 as u64;
                        let q = if b == 0 { u64::MAX } else { a / b };
                        (q as u32) as i32 as i64 as u64
                    }
                    (6, 0x01) => {
                        // REMW (signed 32-bit)
                        let a = val1 as i32 as i64;
                        let b = val2 as i32 as i64;
                        let r = if b == 0 {
                            a
                        } else if a == i64::from(i32::MIN) && b == -1 {
                            0
                        } else {
                            a % b
                        };
                        (r as i32) as i64 as u64
                    }
                    (7, 0x01) => {
                        // REMUW (unsigned 32-bit)
                        let a = val1 as u32 as u64;
                        let b = val2 as u32 as u64;
                        let r = if b == 0 { a } else { a % b };
                        (r as u32) as i32 as i64 as u64
                    }
                    _ => {
                        return self.handle_trap(
                            Trap::IllegalInstruction(insn_raw as u64),
                            pc,
                            Some(insn_raw),
                        )
                    }
                };
                self.write_reg(rd, res);
            }
            Op::Amo {
                rd,
                rs1,
                rs2,
                funct3,
                funct5,
                ..
            } => {
                let addr = self.read_reg(rs1);

                // Translate once per AMO/LD/ST sequence.
                let pa = self.translate_addr(bus, addr, MmuAccessType::Load, pc, Some(insn_raw))?;

                // Only word (funct3=2) and doubleword (funct3=3) widths are valid.
                let is_word = match funct3 {
                    2 => true,
                    3 => false,
                    _ => {
                        return self.handle_trap(
                            Trap::IllegalInstruction(insn_raw as u64),
                            pc,
                            Some(insn_raw),
                        )
                    }
                };

                // LR/SC vs AMO op distinguished by funct5
                match funct5 {
                    0b00010 => {
                        // LR.W / LR.D
                        let loaded = if is_word {
                            match bus.read32(pa) {
                                Ok(v) => v as i32 as i64 as u64,
                                Err(e) => return self.handle_trap(e, pc, Some(insn_raw)),
                            }
                        } else {
                            match bus.read64(pa) {
                                Ok(v) => v,
                                Err(e) => return self.handle_trap(e, pc, Some(insn_raw)),
                            }
                        };
                        self.write_reg(rd, loaded);
                        self.reservation = Some(Self::reservation_granule(addr));
                    }
                    0b00011 => {
                        // SC.W / SC.D
                        // Alignment checks (must be naturally aligned) on the virtual address.
                        if is_word && addr % 4 != 0 {
                            return self.handle_trap(
                                Trap::StoreAddressMisaligned(addr),
                                pc,
                                Some(insn_raw),
                            );
                        }
                        if !is_word && addr % 8 != 0 {
                            return self.handle_trap(
                                Trap::StoreAddressMisaligned(addr),
                                pc,
                                Some(insn_raw),
                            );
                        }
                        let granule = Self::reservation_granule(addr);
                        if self.reservation == Some(granule) {
                            // Successful store
                            let val = self.read_reg(rs2);
                            let res = if is_word {
                                bus.write32(pa, val as u32)
                            } else {
                                bus.write64(pa, val)
                            };
                            if let Err(e) = res {
                                return self.handle_trap(e, pc, Some(insn_raw));
                            }
                            self.write_reg(rd, 0);
                            self.reservation = None;
                        } else {
                            // Failed store, no memory access
                            self.write_reg(rd, 1);
                        }
                    }
                    // AMO* operations - MUST be atomic across all harts
                    // Use Bus trait's atomic methods which properly synchronize
                    // across WASM workers using JavaScript Atomics API.
                    0b00001 => {
                        // AMOSWAP
                        self.clear_reservation_if_conflict(addr);
                        let rs2_val = self.read_reg(rs2);
                        match bus.atomic_swap(pa, rs2_val, is_word) {
                            Ok(old) => self.write_reg(rd, old),
                            Err(e) => return self.handle_trap(e, pc, Some(insn_raw)),
                        }
                    }
                    0b00000 => {
                        // AMOADD
                        self.clear_reservation_if_conflict(addr);
                        let rs2_val = self.read_reg(rs2);
                        match bus.atomic_add(pa, rs2_val, is_word) {
                            Ok(old) => self.write_reg(rd, old),
                            Err(e) => return self.handle_trap(e, pc, Some(insn_raw)),
                        }
                    }
                    0b00100 => {
                        // AMOXOR
                        self.clear_reservation_if_conflict(addr);
                        let rs2_val = self.read_reg(rs2);
                        match bus.atomic_xor(pa, rs2_val, is_word) {
                            Ok(old) => self.write_reg(rd, old),
                            Err(e) => return self.handle_trap(e, pc, Some(insn_raw)),
                        }
                    }
                    0b01000 => {
                        // AMOOR
                        self.clear_reservation_if_conflict(addr);
                        let rs2_val = self.read_reg(rs2);
                        match bus.atomic_or(pa, rs2_val, is_word) {
                            Ok(old) => self.write_reg(rd, old),
                            Err(e) => return self.handle_trap(e, pc, Some(insn_raw)),
                        }
                    }
                    0b01100 => {
                        // AMOAND
                        self.clear_reservation_if_conflict(addr);
                        let rs2_val = self.read_reg(rs2);
                        match bus.atomic_and(pa, rs2_val, is_word) {
                            Ok(old) => self.write_reg(rd, old),
                            Err(e) => return self.handle_trap(e, pc, Some(insn_raw)),
                        }
                    }
                    0b10000 => {
                        // AMOMIN (signed)
                        self.clear_reservation_if_conflict(addr);
                        let rs2_val = self.read_reg(rs2);
                        match bus.atomic_min(pa, rs2_val, is_word) {
                            Ok(old) => self.write_reg(rd, old),
                            Err(e) => return self.handle_trap(e, pc, Some(insn_raw)),
                        }
                    }
                    0b10100 => {
                        // AMOMAX (signed)
                        self.clear_reservation_if_conflict(addr);
                        let rs2_val = self.read_reg(rs2);
                        match bus.atomic_max(pa, rs2_val, is_word) {
                            Ok(old) => self.write_reg(rd, old),
                            Err(e) => return self.handle_trap(e, pc, Some(insn_raw)),
                        }
                    }
                    0b11000 => {
                        // AMOMINU (unsigned)
                        self.clear_reservation_if_conflict(addr);
                        let rs2_val = self.read_reg(rs2);
                        match bus.atomic_minu(pa, rs2_val, is_word) {
                            Ok(old) => self.write_reg(rd, old),
                            Err(e) => return self.handle_trap(e, pc, Some(insn_raw)),
                        }
                    }
                    0b11100 => {
                        // AMOMAXU (unsigned)
                        self.clear_reservation_if_conflict(addr);
                        let rs2_val = self.read_reg(rs2);
                        match bus.atomic_maxu(pa, rs2_val, is_word) {
                            Ok(old) => self.write_reg(rd, old),
                            Err(e) => return self.handle_trap(e, pc, Some(insn_raw)),
                        }
                    }
                    _ => {
                        return self.handle_trap(
                            Trap::IllegalInstruction(insn_raw as u64),
                            pc,
                            Some(insn_raw),
                        );
                    }
                }
            }
            Op::System {
                rd,
                rs1,
                funct3,
                imm,
                ..
            } => {
                match funct3 {
                    0 => {
                        // SYSTEM (ECALL/EBREAK, MRET/SRET, SFENCE.VMA)

                        // Detect SFENCE.VMA via mask/match (funct7=0001001, opcode=0x73, rd=0).
                        const SFENCE_VMA_MASK: u32 = 0b1111111_00000_00000_111_00000_1111111;
                        const SFENCE_VMA_MATCH: u32 = 0b0001001_00000_00000_000_00000_1110011; // 0x12000073

                        if (insn_raw & SFENCE_VMA_MASK) == SFENCE_VMA_MATCH {
                            // Only legal from S or M mode.
                            if matches!(self.mode, Mode::User) {
                                return self.handle_trap(
                                    Trap::IllegalInstruction(insn_raw as u64),
                                    pc,
                                    Some(insn_raw),
                                );
                            }
                            // Simplest implementation: flush entire TLB.
                            self.tlb.flush();
                            // Also invalidate decode cache (PC->PA mappings may have changed)
                            self.invalidate_decode_cache();
                        } else {
                            match insn_raw {
                                0x0010_0073 => {
                                    // EBREAK
                                    return self.handle_trap(Trap::Breakpoint, pc, Some(insn_raw));
                                }
                                0x1050_0073 => {
                                    // WFI - Wait For Interrupt
                                    // Instead of busy-spinning, hint to the CPU to reduce power usage.
                                    // This uses the PAUSE instruction on x86 or equivalent on other archs.
                                    // Multiple iterations give the scheduler a chance to run other threads.
                                    for _ in 0..10 {
                                        std::hint::spin_loop();
                                    }
                                }
                                0x0000_0073 => {
                                    // ECALL - route based on current privilege mode
                                    let trap = match self.mode {
                                        Mode::User => Trap::EnvironmentCallFromU,
                                        Mode::Supervisor => Trap::EnvironmentCallFromS,
                                        Mode::Machine => Trap::EnvironmentCallFromM,
                                    };
                                    return self.handle_trap(trap, pc, Some(insn_raw));
                                }
                                0x3020_0073 => {
                                    // MRET
                                    if self.mode != Mode::Machine {
                                        return self.handle_trap(
                                            Trap::IllegalInstruction(insn_raw as u64),
                                            pc,
                                            Some(insn_raw),
                                        );
                                    }

                                    let mut mstatus = self.csrs[CSR_MSTATUS as usize];
                                    let mepc = self.csrs[CSR_MEPC as usize];

                                    // Extract MPP and MPIE
                                    let mpp_bits = (mstatus >> 11) & 0b11;
                                    let mpie = (mstatus >> 7) & 1;

                                    // Set new privilege mode from MPP
                                    self.mode = Mode::from_mpp(mpp_bits);

                                    // MIE <= MPIE, MPIE <= 1, MPP <= U (00)
                                    mstatus = (mstatus & !(1 << 3)) | (mpie << 3);
                                    mstatus |= 1 << 7; // MPIE = 1
                                    mstatus &= !(0b11 << 11); // MPP = U (00)

                                    self.csrs[CSR_MSTATUS as usize] = mstatus;
                                    next_pc = mepc;
                                }
                                0x1020_0073 => {
                                    // SRET (only valid from S-mode)
                                    if self.mode != Mode::Supervisor {
                                        return self.handle_trap(
                                            Trap::IllegalInstruction(insn_raw as u64),
                                            pc,
                                            Some(insn_raw),
                                        );
                                    }

                                    // We model only the SPP/SIE/SPIE subset of mstatus.
                                    let mut mstatus = self.csrs[CSR_MSTATUS as usize];
                                    let sepc = self.csrs[CSR_SEPC as usize];

                                    // SPP is bit 8, SPIE is bit 5, SIE is bit 1.
                                    let spp = (mstatus >> 8) & 1;
                                    let spie = (mstatus >> 5) & 1;

                                    self.mode = if spp == 0 {
                                        Mode::User
                                    } else {
                                        Mode::Supervisor
                                    };

                                    // SIE <= SPIE, SPIE <= 1, SPP <= U (0)
                                    mstatus = (mstatus & !(1 << 1)) | (spie << 1);
                                    mstatus |= 1 << 5; // SPIE = 1
                                    mstatus &= !(1 << 8); // SPP = U

                                    self.csrs[CSR_MSTATUS as usize] = mstatus;
                                    next_pc = sepc;
                                }
                                _ => {
                                    return self.handle_trap(
                                        Trap::IllegalInstruction(insn_raw as u64),
                                        pc,
                                        Some(insn_raw),
                                    );
                                }
                            }
                        }
                    }
                    // Zicsr: CSRRW/CSRRS/CSRRC
                    1 | 2 | 3 | 5 | 6 | 7 => {
                        let csr_addr = (imm & 0xFFF) as u16;
                        // Dynamic read for time CSR to reflect CLINT MTIME.
                        let old = if csr_addr == CSR_TIME {
                            bus.read64(CLINT_BASE + MTIME_OFFSET).unwrap_or(0)
                        } else {
                            match self.read_csr(csr_addr) {
                                Ok(v) => v,
                                Err(e) => return self.handle_trap(e, pc, Some(insn_raw)),
                            }
                        };

                        let mut write_new = None::<u64>;
                        match funct3 {
                            // CSRRW: write rs1, rd = old
                            1 => {
                                let rs1_val = self.read_reg(rs1);
                                write_new = Some(rs1_val);
                            }
                            // CSRRS: set bits in CSR with rs1
                            2 => {
                                let rs1_val = self.read_reg(rs1);
                                if rs1 != Register::X0 {
                                    write_new = Some(old | rs1_val);
                                }
                            }
                            // CSRRC: clear bits in CSR with rs1
                            3 => {
                                let rs1_val = self.read_reg(rs1);
                                if rs1 != Register::X0 {
                                    write_new = Some(old & !rs1_val);
                                }
                            }
                            // CSRRWI: write zero-extended zimm, rd = old
                            5 => {
                                let zimm = rs1.to_usize() as u64;
                                write_new = Some(zimm);
                            }
                            // CSRRSI: set bits using zimm (if non-zero)
                            6 => {
                                let zimm = rs1.to_usize() as u64;
                                if zimm != 0 {
                                    write_new = Some(old | zimm);
                                }
                            }
                            // CSRRCI: clear bits using zimm (if non-zero)
                            7 => {
                                let zimm = rs1.to_usize() as u64;
                                if zimm != 0 {
                                    write_new = Some(old & !zimm);
                                }
                            }
                            _ => {}
                        }

                        if let Some(new_val) = write_new {
                            if let Err(e) = self.write_csr(csr_addr, new_val) {
                                return self.handle_trap(e, pc, Some(insn_raw));
                            }
                            // Invalidate decode cache if SATP changed (address space switch)
                            if csr_addr == CSR_SATP {
                                self.tlb.flush();
                                self.invalidate_decode_cache();
                            }
                        }

                        if rd != Register::X0 {
                            self.write_reg(rd, old);
                        }
                    }
                    _ => {
                        return self.handle_trap(
                            Trap::IllegalInstruction(insn_raw as u64),
                            pc,
                            Some(insn_raw),
                        );
                    }
                }
            }
            Op::Fence => {
                // NOP
            }
        }

        self.pc = next_pc;
        Ok(())
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::bus::SystemBus;

    // --- Memory layout tests (Task 10.1) ---------------------------------

    #[test]
    fn measure_struct_sizes() {
        println!("=== Phase 10 Memory Layout Analysis ===");
        println!("Cpu size: {} bytes", std::mem::size_of::<Cpu>());
        println!("Cpu align: {} bytes", std::mem::align_of::<Cpu>());
        println!();

        // Verify cache-line alignment for multi-hart safety
        assert!(
            std::mem::align_of::<Cpu>() >= 64,
            "Cpu should be cache-line aligned (>= 64 bytes)"
        );
    }

    #[test]
    fn test_cpu_alignment() {
        // Verify Cpu is properly aligned for cache-line isolation
        assert!(
            std::mem::align_of::<Cpu>() >= 64,
            "Cpu alignment should be at least 64 bytes for cache-line isolation"
        );

        // On Apple Silicon, cache lines are 128 bytes, so we align to 128
        assert_eq!(
            std::mem::align_of::<Cpu>(),
            128,
            "Cpu should be aligned to 128 bytes for Apple M1/M2 compatibility"
        );
    }

    #[test]
    fn test_cpu_array_no_false_sharing() {
        // Create multiple CPUs in a Vec to simulate multi-hart scenario
        let cpus: Vec<Cpu> = (0..4)
            .map(|i| Cpu::new(0x8000_0000, i as u64))
            .collect();

        // Verify that adjacent CPUs are at least 64 bytes apart (one cache line)
        for i in 0..cpus.len() - 1 {
            let addr_i = &cpus[i] as *const _ as usize;
            let addr_j = &cpus[i + 1] as *const _ as usize;
            let distance = addr_j - addr_i;

            assert!(
                distance >= 64,
                "CPUs {} and {} are only {} bytes apart (need >= 64 for cache-line isolation)",
                i,
                i + 1,
                distance
            );
        }
    }

    // --- Test helpers ----------------------------------------------------

    fn encode_i(imm: i32, rs1: u32, funct3: u32, rd: u32, opcode: u32) -> u32 {
        (((imm as u32) & 0xFFF) << 20) | (rs1 << 15) | (funct3 << 12) | (rd << 7) | opcode
    }

    fn encode_r(funct7: u32, rs2: u32, rs1: u32, funct3: u32, rd: u32, opcode: u32) -> u32 {
        (funct7 << 25) | (rs2 << 20) | (rs1 << 15) | (funct3 << 12) | (rd << 7) | opcode
    }

    fn encode_s(imm: i32, rs2: u32, rs1: u32, funct3: u32, opcode: u32) -> u32 {
        let imm = imm as u32;
        let imm11_5 = (imm >> 5) & 0x7F;
        let imm4_0 = imm & 0x1F;
        (imm11_5 << 25)
            | (rs2 << 20)
            | (rs1 << 15)
            | (funct3 << 12)
            | (imm4_0 << 7)
            | opcode
    }

    fn encode_b(imm: i32, rs2: u32, rs1: u32, funct3: u32, opcode: u32) -> u32 {
        // imm is a signed byte offset, must be multiple of 2
        let imm = imm as u32;
        let imm12 = (imm >> 12) & 0x1;
        let imm10_5 = (imm >> 5) & 0x3F;
        let imm4_1 = (imm >> 1) & 0xF;
        let imm11 = (imm >> 11) & 0x1;

        (imm12 << 31)
            | (imm10_5 << 25)
            | (rs2 << 20)
            | (rs1 << 15)
            | (funct3 << 12)
            | (imm4_1 << 8)
            | (imm11 << 7)
            | opcode
    }

    fn make_bus() -> SystemBus {
        SystemBus::new(0x8000_0000, 1024 * 1024) // 1MB
    }

    fn encode_amo(
        funct5: u32,
        aq: bool,
        rl: bool,
        rs2: u32,
        rs1: u32,
        funct3: u32,
        rd: u32,
    ) -> u32 {
        let funct7 = (funct5 << 2) | ((aq as u32) << 1) | (rl as u32);
        encode_r(funct7, rs2, rs1, funct3, rd, 0x2F)
    }

    #[test]
    fn test_addi() {
        let bus = make_bus();
        let mut cpu = Cpu::new(0x8000_0000, 0);

        // ADDI x1, x0, -1
        let insn = encode_i(-1, 0, 0, 1, 0x13);
        bus.write32(0x8000_0000, insn).unwrap();

        cpu.step(&bus).unwrap();
        assert_eq!(cpu.read_reg(Register::X1), 0xFFFF_FFFF_FFFF_FFFF);
        assert_eq!(cpu.pc, 0x8000_0004);
    }

    #[test]
    fn test_lui() {
        let bus = make_bus();
        let mut cpu = Cpu::new(0x8000_0000, 0);

        // LUI x2, 0x12345
        // imm field is already << 12 in the encoding helper
        let imm = 0x12345 << 12;
        let insn = ((imm as u32) & 0xFFFFF000) | (2 << 7) | 0x37;
        bus.write32(0x8000_0000, insn).unwrap();

        cpu.step(&bus).unwrap();
        assert_eq!(cpu.read_reg(Register::X2), 0x0000_0000_1234_5000);
    }

    #[test]
    fn test_load_store() {
        let bus = make_bus();
        let mut cpu = Cpu::new(0x8000_0000, 0);

        // SD x1, 0(x2) -> Store x1 at x2+0
        // x1 = 0xDEADBEEF, x2 = 0x8000_0100
        cpu.write_reg(Register::X1, 0xDEADBEEF);
        cpu.write_reg(Register::X2, 0x8000_0100);

        // SD: Op=0x23, funct3=3, rs1=2, rs2=1, imm=0
        // Using manual encoding here: imm=0 so only rs2/rs1/funct3/opcode matter.
        let sd_insn = (1 << 20) | (2 << 15) | (3 << 12) | 0x23;
        bus.write32(0x8000_0000, sd_insn).unwrap();

        cpu.step(&bus).unwrap();
        assert_eq!(bus.read64(0x8000_0100).unwrap(), 0xDEADBEEF);

        // LD x3, 0(x2) -> Load x3 from x2+0
        // LD: Op=0x03, funct3=3, rd=3, rs1=2, imm=0
        let ld_insn = (2 << 15) | (3 << 12) | (3 << 7) | 0x03;
        bus.write32(0x8000_0004, ld_insn).unwrap();

        cpu.step(&bus).unwrap(); // Execute SD (pc was incremented in previous step? No wait)
                                     // Previous step PC went 0->4. Now at 4.

        assert_eq!(cpu.read_reg(Register::X3), 0xDEADBEEF);
    }

    #[test]
    fn test_x0_invariant() {
        let bus = make_bus();
        let mut cpu = Cpu::new(0x8000_0000, 0);

        // Place a value in memory
        let addr = 0x8000_0100;
        bus.write64(addr, 0xDEAD_BEEF_DEAD_BEEF).unwrap();

        // Set x2 = addr
        cpu.write_reg(Register::X2, addr);

        // 1) ADDI x0, x0, 5
        let addi_x0 = encode_i(5, 0, 0, 0, 0x13);
        // 2) LD x0, 0(x2)
        let ld_x0 = encode_i(0, 2, 3, 0, 0x03);

        bus.write32(0x8000_0000, addi_x0).unwrap();
        bus.write32(0x8000_0004, ld_x0).unwrap();

        cpu.step(&bus).unwrap();
        cpu.step(&bus).unwrap();

        // x0 must remain hard-wired to zero
        assert_eq!(cpu.read_reg(Register::X0), 0);
    }

    #[test]
    fn test_branch_taken_and_not_taken() {
        let bus = make_bus();
        let mut cpu = Cpu::new(0x8000_0000, 0);

        // BEQ x1, x2, +8 (pc + 8 when taken)
        let beq_insn = encode_b(8, 2, 1, 0x0, 0x63);
        bus.write32(0x8000_0000, beq_insn).unwrap();

        // Taken: x1 == x2
        cpu.write_reg(Register::X1, 5);
        cpu.write_reg(Register::X2, 5);
        cpu.pc = 0x8000_0000;
        cpu.step(&bus).unwrap();
        assert_eq!(cpu.pc, 0x8000_0008);

        // Not taken: x1 != x2
        cpu.write_reg(Register::X1, 1);
        cpu.write_reg(Register::X2, 2);
        cpu.pc = 0x8000_0000;
        cpu.step(&bus).unwrap();
        assert_eq!(cpu.pc, 0x8000_0004);
    }

    #[test]
    fn test_w_ops_sign_extension() {
        let bus = make_bus();
        let mut cpu = Cpu::new(0x8000_0000, 0);

        // Set x1 = 0x0000_0000_8000_0000 (low 32 bits have sign bit set)
        cpu.write_reg(Register::X1, 0x0000_0000_8000_0000);
        cpu.write_reg(Register::X2, 0); // x2 = 0

        // ADDW x3, x1, x2  (opcode=0x3B, funct3=0, funct7=0)
        let addw = encode_r(0x00, 2, 1, 0x0, 3, 0x3B);
        bus.write32(0x8000_0000, addw).unwrap();

        cpu.step(&bus).unwrap();

        // Expect sign-extended 32-bit result: 0xFFFF_FFFF_8000_0000
        assert_eq!(cpu.read_reg(Register::X3), 0xFFFF_FFFF_8000_0000);
    }

    #[test]
    fn test_m_extension_mul_div_rem() {
        let bus = make_bus();
        let mut cpu = Cpu::new(0x8000_0000, 0);

        // MUL: 3 * 4 = 12
        cpu.write_reg(Register::X1, 3);
        cpu.write_reg(Register::X2, 4);
        let mul = encode_r(0x01, 2, 1, 0x0, 3, 0x33); // MUL x3, x1, x2
        bus.write32(0x8000_0000, mul).unwrap();
        cpu.step(&bus).unwrap();
        assert_eq!(cpu.read_reg(Register::X3), 12);

        // MULH / MULHSU / MULHU basic sanity using large values
        cpu.pc = 0x8000_0004;
        cpu.write_reg(Register::X1, 0x8000_0000_0000_0000);
        cpu.write_reg(Register::X2, 2);
        let mulh = encode_r(0x01, 2, 1, 0x1, 4, 0x33); // MULH x4, x1, x2
        let mulhsu = encode_r(0x01, 2, 1, 0x2, 5, 0x33); // MULHSU x5, x1, x2
        let mulhu = encode_r(0x01, 2, 1, 0x3, 6, 0x33); // MULHU x6, x1, x2
        bus.write32(0x8000_0004, mulh).unwrap();
        bus.write32(0x8000_0008, mulhsu).unwrap();
        bus.write32(0x8000_000C, mulhu).unwrap();
        cpu.step(&bus).unwrap();
        cpu.step(&bus).unwrap();
        cpu.step(&bus).unwrap();

        // From spec example: low product is 0, high signed part negative
        assert_eq!(cpu.read_reg(Register::X3), 12);
        assert_ne!(cpu.read_reg(Register::X4), 0);
        assert_ne!(cpu.read_reg(Register::X5), 0);
        assert_ne!(cpu.read_reg(Register::X6), 0);

        // DIV / DIVU / REM / REMU corner cases
        cpu.pc = 0x8000_0010;
        cpu.write_reg(Register::X1, u64::MAX); // -1 as signed
        cpu.write_reg(Register::X2, 0);
        let div = encode_r(0x01, 2, 1, 0x4, 7, 0x33); // DIV x7, x1, x2
        let divu = encode_r(0x01, 2, 1, 0x5, 8, 0x33); // DIVU x8, x1, x2
        let rem = encode_r(0x01, 2, 1, 0x6, 9, 0x33); // REM x9, x1, x2
        let remu = encode_r(0x01, 2, 1, 0x7, 10, 0x33); // REMU x10, x1, x2
        bus.write32(0x8000_0010, div).unwrap();
        bus.write32(0x8000_0014, divu).unwrap();
        bus.write32(0x8000_0018, rem).unwrap();
        bus.write32(0x8000_001C, remu).unwrap();

        for _ in 0..4 {
            cpu.step(&bus).unwrap();
        }

        assert_eq!(cpu.read_reg(Register::X7), u64::MAX); // DIV by 0 -> -1
        assert_eq!(cpu.read_reg(Register::X8), u64::MAX); // DIVU by 0 -> all ones
        assert_eq!(cpu.read_reg(Register::X9), u64::MAX); // REM by 0 -> rs1
        assert_eq!(cpu.read_reg(Register::X10), u64::MAX); // REMU by 0 -> rs1

        // Overflow case: -(2^63) / -1 -> -(2^63), rem = 0
        cpu.pc = 0x8000_0020;
        cpu.write_reg(Register::X1, i64::MIN as u64);
        cpu.write_reg(Register::X2, (!0u64) as u64); // -1
        let div_over = encode_r(0x01, 2, 1, 0x4, 11, 0x33); // DIV x11, x1, x2
        let rem_over = encode_r(0x01, 2, 1, 0x6, 12, 0x33); // REM x12, x1, x2
        bus.write32(0x8000_0020, div_over).unwrap();
        bus.write32(0x8000_0024, rem_over).unwrap();
        cpu.step(&bus).unwrap();
        cpu.step(&bus).unwrap();

        assert_eq!(cpu.read_reg(Register::X11), i64::MIN as u64);
        assert_eq!(cpu.read_reg(Register::X12), 0);
    }

    #[test]
    fn test_compressed_addi_and_lwsp_paths() {
        let bus = make_bus();
        let mut cpu = Cpu::new(0x8000_0000, 0);

        // Encodings from assembler with rv64imac (see rvc_test.S in dev notes):
        let c_addi_x11_1: u16 = 0x0585; // addi x11,x11,1 (C.ADDI)
        let c_addi16sp_16: u16 = 0x0141; // addi sp,sp,16 (C.ADDI16SP)
        let c_lwsp_a5_12: u16 = 0x47B2; // lw a5,12(sp) (C.LWSP)

        // Initialize registers / memory
        cpu.write_reg(Register::X11, 10);
        let sp_base = 0x8000_0100;
        cpu.write_reg(Register::X2, sp_base); // sp
        // After C.ADDI16SP 16, sp = sp_base + 16. C.LWSP uses offset 12 from new sp.
        bus.write32(sp_base + 16 + 12, 0xDEAD_BEEF).unwrap();

        // Place compressed instructions at 0,2,4
        bus.write16(0x8000_0000, c_addi_x11_1).unwrap();
        bus.write16(0x8000_0002, c_addi16sp_16).unwrap();
        bus.write16(0x8000_0004, c_lwsp_a5_12).unwrap();

        // Execute three steps; PC should advance by 2 for each compressed inst.
        cpu.step(&bus).unwrap();
        assert_eq!(cpu.pc, 0x8000_0002);
        assert_eq!(cpu.read_reg(Register::X11), 11);

        cpu.step(&bus).unwrap();
        assert_eq!(cpu.pc, 0x8000_0004);
        assert_eq!(cpu.read_reg(Register::X2), 0x8000_0110); // sp + 16

        cpu.step(&bus).unwrap();
        assert_eq!(cpu.pc, 0x8000_0006);
        assert_eq!(cpu.read_reg(Register::X15), 0xFFFF_FFFF_DEAD_BEEF); // a5 (sign-extended lw)
    }

    #[test]
    fn test_zicsr_basic_csrs() {
        let bus = make_bus();
        let mut cpu = Cpu::new(0x8000_0000, 0);
        let csr_addr: u32 = 0x300; // mstatus

        // CSRRWI x1, mstatus, 5  (mstatus = 5, x1 = old = 0)
        let csrrwi = {
            let zimm = 5u32;
            (csr_addr << 20) | (zimm << 15) | (0x5 << 12) | (1 << 7) | 0x73
        };
        bus.write32(0x8000_0000, csrrwi).unwrap();
        cpu.step(&bus).unwrap();
        assert_eq!(cpu.read_reg(Register::X1), 0);

        // CSRRSI x2, mstatus, 0xA  (mstatus = 5 | 0xA = 0xF, x2 = old = 5)
        let csrrsi = {
            let zimm = 0xAu32;
            (csr_addr << 20) | (zimm << 15) | (0x6 << 12) | (2 << 7) | 0x73
        };
        bus.write32(0x8000_0004, csrrsi).unwrap();
        cpu.step(&bus).unwrap();
        assert_eq!(cpu.read_reg(Register::X2), 5);

        // CSRRCI x3, mstatus, 0x3  (mstatus = 0xF & !0x3 = 0xC, x3 = old = 0xF)
        let csrrci = {
            let zimm = 0x3u32;
            (csr_addr << 20) | (zimm << 15) | (0x7 << 12) | (3 << 7) | 0x73
        };
        bus.write32(0x8000_0008, csrrci).unwrap();
        cpu.step(&bus).unwrap();
        assert_eq!(cpu.read_reg(Register::X3), 0xF);
    }

    #[test]
    fn test_a_extension_lr_sc_basic() {
        let bus = make_bus();
        let mut cpu = Cpu::new(0x8000_0000, 0);

        let addr = 0x8000_0200;
        bus.write64(addr, 0xDEAD_BEEF_DEAD_BEEF).unwrap();

        cpu.write_reg(Register::X1, addr); // base
        cpu.write_reg(Register::X2, 0x0123_4567_89AB_CDEF); // value to store with SC

        // LR.D x3, 0(x1)
        let lr_d = encode_amo(0b00010, false, false, 0, 1, 0x3, 3);
        // SC.D x4, x2, 0(x1)
        let sc_d = encode_amo(0b00011, false, false, 2, 1, 0x3, 4);

        bus.write32(0x8000_0000, lr_d).unwrap();
        bus.write32(0x8000_0004, sc_d).unwrap();

        cpu.step(&bus).unwrap();
        assert_eq!(cpu.read_reg(Register::X3), 0xDEAD_BEEF_DEAD_BEEF);

        cpu.step(&bus).unwrap();
        assert_eq!(cpu.read_reg(Register::X4), 0); // SC success
        assert_eq!(bus.read64(addr).unwrap(), 0x0123_4567_89AB_CDEF);
    }

    #[test]
    fn test_a_extension_reservation_and_misaligned_sc() {
        let bus = make_bus();
        let mut cpu = Cpu::new(0x8000_0000, 0);

        let addr = 0x8000_0300;
        bus.write64(addr, 0xCAFEBABE_F00D_F00D).unwrap();

        cpu.write_reg(Register::X1, addr); // base
        cpu.write_reg(Register::X2, 1); // increment

        // LR.D to establish reservation
        let lr_d = encode_amo(0b00010, false, false, 0, 1, 0x3, 3);
        // AMOADD.D x4, x2, 0(x1) -> increments and clears reservation
        let amoadd_d = encode_amo(0b00000, false, false, 2, 1, 0x3, 4);
        // SC.D x5, x2, 0(x1) -> should fail (x5=1) because reservation cleared
        let sc_d = encode_amo(0b00011, false, false, 2, 1, 0x3, 5);

        bus.write32(0x8000_0000, lr_d).unwrap();
        bus.write32(0x8000_0004, amoadd_d).unwrap();
        bus.write32(0x8000_0008, sc_d).unwrap();

        cpu.step(&bus).unwrap(); // LR
        cpu.step(&bus).unwrap(); // AMOADD
        cpu.step(&bus).unwrap(); // SC (should fail)

        assert_eq!(cpu.read_reg(Register::X5), 1);

        // Misaligned SC.D must trap with StoreAddressMisaligned
        cpu.pc = 0x8000_0010;
        cpu.write_reg(Register::X1, addr + 1); // misaligned
        let sc_misaligned = encode_amo(0b00011, false, false, 2, 1, 0x3, 6);
        bus.write32(0x8000_0010, sc_misaligned).unwrap();

        let res = cpu.step(&bus);
        match res {
            Err(Trap::StoreAddressMisaligned(a)) => assert_eq!(a, addr + 1),
            _ => panic!("Expected StoreAddressMisaligned trap"),
        }
    }

    #[test]
    fn test_load_sign_and_zero_extension() {
        let bus = make_bus();
        let mut cpu = Cpu::new(0x8000_0000, 0);

        let addr = 0x8000_0100;
        // 0xFFEE_DDCC_BBAA_9988 laid out little-endian in memory
        bus.write64(addr, 0xFFEE_DDCC_BBAA_9988).unwrap();

        cpu.write_reg(Register::X1, addr); // base pointer

        // LB x2, 0(x1)
        let lb = encode_i(0, 1, 0, 2, 0x03);
        // LBU x3, 0(x1)
        let lbu = encode_i(0, 1, 4, 3, 0x03);
        // LH x4, 0(x1)
        let lh = encode_i(0, 1, 1, 4, 0x03);
        // LHU x5, 0(x1)
        let lhu = encode_i(0, 1, 5, 5, 0x03);
        // LW x6, 0(x1)
        let lw = encode_i(0, 1, 2, 6, 0x03);
        // LWU x7, 0(x1)
        let lwu = encode_i(0, 1, 6, 7, 0x03);
        // LD x8, 0(x1)
        let ld = encode_i(0, 1, 3, 8, 0x03);

        let base_pc = 0x8000_0000;
        for (i, insn) in [lb, lbu, lh, lhu, lw, lwu, ld].into_iter().enumerate() {
            bus.write32(base_pc + (i as u64) * 4, insn).unwrap();
        }

        // Execute all loads
        for _ in 0..7 {
            cpu.step(&bus).unwrap();
        }

        assert_eq!(cpu.read_reg(Register::X2), 0xFFFF_FFFF_FFFF_FF88); // LB (sign-extended 0x88)
        assert_eq!(cpu.read_reg(Register::X3), 0x88); // LBU
        assert_eq!(cpu.read_reg(Register::X4), 0xFFFF_FFFF_FFFF_9988); // LH
        assert_eq!(cpu.read_reg(Register::X5), 0x9988); // LHU
        assert_eq!(cpu.read_reg(Register::X6), 0xFFFF_FFFF_BBAA_9988); // LW
        assert_eq!(cpu.read_reg(Register::X7), 0xBBAA_9988); // LWU
        assert_eq!(cpu.read_reg(Register::X8), 0xFFEE_DDCC_BBAA_9988); // LD
    }

    #[test]
    fn test_misaligned_load_and_store_traps() {
        let bus = make_bus();
        let mut cpu = Cpu::new(0x8000_0000, 0);

        // x2 = misaligned address
        cpu.write_reg(Register::X2, 0x8000_0001);

        // LW x1, 0(x2)  -> should trap with LoadAddressMisaligned
        let lw = encode_i(0, 2, 2, 1, 0x03);
        bus.write32(0x8000_0000, lw).unwrap();

        let res = cpu.step(&bus);
        match res {
            Err(Trap::LoadAddressMisaligned(a)) => assert_eq!(a, 0x8000_0001),
            _ => panic!("Expected LoadAddressMisaligned trap"),
        }

        // SW x1, 0(x2)  -> should trap with StoreAddressMisaligned
        cpu.pc = 0x8000_0000;
        let sw = encode_s(0, 1, 2, 2, 0x23);
        bus.write32(0x8000_0000, sw).unwrap();

        let res = cpu.step(&bus);
        match res {
            Err(Trap::StoreAddressMisaligned(a)) => assert_eq!(a, 0x8000_0001),
            _ => panic!("Expected StoreAddressMisaligned trap"),
        }
    }

    #[test]
    fn test_access_fault_outside_dram() {
        let bus = make_bus();
        let mut cpu = Cpu::new(0x8000_0000, 0);

        // LW x1, 0(x0) -> effective address 0x0 (outside DRAM, but aligned)
        let lw = encode_i(0, 0, 2, 1, 0x03);
        bus.write32(0x8000_0000, lw).unwrap();

        let res = cpu.step(&bus);
        match res {
            Err(Trap::LoadAccessFault(a)) => assert_eq!(a, 0),
            _ => panic!("Expected LoadAccessFault trap"),
        }
    }

    #[test]
    fn test_jal() {
        let bus = make_bus();
        let mut cpu = Cpu::new(0x8000_0000, 0);

        // JAL x1, 8
        // Op=0x6F, rd=1, imm=8.
        // J-type: imm[20|10:1|11|19:12]
        // imm=8 (0x8). bit3=1.
        // imm[10:1] = 0100... no wait.
        // 8 = 1000 binary.
        // bit1..10 -> bits 1..4 are 0010 ? No.
        // 8 >> 1 = 4.
        // imm[10:1] = 4.
        // insn: imm[20] | imm[10:1] | imm[11] | imm[19:12] | rd | opcode
        // 0 | 4 | 0 | 0 | 1 | 0x6F
        // (4 << 21) | (1 << 7) | 0x6F
        let jal_insn = (4 << 21) | (1 << 7) | 0x6F;
        bus.write32(0x8000_0000, jal_insn).unwrap();

        cpu.step(&bus).unwrap();
        assert_eq!(cpu.read_reg(Register::X1), 0x8000_0004); // Link address
        assert_eq!(cpu.pc, 0x8000_0008); // Target
    }

    #[test]
    fn test_misaligned_fetch() {
        let bus = make_bus();
        let mut cpu = Cpu::new(0x8000_0001, 0); // Odd PC

        let res = cpu.step(&bus);
        match res {
            Err(Trap::InstructionAddressMisaligned(addr)) => assert_eq!(addr, 0x8000_0001),
            _ => panic!("Expected misaligned trap"),
        }
    }

    #[test]
    fn test_smoke_sum() {
        let bus = make_bus();
        let mut cpu = Cpu::new(0x8000_0000, 0);

        // Data at 0x8000_0100
        let data: [u32; 5] = [1, 2, 3, 4, 5];
        for (i, val) in data.iter().enumerate() {
            bus.write32(0x8000_0100 + (i * 4) as u64, *val).unwrap();
        }

        // Program
        // Need to construct 0x80000100 without sign extension issues.
        // 1. ADDI x1, x0, 1
        // 2. SLLI x1, x1, 31 -> 0x80000000
        // 3. ADDI x1, x1, 0x100 -> 0x80000100
        let prog = [
            0x00100093, // addi x1, x0, 1
            0x01F09093, // slli x1, x1, 31
            0x10008093, // addi x1, x1, 0x100 -> Base
            0x00500113, // addi x2, x0, 5 -> Count
            0x00000193, // addi x3, x0, 0 -> Sum
            // loop:
            0x0000A203, // lw x4, 0(x1)
            0x004181B3, // add x3, x3, x4
            0x00408093, // addi x1, x1, 4
            0xFFF10113, // addi x2, x2, -1
            0xFE0118E3, // bne x2, x0, loop (-16)
            0x00100073, // ebreak
        ];

        for (i, val) in prog.iter().enumerate() {
            bus.write32(0x8000_0000 + (i * 4) as u64, *val).unwrap();
        }

        // Run until ebreak
        let mut steps = 0;
        loop {
            steps += 1;
            if steps > 1000 {
                panic!("Infinite loop");
            }
            match cpu.step(&bus) {
                Ok(_) => {}
                Err(Trap::Breakpoint) => break,
                Err(e) => panic!("Unexpected trap at pc 0x{:x}: {:?}", cpu.pc, e),
            }
        }

        // Check sum
        assert_eq!(cpu.read_reg(Register::X3), 15);
    }

    #[test]
    fn test_interrupts_clint_plic() {
        let bus = make_bus();
        let mut cpu = Cpu::new(0x8000_0000, 0);
        // Set poll_counter to 255 so the first step triggers immediate interrupt check
        cpu.poll_counter = 255;

        // 1. Setup MTVEC to 0x8000_1000 (Direct)
        let mtvec_val = 0x8000_1000;
        cpu.write_csr(CSR_MTVEC, mtvec_val).unwrap();

        // 2. Enable MIE in mstatus (Global Interrupt Enable)
        // mstatus bit 3 is MIE.
        let mstatus_val = 1 << 3; 
        cpu.write_csr(CSR_MSTATUS, mstatus_val).unwrap();

        // 3. Enable MTIE (Timer) and MEIE (External) and MSIE (Software) in mie
        // MTIE=7, MEIE=11, MSIE=3
        let mie_val = (1 << 7) | (1 << 11) | (1 << 3);
        cpu.write_csr(CSR_MIE, mie_val).unwrap();

        // --- Test CLINT Timer Interrupt ---
        // Set mtimecmp[0] to 100
        bus.clint.set_mtimecmp(0, 100);
        // Set mtime to 101 (trigger condition)
        bus.clint.set_mtime(101);

        // We need a valid instruction at PC to attempt fetch, although interrupt checks before fetch.
        bus.write32(0x8000_0000, 0x00000013).unwrap(); // NOP (addi x0, x0, 0)

        let res = cpu.step(&bus);
        match res {
             Err(Trap::MachineTimerInterrupt) => {
                 // Success
                 assert_eq!(cpu.pc, 0x8000_1000); // jumped to mtvec
                 // Check mcause: Interrupt=1, Cause=7 -> 0x8000...0007
                 let mcause = cpu.read_csr(CSR_MCAUSE).unwrap();
                 assert_eq!(mcause, 0x8000_0000_0000_0007);
             }
             _ => panic!("Expected MachineTimerInterrupt, got {:?}", res),
        }

        // Clear the interrupt condition
        bus.clint.set_mtimecmp(0, 200); 
        // CPU is now at handler. We need to "return" (mret) or just reset state for next test.
        // Reset PC back to start
        cpu.pc = 0x8000_0000;
        // Re-enable MIE (trap disabled it)
        let mut mstatus = cpu.read_csr(CSR_MSTATUS).unwrap();
        mstatus |= 1 << 3;
        cpu.write_csr(CSR_MSTATUS, mstatus).unwrap();
        // Set poll_counter to 255 for immediate interrupt check on next step
        cpu.poll_counter = 255;

        // --- Test PLIC UART Interrupt ---
        // Configure PLIC
        // 1. Set Priority for Source 10 (UART) to 1
        bus.plic.store(0x000000 + 4 * 10, 4, 1).unwrap();
        // 2. Enable Source 10 for Context 0 (M-mode)
        // Enable addr for ctx 0: 0x002000. Bit 10.
        bus.plic.store(0x002000, 4, 1 << 10).unwrap();
        // 3. Set Threshold for Context 0 to 0
        bus.plic.store(0x200000, 4, 0).unwrap();

        // Trigger UART Interrupt
        // Writing to IER (Enable RDIE=1) and pushing a char to Input
        // UART RBR is at offset 0. IER is at offset 1.
        bus.uart.store(1, 1, 1).unwrap(); // IER = 1 (RX Data Available Interrupt)
        bus.uart.push_input(b'A'); 
        // This should set uart.lsr[0]=1, and because IER[0]=1, uart.interrupting=true.
        
        // Update bus interrupts so PLIC sees UART line high
        bus.check_interrupts();

        // Step CPU
        let res = cpu.step(&bus);
        match res {
            Err(Trap::MachineExternalInterrupt) => {
                // Success
                assert_eq!(cpu.pc, 0x8000_1000);
                 let mcause = cpu.read_csr(CSR_MCAUSE).unwrap();
                 assert_eq!(mcause, 0x8000_0000_0000_000B); // Cause 11
            }
            _ => panic!("Expected MachineExternalInterrupt, got {:?}", res),
        }
    }
}
</file>

<file path="riscv-vm/src/main.rs">
use clap::Parser;
use std::fs;
use std::io::Write;
use std::path::PathBuf;

use riscv_vm::emulator::NativeVm;

#[derive(Parser, Debug)]
#[command(name = "riscv-vm")]
#[command(about = "RISC-V emulator with SMP support")]
#[command(version)]
struct Args {
    /// Path to kernel ELF or binary
    #[arg(short, long)]
    kernel: PathBuf,

    /// Path to disk image (optional)
    #[arg(short, long)]
    disk: Option<PathBuf>,

    /// Number of harts (CPUs), 0 for auto-detect
    #[arg(short = 'n', long, default_value = "0")]
    harts: usize,

    /// WebTransport relay URL for networking (e.g., https://127.0.0.1:4433)
    #[arg(long)]
    net_webtransport: Option<String>,

    /// Certificate hash for WebTransport (for self-signed certs)
    #[arg(long)]
    cert_hash: Option<String>,

    /// Enable debug output
    #[arg(long)]
    debug: bool,
}

/// Write to stdout with \r\n line endings (for raw terminal mode)
fn uart_print(s: &str) {
    let stdout = std::io::stdout();
    let mut out = stdout.lock();
    for byte in s.bytes() {
        if byte == b'\n' {
            let _ = out.write_all(b"\r\n");
        } else {
            let _ = out.write_all(&[byte]);
        }
    }
    let _ = out.flush();
}

/// Write formatted output to stdout with \r\n, adding a newline at the end
macro_rules! uart_println {
    () => { uart_print("\n") };
    ($($arg:tt)*) => {{
        uart_print(&format!($($arg)*));
        uart_print("\n");
    }};
}

fn main() -> Result<(), Box<dyn std::error::Error>> {
    let args = Args::parse();

    // Initialize logging
    if args.debug {
        env_logger::Builder::from_env(
            env_logger::Env::default().default_filter_or("debug")
        ).init();
    } else {
        env_logger::Builder::from_env(
            env_logger::Env::default().default_filter_or("info")
        ).init();
    }

    // Load kernel
    let kernel_data = fs::read(&args.kernel)
        .map_err(|e| format!("Failed to read kernel '{}': {}", args.kernel.display(), e))?;

    // Determine hart count - use half available cores or user-specified count
    let num_harts = if args.harts == 0 {
        let cpus = std::thread::available_parallelism()
            .map(|n| n.get())
            .unwrap_or(2);
        (cpus / 2).max(1) // Use half the CPUs, ensure at least 1
    } else {
        args.harts
    }.max(1); // Ensure at least 1

    // Print banner
    uart_println!();
    uart_println!("╔══════════════════════════════════════════════════════════════╗");
    uart_println!("║              RISC-V Emulator (SMP Edition)                   ║");
    uart_println!("╠══════════════════════════════════════════════════════════════╣");
    uart_println!("║  Kernel: {:50} ║", 
             args.kernel.file_name().unwrap_or_default().to_string_lossy());
    uart_println!("║  Harts:  {:50} ║", num_harts);
    if let Some(relay) = &args.net_webtransport {
        uart_println!("║  Network: {:49} ║", relay);
    }
    uart_println!("╚══════════════════════════════════════════════════════════════╝");
    uart_println!();

    // Create VM
    let mut vm = NativeVm::new(&kernel_data, num_harts)?;

    // Load disk if specified
    if let Some(disk_path) = &args.disk {
        let disk_data = fs::read(disk_path)
            .map_err(|e| format!("Failed to read disk '{}': {}", disk_path.display(), e))?;
        vm.load_disk(disk_data);
        uart_println!("[VM] Loaded disk: {}", disk_path.display());
    }

    // Connect to WebTransport relay if specified
    if let Some(relay_url) = &args.net_webtransport {
        vm.connect_webtransport(relay_url, args.cert_hash.clone());
    }

    // Run VM
    vm.run();

    // Report exit status
    let halt_code = vm.shared.halt_code();
    if halt_code == 0x5555 {
        uart_println!();
        uart_println!("[VM] Clean shutdown (PASS)");
        Ok(())
    } else {
        uart_println!();
        uart_println!("[VM] Shutdown with code: {:#x}", halt_code);
        Ok(())
    }
}
</file>

<file path="kernel/src/scripting.rs">
// kernel/src/scripting.rs
//! JavaScript-like scripting runtime with ES6 module system
//!
//! Scripts use `import * from` to import OS modules:
//!   import * from "os:fs"
//!   import * from "os:net"
//!   import * from "os:sys"
//!   import * from "os:mem"
//!
//! Performance optimizations:
//!   - Global cached runtime (created once, reused)
//!   - Compiled AST caching for frequently used scripts
//!   - Optimized import preprocessor

use alloc::string::{String, ToString};
use alloc::vec::Vec;
use alloc::collections::BTreeMap;
use alloc::format;
use rhai::{Engine, Scope, Dynamic, Array, Map, ImmutableString, AST, packages::{Package, StandardPackage}};
use crate::Spinlock;

// ═══════════════════════════════════════════════════════════════════════════════
// MODULE TYPES - For namespace imports (import * as X from "...")
// ═══════════════════════════════════════════════════════════════════════════════

/// Filesystem module object - os:fs
#[derive(Clone)]
pub struct FsModule;

/// Network module object - os:net
#[derive(Clone)]
pub struct NetModule;

/// System module object - os:sys
#[derive(Clone)]
pub struct SysModule;

/// Memory module object - os:mem
#[derive(Clone)]
pub struct MemModule;

/// HTTP module object - os:http
#[derive(Clone)]
pub struct HttpModule;


// ═══════════════════════════════════════════════════════════════════════════════
// LOGGING
// ═══════════════════════════════════════════════════════════════════════════════

#[derive(Clone, Copy, PartialEq, Eq)]
pub enum LogLevel {
    Off,
    Error,
    Warn,
    Info,
    Debug,
    Trace,
}

impl LogLevel {
    fn as_str(&self) -> &'static str {
        match self {
            LogLevel::Off => "OFF",
            LogLevel::Error => "ERROR",
            LogLevel::Warn => "WARN",
            LogLevel::Info => "INFO",
            LogLevel::Debug => "DEBUG",
            LogLevel::Trace => "TRACE",
        }
    }
}

/// Script log level, protected by spinlock.
static SCRIPT_LOG_LEVEL: Spinlock<LogLevel> = Spinlock::new(LogLevel::Info);

pub fn set_log_level(level: LogLevel) {
    *SCRIPT_LOG_LEVEL.lock() = level;
}

pub fn get_log_level() -> LogLevel {
    *SCRIPT_LOG_LEVEL.lock()
}

fn log(level: LogLevel, msg: &str) {
    let current_level = *SCRIPT_LOG_LEVEL.lock();
    if (level as u8) <= (current_level as u8) {
        let color = match level {
            LogLevel::Error => "\x1b[1;31m",
            LogLevel::Warn => "\x1b[1;33m",
            LogLevel::Info => "\x1b[1;34m",
            LogLevel::Debug => "\x1b[0;36m",
            LogLevel::Trace => "\x1b[0;90m",
            LogLevel::Off => "",
        };
        crate::uart::write_str(color);
        crate::uart::write_str("[SCRIPT:");
        crate::uart::write_str(level.as_str());
        crate::uart::write_str("]\x1b[0m ");
        crate::uart::write_line(msg);
    }
}

macro_rules! log_error {
    ($($arg:tt)*) => { log(LogLevel::Error, &format!($($arg)*)); };
}

macro_rules! log_debug {
    ($($arg:tt)*) => { log(LogLevel::Debug, &format!($($arg)*)); };
}

macro_rules! log_trace {
    ($($arg:tt)*) => { log(LogLevel::Trace, &format!($($arg)*)); };
}

// ═══════════════════════════════════════════════════════════════════════════════
// OUTPUT BUFFER
// ═══════════════════════════════════════════════════════════════════════════════

/// Script output buffer, protected by spinlock.
static SCRIPT_OUTPUT: Spinlock<Option<Vec<u8>>> = Spinlock::new(None);

fn init_output() {
    *SCRIPT_OUTPUT.lock() = Some(Vec::with_capacity(8192));
}

fn take_output() -> Vec<u8> {
    SCRIPT_OUTPUT.lock().take().unwrap_or_default()
}

fn append_output(s: &str) {
    let mut guard = SCRIPT_OUTPUT.lock();
    if let Some(ref mut buf) = *guard {
        buf.extend_from_slice(s.as_bytes());
    }
}

// ═══════════════════════════════════════════════════════════════════════════════
// GLOBAL RUNTIME CACHE
// ═══════════════════════════════════════════════════════════════════════════════

// Note: ScriptRuntime contains Rhai Engine which uses Rc internally and is not Send.
// This is acceptable because scripts only run on the primary hart (shell).
// Access is serialized by the shell command loop.
static mut CACHED_RUNTIME: Option<ScriptRuntime> = None;

/// Get or create the global cached runtime (much faster than creating new each time)
fn get_runtime() -> &'static ScriptRuntime {
    unsafe {
        if CACHED_RUNTIME.is_none() {
            log_debug!("Creating cached script runtime...");
            CACHED_RUNTIME = Some(ScriptRuntime::new_internal());
        }
        CACHED_RUNTIME.as_ref().unwrap()
    }
}

// ═══════════════════════════════════════════════════════════════════════════════
// AST CACHE - Cache compiled scripts for faster re-execution
// ═══════════════════════════════════════════════════════════════════════════════

const AST_CACHE_MAX_SIZE: usize = 32;

// Note: AST contains Rhai types that use Rc internally and are not Send.
// This is acceptable because scripts only run on the primary hart (shell).
static mut AST_CACHE: Option<BTreeMap<u64, AST>> = None;

fn get_ast_cache() -> &'static mut BTreeMap<u64, AST> {
    unsafe {
        if AST_CACHE.is_none() {
            AST_CACHE = Some(BTreeMap::new());
        }
        AST_CACHE.as_mut().unwrap()
    }
}

/// Simple FNV-1a hash for script content (fast, good distribution)
#[inline]
fn hash_script(script: &str) -> u64 {
    const FNV_OFFSET: u64 = 0xcbf29ce484222325;
    const FNV_PRIME: u64 = 0x100000001b3;
    
    let mut hash = FNV_OFFSET;
    for byte in script.bytes() {
        hash ^= byte as u64;
        hash = hash.wrapping_mul(FNV_PRIME);
    }
    hash
}

/// Try to get cached AST, or compile and cache it
fn get_or_compile_ast(engine: &Engine, script: &str, hash: u64) -> Result<AST, String> {
    let cache = get_ast_cache();
    
    // Check cache first
    if let Some(ast) = cache.get(&hash) {
        log_trace!("AST cache hit for hash {:016x}", hash);
        return Ok(ast.clone());
    }
    
    // Compile new AST
    log_trace!("AST cache miss, compiling script...");
    let ast = engine.compile(script).map_err(|e| format!("Syntax error: {}", e))?;
    
    // Evict oldest entries if cache is full (simple LRU approximation)
    if cache.len() >= AST_CACHE_MAX_SIZE {
        if let Some(&oldest_key) = cache.keys().next() {
            cache.remove(&oldest_key);
        }
    }
    
    // Cache the compiled AST
    cache.insert(hash, ast.clone());
    log_trace!("Cached AST, cache size: {}", cache.len());
    
    Ok(ast)
}

/// Clear the AST cache (useful for debugging or freeing memory)
pub fn clear_ast_cache() {
    unsafe {
        if let Some(ref mut cache) = AST_CACHE {
            cache.clear();
            log_debug!("AST cache cleared");
        }
    }
}

/// Preload all scripts from /usr/bin/ into the AST cache at boot
/// Returns the number of scripts successfully cached
pub fn preload_scripts() -> usize {
    log_debug!("Preloading scripts from /usr/bin/...");
    
    let runtime = get_runtime();
    let mut cached_count = 0;
    
    // Collect scripts with FS lock, then release before compiling
    let scripts_to_cache: Vec<(String, Vec<u8>)> = {
        let fs_guard = crate::FS_STATE.lock();
        let mut blk_guard = crate::BLK_DEV.lock();
        
        let mut scripts = Vec::new();
        if let (Some(fs), Some(dev)) = (fs_guard.as_ref(), blk_guard.as_mut()) {
            // List all files in /usr/bin/
            let files = fs.list_dir(dev, "/usr/bin");
            
            for file_info in files {
                // Skip directories
                if file_info.is_dir {
                    continue;
                }
                
                let path = format!("/usr/bin/{}", file_info.name);
                
                // Read the script content
                if let Some(content) = fs.read_file(dev, &path) {
                    scripts.push((file_info.name.clone(), content));
                }
            }
        }
        scripts
    };
    
    // Now compile and cache scripts (FS lock released)
    for (name, content) in scripts_to_cache {
        if let Ok(script) = core::str::from_utf8(&content) {
            // Preprocess and cache
            let preprocess_result = preprocess_imports(script);
            let processed_script = preprocess_result.as_str(script);
            let script_hash = hash_script(processed_script);
            
            // Try to compile and cache
            match get_or_compile_ast(&runtime.engine, processed_script, script_hash) {
                Ok(_) => {
                    log_trace!("Cached: {}", name);
                    cached_count += 1;
                }
                Err(e) => {
                    log_error!("Failed to cache {}: {}", name, e);
                }
            }
        }
    }
    
    log_debug!("Preloaded {} scripts into AST cache", cached_count);
    cached_count
}

/// Get the current AST cache size
pub fn ast_cache_size() -> usize {
    unsafe {
        AST_CACHE.as_ref().map(|c| c.len()).unwrap_or(0)
    }
}

// ═══════════════════════════════════════════════════════════════════════════════
// ES6 IMPORT PREPROCESSOR
// ═══════════════════════════════════════════════════════════════════════════════

/// Preprocess script to handle ES6 import statements
/// Transforms:
///   import * as fs from "os:fs"     → let fs = __module_fs();
///   import { ls, read_file } from "os:fs"  → (stripped, functions are global)
/// 
/// Optimized: returns original script unchanged if no imports found (zero-copy)
fn preprocess_imports(script: &str) -> PreprocessResult {
    // Fast path: check if script contains any imports at all
    if !script.contains("import ") {
        return PreprocessResult::Unchanged;
    }
    
    let mut output = String::with_capacity(script.len() + 128);
    let mut had_imports = false;
    
    for line in script.lines() {
        let trimmed = line.trim();
        
        // Fast skip: empty lines, comments, or lines not starting with 'i'
        if trimmed.is_empty() || trimmed.starts_with("//") || !trimmed.starts_with("import ") {
            output.push_str(line);
            output.push('\n');
            continue;
        }
        
        // Must be an import line - check for " from "
        if !trimmed.contains(" from ") {
            output.push_str(line);
            output.push('\n');
            continue;
        }
        
        had_imports = true;
        
        // Extract module name (between quotes)
        let module = match extract_module_name_fast(trimmed) {
            Some(m) => m,
            None => {
                output.push_str(line);
                output.push('\n');
                continue;
            }
        };
        
        // Map module name to function name
        let module_fn = match module {
            "os:fs" => "__module_fs",
            "os:net" => "__module_net",
            "os:sys" => "__module_sys",
            "os:mem" => "__module_mem",
            "os:http" => "__module_http",
            _ => {
                output.push_str("// Error: Unknown module\n");
                continue;
            }
        };
        
        // Check for: import * as NAME from "module"
        if let Some(alias) = extract_namespace_alias_fast(trimmed) {
            output.push_str("let ");
            output.push_str(alias);
            output.push_str(" = ");
            output.push_str(module_fn);
            output.push_str("();\n");
            continue;
        }
        
        // Named imports or plain "import * from" - just strip them
        output.push_str("// imported\n");
    }
    
    if had_imports {
        PreprocessResult::Changed(output)
    } else {
        PreprocessResult::Unchanged
    }
}

/// Result of preprocessing - avoids allocation when no changes needed
enum PreprocessResult {
    Unchanged,
    Changed(String),
}

impl PreprocessResult {
    #[inline]
    fn as_str<'a>(&'a self, original: &'a str) -> &'a str {
        match self {
            PreprocessResult::Unchanged => original,
            PreprocessResult::Changed(s) => s.as_str(),
        }
    }
}

/// Extract module name from import statement (between quotes) - returns &str, no allocation
#[inline]
fn extract_module_name_fast(line: &str) -> Option<&str> {
    // Find " from " first, then look for quotes after it
    let from_pos = line.find(" from ")?;
    let after_from = &line[from_pos + 6..];
    
    // Find opening quote
    let start = after_from.find('"').or_else(|| after_from.find('\''))?;
    let rest = &after_from[start + 1..];
    // Find closing quote
    let end = rest.find('"').or_else(|| rest.find('\''))?;
    Some(&rest[..end])
}

/// Extract namespace alias from "import * as NAME from ..." - returns &str, no allocation
#[inline]
fn extract_namespace_alias_fast(line: &str) -> Option<&str> {
    // Find "* as " pattern
    let as_pos = line.find("* as ")?;
    let after_as = &line[as_pos + 5..];
    // Find the alias (word before "from")
    let from_pos = after_as.find(" from")?;
    let alias = after_as[..from_pos].trim();
    if alias.is_empty() {
        None
    } else {
        Some(alias)
    }
}

// ═══════════════════════════════════════════════════════════════════════════════
// SCRIPT RUNTIME
// ═══════════════════════════════════════════════════════════════════════════════

pub struct ScriptRuntime {
    engine: Engine,
}

impl ScriptRuntime {
    // ═══════════════════════════════════════════════════════════════════════
    // os:fs MODULE - Filesystem functions
    // ═══════════════════════════════════════════════════════════════════════
    
    fn register_fs_module(engine: &mut Engine) {
        // ls() -> Array of {name, size, is_dir}
        engine.register_fn("ls", || -> Array {
            let mut list = Array::new();
            let fs_guard = crate::FS_STATE.lock();
            let mut blk_guard = crate::BLK_DEV.lock();
            if let (Some(fs), Some(dev)) = (fs_guard.as_ref(), blk_guard.as_mut()) {
                let files = fs.list_dir(dev, "/");
                for f in files {
                    let mut map = Map::new();
                    map.insert("name".into(), Dynamic::from(f.name));
                    map.insert("size".into(), Dynamic::from(f.size as i64));
                    map.insert("is_dir".into(), Dynamic::from(f.is_dir));
                    list.push(Dynamic::from(map));
                }
            }
            list
        });
        
        // read_file(path) -> String
        engine.register_fn("read_file", |path: ImmutableString| -> ImmutableString {
            let fs_guard = crate::FS_STATE.lock();
            let mut blk_guard = crate::BLK_DEV.lock();
            if let (Some(fs), Some(dev)) = (fs_guard.as_ref(), blk_guard.as_mut()) {
                if let Some(data) = fs.read_file(dev, path.as_str()) {
                    return String::from_utf8_lossy(&data).into_owned().into();
                }
            }
            "".into()
        });
        
        // write_file(path, content) -> bool
        engine.register_fn("write_file", |path: ImmutableString, content: ImmutableString| -> bool {
            let mut fs_guard = crate::FS_STATE.lock();
            let mut blk_guard = crate::BLK_DEV.lock();
            if let (Some(fs), Some(dev)) = (fs_guard.as_mut(), blk_guard.as_mut()) {
                return fs.write_file(dev, path.as_str(), content.as_bytes()).is_ok();
            }
            false
        });
        
        // file_exists(path) -> bool
        engine.register_fn("file_exists", |path: ImmutableString| -> bool {
            let fs_guard = crate::FS_STATE.lock();
            let mut blk_guard = crate::BLK_DEV.lock();
            if let (Some(fs), Some(dev)) = (fs_guard.as_ref(), blk_guard.as_mut()) {
                return fs.read_file(dev, path.as_str()).is_some();
            }
            false
        });
        
        // fs_available() -> bool
        engine.register_fn("fs_available", || -> bool {
            crate::FS_STATE.lock().is_some()
        });
    }
    
    // ═══════════════════════════════════════════════════════════════════════
    // os:net MODULE - Network functions
    // ═══════════════════════════════════════════════════════════════════════
    
    fn register_net_module(engine: &mut Engine) {
        // get_ip() -> String
        engine.register_fn("get_ip", || -> ImmutableString {
            let mut buf = [0u8; 16];
            let ip = crate::net::get_my_ip();
            let len = crate::net::format_ipv4(ip, &mut buf);
            String::from_utf8_lossy(&buf[..len]).into_owned().into()
        });
        
        // get_mac() -> String
        engine.register_fn("get_mac", || -> ImmutableString {
            let net_guard = crate::NET_STATE.lock();
            if let Some(ref state) = *net_guard {
                return String::from_utf8_lossy(&state.mac_str()).into_owned().into();
            }
            "00:00:00:00:00:00".into()
        });
        
        // get_gateway() -> String
        engine.register_fn("get_gateway", || -> ImmutableString {
            let mut buf = [0u8; 16];
            let len = crate::net::format_ipv4(crate::net::GATEWAY, &mut buf);
            String::from_utf8_lossy(&buf[..len]).into_owned().into()
        });
        
        // get_dns() -> String
        engine.register_fn("get_dns", || -> ImmutableString {
            let mut buf = [0u8; 16];
            let len = crate::net::format_ipv4(crate::net::DNS_SERVER, &mut buf);
            String::from_utf8_lossy(&buf[..len]).into_owned().into()
        });
        
        // get_prefix() -> i64
        engine.register_fn("get_prefix", || -> i64 {
            crate::net::PREFIX_LEN as i64
        });
        
        // net_available() -> bool
        engine.register_fn("net_available", || -> bool {
            crate::NET_STATE.lock().is_some()
        });
    }
    
    // ═══════════════════════════════════════════════════════════════════════
    // os:sys MODULE - System functions
    // ═══════════════════════════════════════════════════════════════════════
    
    fn register_sys_module(engine: &mut Engine) {
        // time_ms() -> i64 (milliseconds since boot)
        engine.register_fn("time_ms", || -> i64 {
            const CLINT_MTIME: usize = 0x0200_BFF8;
            let mtime = unsafe { core::ptr::read_volatile(CLINT_MTIME as *const u64) };
            (mtime / 10_000) as i64
        });
        
        // sleep(ms)
        engine.register_fn("sleep", |ms: i64| {
            const CLINT_MTIME: usize = 0x0200_BFF8;
            let start = unsafe { core::ptr::read_volatile(CLINT_MTIME as *const u64) };
            let ticks = ms as u64 * 10_000;
            loop {
                let now = unsafe { core::ptr::read_volatile(CLINT_MTIME as *const u64) };
                if now.wrapping_sub(start) >= ticks { break; }
                core::hint::spin_loop();
                {
                    let mut net_guard = crate::NET_STATE.lock();
                    if let Some(ref mut net) = *net_guard {
                        net.poll((now / 10_000) as i64);
                    }
                }
            }
        });
        
        // cwd() -> String
        engine.register_fn("cwd", || -> ImmutableString {
            crate::cwd_get().into()
        });
        
        // kernel_version() -> String
        engine.register_fn("kernel_version", || -> ImmutableString {
            const VERSION: &str = env!("CARGO_PKG_VERSION");
            format!("BAVY OS v{}", VERSION).into()
        });
        
        // arch() -> String
        engine.register_fn("arch", || -> ImmutableString {
            "RISC-V 64-bit (RV64GC)".into()
        });
        
        // harts_online() -> i64
        engine.register_fn("harts_online", || -> i64 {
            crate::HARTS_ONLINE.load(core::sync::atomic::Ordering::Relaxed) as i64
        });
    }
    
    // ═══════════════════════════════════════════════════════════════════════
    // os:proc MODULE - Process management functions
    // ═══════════════════════════════════════════════════════════════════════
    
    fn register_proc_module(engine: &mut Engine) {
        // get_tasks() -> Array of {pid, name, state, priority, hart, cpu_time, uptime}
        engine.register_fn("get_tasks", || -> Array {
            let mut list = Array::new();
            let tasks = crate::scheduler::SCHEDULER.list_tasks();
            for task in tasks {
                let mut map = Map::new();
                map.insert("pid".into(), Dynamic::from(task.pid as i64));
                map.insert("name".into(), Dynamic::from(task.name));
                map.insert("state".into(), Dynamic::from(task.state.as_str()));
                map.insert("priority".into(), Dynamic::from(task.priority.as_str()));
                map.insert("hart".into(), Dynamic::from(task.hart.map(|h| h as i64).unwrap_or(-1)));
                map.insert("cpu_time".into(), Dynamic::from(task.cpu_time as i64));
                map.insert("uptime".into(), Dynamic::from(task.uptime as i64));
                list.push(Dynamic::from(map));
            }
            list
        });
        
        // task_count() -> i64
        engine.register_fn("task_count", || -> i64 {
            crate::scheduler::SCHEDULER.task_count() as i64
        });
        
        // kill_task(pid) -> bool
        engine.register_fn("kill_task", |pid: i64| -> bool {
            if pid <= 0 {
                return false;
            }
            crate::scheduler::SCHEDULER.kill(pid as u32)
        });
        
        // get_klog(count) -> Array of formatted log strings
        engine.register_fn("get_klog", |count: i64| -> Array {
            let count = count.max(1).min(100) as usize;
            let entries = crate::klog::KLOG.recent(count);
            entries.iter()
                .rev() // Most recent first
                .map(|e| Dynamic::from(e.format_colored()))
                .collect()
        });
        
        // services() -> Array of {name, pid, status, started_at, hart}
        engine.register_fn("services", || -> Array {
            let mut list = Array::new();
            let services = crate::init::list_services();
            for svc in services {
                let mut map = Map::new();
                map.insert("name".into(), Dynamic::from(svc.name));
                map.insert("pid".into(), Dynamic::from(svc.pid as i64));
                map.insert("status".into(), Dynamic::from(svc.status.as_str()));
                map.insert("started_at".into(), Dynamic::from(svc.started_at as i64));
                map.insert("hart".into(), Dynamic::from(svc.hart.map(|h| h as i64).unwrap_or(-1)));
                list.push(Dynamic::from(map));
            }
            list
        });
        
        // service_defs() -> Array of {name, description}
        engine.register_fn("service_defs", || -> Array {
            let mut list = Array::new();
            let defs = crate::init::list_service_defs();
            for (name, desc) in defs {
                let mut map = Map::new();
                map.insert("name".into(), Dynamic::from(name));
                map.insert("description".into(), Dynamic::from(desc));
                list.push(Dynamic::from(map));
            }
            list
        });
        
        // start_service(name) -> bool
        engine.register_fn("start_service", |name: ImmutableString| -> bool {
            match crate::init::start_service(name.as_str()) {
                Ok(()) => true,
                Err(_) => false,
            }
        });
        
        // stop_service(name) -> bool
        engine.register_fn("stop_service", |name: ImmutableString| -> bool {
            match crate::init::stop_service(name.as_str()) {
                Ok(()) => true,
                Err(_) => false,
            }
        });
        
        // restart_service(name) -> bool
        engine.register_fn("restart_service", |name: ImmutableString| -> bool {
            match crate::init::restart_service(name.as_str()) {
                Ok(()) => true,
                Err(_) => false,
            }
        });
        
        // service_status(name) -> String ("running", "stopped", "failed", or "unknown")
        engine.register_fn("service_status", |name: ImmutableString| -> ImmutableString {
            match crate::init::service_status(name.as_str()) {
                Some(status) => status.as_str().into(),
                None => "unknown".into(),
            }
        });
    }
    
    // ═══════════════════════════════════════════════════════════════════════
    // os:mem MODULE - Memory functions
    // ═══════════════════════════════════════════════════════════════════════
    
    fn register_mem_module(engine: &mut Engine) {
        // heap_total() -> i64
        engine.register_fn("heap_total", || -> i64 {
            crate::allocator::heap_size() as i64
        });
        
        // heap_used() -> i64
        engine.register_fn("heap_used", || -> i64 {
            let (used, _) = crate::allocator::heap_stats();
            used as i64
        });
        
        // heap_free() -> i64
        engine.register_fn("heap_free", || -> i64 {
            let (_, free) = crate::allocator::heap_stats();
            free as i64
        });
        
        // heap_stats() -> {used, free}
        engine.register_fn("heap_stats", || -> Map {
            let (used, free) = crate::allocator::heap_stats();
            let mut map = Map::new();
            map.insert("used".into(), Dynamic::from(used as i64));
            map.insert("free".into(), Dynamic::from(free as i64));
            map
        });
    }
    
    // ═══════════════════════════════════════════════════════════════════════
    // os:http MODULE - HTTP client functions
    // ═══════════════════════════════════════════════════════════════════════
    
    fn register_http_module(engine: &mut Engine) {
        /// Helper to get time in milliseconds
        fn get_time_ms() -> i64 {
            const CLINT_MTIME: usize = 0x0200_BFF8;
            let mtime = unsafe { core::ptr::read_volatile(CLINT_MTIME as *const u64) };
            (mtime / 10_000) as i64
        }
        
        // http_request(options) -> {ok, status, statusText, headers, body}
        // options = {url, method?, headers?, body?, timeout?}
        engine.register_fn("http_request", |options: Map| -> Map {
            let mut result = Map::new();
            
            // Extract URL (required)
            let url = match options.get("url") {
                Some(v) => v.clone().into_string().unwrap_or_default(),
                None => {
                    result.insert("ok".into(), Dynamic::from(false));
                    result.insert("error".into(), Dynamic::from("Missing 'url' in options"));
                    return result;
                }
            };
            
            // Extract method (default: GET)
            let method_str = options.get("method")
                .map(|v| v.clone().into_string().unwrap_or_default())
                .unwrap_or_else(|| "GET".to_string());
            
            let method = match method_str.to_uppercase().as_str() {
                "GET" => crate::http::HttpMethod::Get,
                "POST" => crate::http::HttpMethod::Post,
                "PUT" => crate::http::HttpMethod::Put,
                "DELETE" => crate::http::HttpMethod::Delete,
                "HEAD" => crate::http::HttpMethod::Head,
                _ => {
                    result.insert("ok".into(), Dynamic::from(false));
                    result.insert("error".into(), Dynamic::from("Invalid HTTP method"));
                    return result;
                }
            };
            
            // Extract timeout (default: 10000ms)
            let timeout = options.get("timeout")
                .and_then(|v| v.clone().try_cast::<i64>())
                .unwrap_or(10000);
            
            // Extract followRedirects option (default: true)
            let follow_redirects = options.get("followRedirects")
                .and_then(|v| v.clone().try_cast::<bool>())
                .unwrap_or(true);
            
            // Build the request
            let mut request = match crate::http::HttpRequest::new(method, &url) {
                Ok(r) => r,
                Err(e) => {
                    result.insert("ok".into(), Dynamic::from(false));
                    result.insert("error".into(), Dynamic::from(e));
                    return result;
                }
            };
            
            // Extract custom headers
            if let Some(headers_val) = options.get("headers") {
                if let Some(headers_map) = headers_val.clone().try_cast::<Map>() {
                    for (key, value) in headers_map.iter() {
                        if let Ok(v) = value.clone().into_string() {
                            request.headers.insert(key.to_string(), v);
                        }
                    }
                }
            }
            
            // Extract body
            if let Some(body_val) = options.get("body") {
                if let Ok(body_str) = body_val.clone().into_string() {
                    request = request.body_str(&body_str);
                }
            }
            
            // Perform the request
            {
                let mut net_guard = crate::NET_STATE.lock();
                if let Some(ref mut net) = *net_guard {
                    let http_result = if follow_redirects {
                        crate::http::http_request_follow_redirects(net, &request, timeout, get_time_ms)
                    } else {
                        crate::http::http_request(net, &request, timeout, get_time_ms)
                    };
                    match http_result {
                        Ok(response) => {
                            // Extract body first (needs borrow), then move other fields
                            let body_text = response.text();
                            let status_code = response.status_code;
                            let status_text = response.status_text;
                            
                            result.insert("ok".into(), Dynamic::from(true));
                            result.insert("status".into(), Dynamic::from(status_code as i64));
                            result.insert("statusText".into(), Dynamic::from(status_text));
                            
                            // Convert headers to Map
                            let mut headers_map = Map::new();
                            for (key, value) in response.headers {
                                headers_map.insert(key.into(), Dynamic::from(value));
                            }
                            result.insert("headers".into(), Dynamic::from(headers_map));
                            result.insert("body".into(), Dynamic::from(body_text));
                        }
                        Err(e) => {
                            result.insert("ok".into(), Dynamic::from(false));
                            result.insert("error".into(), Dynamic::from(e));
                        }
                    }
                } else {
                    result.insert("ok".into(), Dynamic::from(false));
                    result.insert("error".into(), Dynamic::from("Network not available"));
                }
            }
            
            result
        });
        
        // http_get(url) -> {ok, status, body, ...}
        // Automatically follows redirects
        engine.register_fn("http_get", |url: ImmutableString| -> Map {
            let mut result = Map::new();
            
            let mut net_guard = crate::NET_STATE.lock();
            if let Some(ref mut net) = *net_guard {
                match crate::http::get_follow_redirects(net, url.as_str(), 10000, get_time_ms) {
                    Ok(response) => {
                        let body_text = response.text();
                        let status_code = response.status_code;
                        let status_text = response.status_text;
                        
                        result.insert("ok".into(), Dynamic::from(true));
                        result.insert("status".into(), Dynamic::from(status_code as i64));
                        result.insert("statusText".into(), Dynamic::from(status_text));
                        
                        let mut headers_map = Map::new();
                        for (key, value) in response.headers {
                            headers_map.insert(key.into(), Dynamic::from(value));
                        }
                        result.insert("headers".into(), Dynamic::from(headers_map));
                        result.insert("body".into(), Dynamic::from(body_text));
                    }
                    Err(e) => {
                        result.insert("ok".into(), Dynamic::from(false));
                        result.insert("error".into(), Dynamic::from(e));
                    }
                }
            } else {
                result.insert("ok".into(), Dynamic::from(false));
                result.insert("error".into(), Dynamic::from("Network not available"));
            }
            
            result
        });
        
        // http_post(url, body, content_type) -> {ok, status, body, ...}
        engine.register_fn("http_post", |url: ImmutableString, body: ImmutableString, content_type: ImmutableString| -> Map {
            let mut result = Map::new();
            
            let mut net_guard = crate::NET_STATE.lock();
            if let Some(ref mut net) = *net_guard {
                match crate::http::post(net, url.as_str(), body.as_str(), content_type.as_str(), 10000, get_time_ms) {
                    Ok(response) => {
                        let body_text = response.text();
                        let status_code = response.status_code;
                        let status_text = response.status_text;
                        
                        result.insert("ok".into(), Dynamic::from(true));
                        result.insert("status".into(), Dynamic::from(status_code as i64));
                        result.insert("statusText".into(), Dynamic::from(status_text));
                        
                        let mut headers_map = Map::new();
                        for (key, value) in response.headers {
                            headers_map.insert(key.into(), Dynamic::from(value));
                        }
                        result.insert("headers".into(), Dynamic::from(headers_map));
                        result.insert("body".into(), Dynamic::from(body_text));
                    }
                    Err(e) => {
                        result.insert("ok".into(), Dynamic::from(false));
                        result.insert("error".into(), Dynamic::from(e));
                    }
                }
            } else {
                result.insert("ok".into(), Dynamic::from(false));
                result.insert("error".into(), Dynamic::from("Network not available"));
            }
            
            result
        });
    }
    
    // ═══════════════════════════════════════════════════════════════════════
    // MODULE OBJECTS - For namespace imports (import * as X from "...")
    // ═══════════════════════════════════════════════════════════════════════
    
    fn register_module_objects(engine: &mut Engine) {
        // Register module types
        engine.register_type_with_name::<FsModule>("FsModule");
        engine.register_type_with_name::<NetModule>("NetModule");
        engine.register_type_with_name::<SysModule>("SysModule");
        engine.register_type_with_name::<MemModule>("MemModule");
        engine.register_type_with_name::<HttpModule>("HttpModule");
        
        // __module_fs() -> FsModule
        engine.register_fn("__module_fs", || FsModule);
        
        // FsModule methods
        engine.register_fn("ls", |_: &mut FsModule| -> Array {
            let mut list = Array::new();
            let fs_guard = crate::FS_STATE.lock();
            let mut blk_guard = crate::BLK_DEV.lock();
            if let (Some(fs), Some(dev)) = (fs_guard.as_ref(), blk_guard.as_mut()) {
                let files = fs.list_dir(dev, "/");
                for f in files {
                    let mut map = Map::new();
                    map.insert("name".into(), Dynamic::from(f.name));
                    map.insert("size".into(), Dynamic::from(f.size as i64));
                    map.insert("is_dir".into(), Dynamic::from(f.is_dir));
                    list.push(Dynamic::from(map));
                }
            }
            list
        });
        engine.register_fn("read", |_: &mut FsModule, path: ImmutableString| -> ImmutableString {
            let fs_guard = crate::FS_STATE.lock();
            let mut blk_guard = crate::BLK_DEV.lock();
            if let (Some(fs), Some(dev)) = (fs_guard.as_ref(), blk_guard.as_mut()) {
                if let Some(data) = fs.read_file(dev, path.as_str()) {
                    return String::from_utf8_lossy(&data).into_owned().into();
                }
            }
            "".into()
        });
        engine.register_fn("write", |_: &mut FsModule, path: ImmutableString, content: ImmutableString| -> bool {
            let mut fs_guard = crate::FS_STATE.lock();
            let mut blk_guard = crate::BLK_DEV.lock();
            if let (Some(fs), Some(dev)) = (fs_guard.as_mut(), blk_guard.as_mut()) {
                return fs.write_file(dev, path.as_str(), content.as_bytes()).is_ok();
            }
            false
        });
        engine.register_fn("exists", |_: &mut FsModule, path: ImmutableString| -> bool {
            let fs_guard = crate::FS_STATE.lock();
            let mut blk_guard = crate::BLK_DEV.lock();
            if let (Some(fs), Some(dev)) = (fs_guard.as_ref(), blk_guard.as_mut()) {
                return fs.read_file(dev, path.as_str()).is_some();
            }
            false
        });
        engine.register_fn("available", |_: &mut FsModule| -> bool {
            crate::FS_STATE.lock().is_some()
        });
        
        // __module_net() -> NetModule
        engine.register_fn("__module_net", || NetModule);
        
        // NetModule methods
        engine.register_fn("ip", |_: &mut NetModule| -> ImmutableString {
            let mut buf = [0u8; 16];
            let ip = crate::net::get_my_ip();
            let len = crate::net::format_ipv4(ip, &mut buf);
            String::from_utf8_lossy(&buf[..len]).into_owned().into()
        });
        engine.register_fn("mac", |_: &mut NetModule| -> ImmutableString {
            let net_guard = crate::NET_STATE.lock();
            if let Some(ref state) = *net_guard {
                return String::from_utf8_lossy(&state.mac_str()).into_owned().into();
            }
            "00:00:00:00:00:00".into()
        });
        engine.register_fn("gateway", |_: &mut NetModule| -> ImmutableString {
            let mut buf = [0u8; 16];
            let len = crate::net::format_ipv4(crate::net::GATEWAY, &mut buf);
            String::from_utf8_lossy(&buf[..len]).into_owned().into()
        });
        engine.register_fn("dns", |_: &mut NetModule| -> ImmutableString {
            let mut buf = [0u8; 16];
            let len = crate::net::format_ipv4(crate::net::DNS_SERVER, &mut buf);
            String::from_utf8_lossy(&buf[..len]).into_owned().into()
        });
        engine.register_fn("prefix", |_: &mut NetModule| -> i64 {
            crate::net::PREFIX_LEN as i64
        });
        engine.register_fn("available", |_: &mut NetModule| -> bool {
            crate::NET_STATE.lock().is_some()
        });
        
        // __module_sys() -> SysModule
        engine.register_fn("__module_sys", || SysModule);
        
        // SysModule methods
        engine.register_fn("time", |_: &mut SysModule| -> i64 {
            const CLINT_MTIME: usize = 0x0200_BFF8;
            let mtime = unsafe { core::ptr::read_volatile(CLINT_MTIME as *const u64) };
            (mtime / 10_000) as i64
        });
        engine.register_fn("sleep", |_: &mut SysModule, ms: i64| {
            const CLINT_MTIME: usize = 0x0200_BFF8;
            let start = unsafe { core::ptr::read_volatile(CLINT_MTIME as *const u64) };
            let ticks = ms as u64 * 10_000;
            loop {
                let now = unsafe { core::ptr::read_volatile(CLINT_MTIME as *const u64) };
                if now.wrapping_sub(start) >= ticks { break; }
                core::hint::spin_loop();
                {
                    let mut net_guard = crate::NET_STATE.lock();
                    if let Some(ref mut net) = *net_guard {
                        net.poll((now / 10_000) as i64);
                    }
                }
            }
        });
        engine.register_fn("cwd", |_: &mut SysModule| -> ImmutableString {
            crate::cwd_get().into()
        });
        engine.register_fn("version", |_: &mut SysModule| -> ImmutableString {
            const VERSION: &str = env!("CARGO_PKG_VERSION");
            format!("BAVY OS v{}", VERSION).into()
        });
        engine.register_fn("arch", |_: &mut SysModule| -> ImmutableString {
            "RISC-V 64-bit (RV64GC)".into()
        });
        
        // __module_mem() -> MemModule
        engine.register_fn("__module_mem", || MemModule);
        
        // MemModule methods
        engine.register_fn("total", |_: &mut MemModule| -> i64 {
            crate::allocator::heap_size() as i64
        });
        engine.register_fn("used", |_: &mut MemModule| -> i64 {
            let (used, _) = crate::allocator::heap_stats();
            used as i64
        });
        engine.register_fn("free", |_: &mut MemModule| -> i64 {
            let (_, free) = crate::allocator::heap_stats();
            free as i64
        });
        engine.register_fn("stats", |_: &mut MemModule| -> Map {
            let (used, free) = crate::allocator::heap_stats();
            let mut map = Map::new();
            map.insert("used".into(), Dynamic::from(used as i64));
            map.insert("free".into(), Dynamic::from(free as i64));
            map
        });
        
        // __module_http() -> HttpModule
        engine.register_fn("__module_http", || HttpModule);
        
        /// Helper to get time in milliseconds
        fn get_time_ms_mod() -> i64 {
            const CLINT_MTIME: usize = 0x0200_BFF8;
            let mtime = unsafe { core::ptr::read_volatile(CLINT_MTIME as *const u64) };
            (mtime / 10_000) as i64
        }
        
        // HttpModule methods
        // http.get(url) -> response object
        // Automatically follows redirects
        engine.register_fn("get", |_: &mut HttpModule, url: ImmutableString| -> Map {
            let mut result = Map::new();
            
            let mut net_guard = crate::NET_STATE.lock();
            if let Some(ref mut net) = *net_guard {
                match crate::http::get_follow_redirects(net, url.as_str(), 10000, get_time_ms_mod) {
                    Ok(response) => {
                        let body_text = response.text();
                        let status_code = response.status_code;
                        let status_text = response.status_text;
                        
                        result.insert("ok".into(), Dynamic::from(true));
                        result.insert("status".into(), Dynamic::from(status_code as i64));
                        result.insert("statusText".into(), Dynamic::from(status_text));
                        
                        let mut headers_map = Map::new();
                        for (key, value) in response.headers {
                            headers_map.insert(key.into(), Dynamic::from(value));
                        }
                        result.insert("headers".into(), Dynamic::from(headers_map));
                        result.insert("body".into(), Dynamic::from(body_text));
                    }
                    Err(e) => {
                        result.insert("ok".into(), Dynamic::from(false));
                        result.insert("error".into(), Dynamic::from(e));
                    }
                }
            } else {
                result.insert("ok".into(), Dynamic::from(false));
                result.insert("error".into(), Dynamic::from("Network not available"));
            }
            
            result
        });
        
        // http.post(url, body, content_type) -> response object
        engine.register_fn("post", |_: &mut HttpModule, url: ImmutableString, body: ImmutableString, content_type: ImmutableString| -> Map {
            let mut result = Map::new();
            
            let mut net_guard = crate::NET_STATE.lock();
            if let Some(ref mut net) = *net_guard {
                match crate::http::post(net, url.as_str(), body.as_str(), content_type.as_str(), 10000, get_time_ms_mod) {
                    Ok(response) => {
                        let body_text = response.text();
                        let status_code = response.status_code;
                        let status_text = response.status_text;
                        
                        result.insert("ok".into(), Dynamic::from(true));
                        result.insert("status".into(), Dynamic::from(status_code as i64));
                        result.insert("statusText".into(), Dynamic::from(status_text));
                        
                        let mut headers_map = Map::new();
                        for (key, value) in response.headers {
                            headers_map.insert(key.into(), Dynamic::from(value));
                        }
                        result.insert("headers".into(), Dynamic::from(headers_map));
                        result.insert("body".into(), Dynamic::from(body_text));
                    }
                    Err(e) => {
                        result.insert("ok".into(), Dynamic::from(false));
                        result.insert("error".into(), Dynamic::from(e));
                    }
                }
            } else {
                result.insert("ok".into(), Dynamic::from(false));
                result.insert("error".into(), Dynamic::from("Network not available"));
            }
            
            result
        });
        
        // http.request(options) -> response object
        engine.register_fn("request", |_: &mut HttpModule, options: Map| -> Map {
            let mut result = Map::new();
            
            // Extract URL (required)
            let url = match options.get("url") {
                Some(v) => v.clone().into_string().unwrap_or_default(),
                None => {
                    result.insert("ok".into(), Dynamic::from(false));
                    result.insert("error".into(), Dynamic::from("Missing 'url' in options"));
                    return result;
                }
            };
            
            // Extract method (default: GET)
            let method_str = options.get("method")
                .map(|v| v.clone().into_string().unwrap_or_default())
                .unwrap_or_else(|| "GET".to_string());
            
            let method = match method_str.to_uppercase().as_str() {
                "GET" => crate::http::HttpMethod::Get,
                "POST" => crate::http::HttpMethod::Post,
                "PUT" => crate::http::HttpMethod::Put,
                "DELETE" => crate::http::HttpMethod::Delete,
                "HEAD" => crate::http::HttpMethod::Head,
                _ => {
                    result.insert("ok".into(), Dynamic::from(false));
                    result.insert("error".into(), Dynamic::from("Invalid HTTP method"));
                    return result;
                }
            };
            
            // Extract timeout (default: 10000ms)
            let timeout = options.get("timeout")
                .and_then(|v| v.clone().try_cast::<i64>())
                .unwrap_or(10000);
            
            // Build the request
            let mut request = match crate::http::HttpRequest::new(method, &url) {
                Ok(r) => r,
                Err(e) => {
                    result.insert("ok".into(), Dynamic::from(false));
                    result.insert("error".into(), Dynamic::from(e));
                    return result;
                }
            };
            
            // Extract custom headers
            if let Some(headers_val) = options.get("headers") {
                if let Some(headers_map) = headers_val.clone().try_cast::<Map>() {
                    for (key, value) in headers_map.iter() {
                        if let Ok(v) = value.clone().into_string() {
                            request.headers.insert(key.to_string(), v);
                        }
                    }
                }
            }
            
            // Extract body
            if let Some(body_val) = options.get("body") {
                if let Ok(body_str) = body_val.clone().into_string() {
                    request = request.body_str(&body_str);
                }
            }
            
            // Perform the request
            {
                let mut net_guard = crate::NET_STATE.lock();
                if let Some(ref mut net) = *net_guard {
                    match crate::http::http_request(net, &request, timeout, get_time_ms_mod) {
                        Ok(response) => {
                            let body_text = response.text();
                            let status_code = response.status_code;
                            let status_text = response.status_text;
                            
                            result.insert("ok".into(), Dynamic::from(true));
                            result.insert("status".into(), Dynamic::from(status_code as i64));
                            result.insert("statusText".into(), Dynamic::from(status_text));
                            
                            let mut headers_map = Map::new();
                            for (key, value) in response.headers {
                                headers_map.insert(key.into(), Dynamic::from(value));
                            }
                            result.insert("headers".into(), Dynamic::from(headers_map));
                            result.insert("body".into(), Dynamic::from(body_text));
                        }
                        Err(e) => {
                            result.insert("ok".into(), Dynamic::from(false));
                            result.insert("error".into(), Dynamic::from(e));
                        }
                    }
                } else {
                    result.insert("ok".into(), Dynamic::from(false));
                    result.insert("error".into(), Dynamic::from("Network not available"));
                }
            }
            
            result
        });
        
        // http.available() -> bool
        engine.register_fn("available", |_: &mut HttpModule| -> bool {
            crate::NET_STATE.lock().is_some()
        });
    }
    
    /// Create a new runtime (internal, use get_runtime() for cached access)
    fn new_internal() -> Self {
        log_debug!("Initializing JavaScript runtime...");
        
        let mut engine = Engine::new_raw();
        
        // Register StandardPackage
        let package = StandardPackage::new();
        engine.register_global_module(package.as_shared_module());
        
        // Engine limits
        engine.set_max_call_levels(64);
        engine.set_max_operations(1_000_000);
        engine.set_max_string_size(16384);
        engine.set_max_array_size(10000);
        engine.set_max_map_size(1000);
        engine.set_max_expr_depths(64, 64);
        
        // Register all module functions as globals
        Self::register_fs_module(&mut engine);
        Self::register_net_module(&mut engine);
        Self::register_sys_module(&mut engine);
        Self::register_mem_module(&mut engine);
        Self::register_http_module(&mut engine);
        Self::register_proc_module(&mut engine);
        
        // Register module object constructors for namespace imports
        Self::register_module_objects(&mut engine);
        
        // ═══════════════════════════════════════════════════════════════════════
        // GLOBAL OUTPUT FUNCTIONS
        // ═══════════════════════════════════════════════════════════════════════
        
        engine.register_fn("print", |s: ImmutableString| {
            append_output(&s);
            append_output("\n");
        });
        engine.register_fn("print", |n: i64| {
            append_output(&format!("{}\n", n));
        });
        engine.register_fn("print", |n: f64| {
            append_output(&format!("{}\n", n));
        });
        engine.register_fn("print", |b: bool| {
            append_output(if b { "true\n" } else { "false\n" });
        });
        engine.register_fn("print", |arr: Array| {
            let s: Vec<String> = arr.iter().map(|v| v.to_string()).collect();
            append_output(&format!("[{}]\n", s.join(", ")));
        });
        engine.register_fn("print", |d: Dynamic| {
            append_output(&format!("{}\n", d));
        });
        
        engine.register_fn("write", |s: ImmutableString| {
            append_output(&s);
        });
        engine.register_fn("write", |n: i64| {
            append_output(&format!("{}", n));
        });
        
        engine.register_fn("debug", |d: Dynamic| {
            append_output(&format!("[DEBUG] {:?}\n", d));
        });
        
        // ═══════════════════════════════════════════════════════════════════════
        // GLOBAL UTILITY FUNCTIONS
        // ═══════════════════════════════════════════════════════════════════════
        
        engine.register_fn("parse_int", |s: ImmutableString| -> i64 {
            s.trim().parse::<i64>().unwrap_or(0)
        });
        
        engine.register_fn("parse_float", |s: ImmutableString| -> f64 {
            s.trim().parse::<f64>().unwrap_or(0.0)
        });
        
        engine.register_fn("type_of", |d: Dynamic| -> ImmutableString {
            d.type_name().into()
        });
        
        engine.register_fn("is_string", |d: Dynamic| -> bool {
            d.is::<ImmutableString>()
        });
        
        engine.register_fn("is_int", |d: Dynamic| -> bool {
            d.is::<i64>()
        });
        
        engine.register_fn("is_float", |d: Dynamic| -> bool {
            d.is::<f64>()
        });
        
        engine.register_fn("is_array", |d: Dynamic| -> bool {
            d.is::<Array>()
        });
        
        engine.register_fn("repeat", |s: ImmutableString, n: i64| -> ImmutableString {
            if n <= 0 { return "".into(); }
            let n = n.min(1000) as usize;
            s.repeat(n).into()
        });
        
        engine.register_fn("pad_left", |s: ImmutableString, width: i64, pad: ImmutableString| -> ImmutableString {
            let width = width.max(0) as usize;
            let pad_char = pad.chars().next().unwrap_or(' ');
            if s.len() >= width {
                s
            } else {
                let padding: String = core::iter::repeat(pad_char).take(width - s.len()).collect();
                format!("{}{}", padding, s).into()
            }
        });
        
        engine.register_fn("pad_right", |s: ImmutableString, width: i64, pad: ImmutableString| -> ImmutableString {
            let width = width.max(0) as usize;
            let pad_char = pad.chars().next().unwrap_or(' ');
            if s.len() >= width {
                s
            } else {
                let padding: String = core::iter::repeat(pad_char).take(width - s.len()).collect();
                format!("{}{}", s, padding).into()
            }
        });
        
        engine.register_fn("join", |arr: Array, sep: ImmutableString| -> ImmutableString {
            let strings: Vec<String> = arr.iter().map(|v| v.to_string()).collect();
            strings.join(sep.as_str()).into()
        });
        
        engine.register_fn("range", |end: i64| -> Array {
            (0..end.max(0).min(10000)).map(Dynamic::from).collect()
        });
        
        engine.register_fn("range", |start: i64, end: i64| -> Array {
            let start = start.min(10000);
            let end = end.min(10000);
            (start..end).map(Dynamic::from).collect()
        });
        
        engine.register_fn("range", |start: i64, end: i64, step: i64| -> Array {
            if step == 0 { return Array::new(); }
            let start = start.min(10000).max(-10000);
            let end = end.min(10000).max(-10000);
            let mut result = Array::new();
            let mut i = start;
            if step > 0 {
                while i < end && result.len() < 10000 {
                    result.push(Dynamic::from(i));
                    i += step;
                }
            } else {
                while i > end && result.len() < 10000 {
                    result.push(Dynamic::from(i));
                    i += step;
                }
            }
            result
        });
        
        log_debug!("JavaScript runtime initialized with module system");
        
        Self { engine }
    }
    
    /// Execute a script with optional arguments
    /// Uses AST caching for faster repeated execution
    pub fn execute(&self, script: &str, args: &[&str]) -> Result<String, String> {
        log_trace!("Executing script ({} bytes, {} args)", script.len(), args.len());
        
        // Preprocess ES6 imports (zero-copy if no imports)
        let preprocess_result = preprocess_imports(script);
        let processed_script = preprocess_result.as_str(script);
        
        // Compute hash for AST caching
        let script_hash = hash_script(processed_script);
        
        // Get or compile the AST (cached)
        let ast = get_or_compile_ast(&self.engine, processed_script, script_hash)?;
        
        init_output();
        
        // Build scope with arguments
        let mut scope = Scope::new();
        let args_array: Array = args.iter()
            .map(|&s| Dynamic::from(ImmutableString::from(s)))
            .collect();
        scope.push("ARGS", args_array);
        
        // Execute the cached AST
        match self.engine.eval_ast_with_scope::<Dynamic>(&mut scope, &ast) {
            Ok(result) => {
                let output = take_output();
                log_trace!("Script completed successfully, output: {} bytes", output.len());
                
                if output.is_empty() && !result.is_unit() {
                    return Ok(format!("{}\n", result));
                }
                
                Ok(String::from_utf8_lossy(&output).into_owned())
            }
            Err(e) => {
                take_output();
                log_error!("Script execution failed: {}", e);
                Err(format!("{}", e))
            }
        }
    }
    
    /// Execute script without caching (for one-off scripts like REPL)
    pub fn execute_uncached(&self, script: &str, args: &[&str]) -> Result<String, String> {
        log_trace!("Executing script uncached ({} bytes)", script.len());
        
        let preprocess_result = preprocess_imports(script);
        let processed_script = preprocess_result.as_str(script);
        
        init_output();
        
        let mut scope = Scope::new();
        let args_array: Array = args.iter()
            .map(|&s| Dynamic::from(ImmutableString::from(s)))
            .collect();
        scope.push("ARGS", args_array);
        
        match self.engine.eval_with_scope::<Dynamic>(&mut scope, processed_script) {
            Ok(result) => {
                let output = take_output();
                if output.is_empty() && !result.is_unit() {
                    return Ok(format!("{}\n", result));
                }
                Ok(String::from_utf8_lossy(&output).into_owned())
            }
            Err(e) => {
                take_output();
                log_error!("Script execution failed: {}", e);
                Err(format!("{}", e))
            }
        }
    }
    
    pub fn compile(&self, script: &str) -> Result<(), String> {
        log_trace!("Compiling script ({} bytes)", script.len());
        match self.engine.compile(script) {
            Ok(_) => Ok(()),
            Err(e) => Err(format!("Syntax error: {}", e))
        }
    }
}

// ═══════════════════════════════════════════════════════════════════════════════
// PUBLIC API
// ═══════════════════════════════════════════════════════════════════════════════

/// Execute a script with arguments (uses cached runtime and AST cache)
pub fn execute_script(script_content: &str, args: &str) -> Result<String, String> {
    let args_vec: Vec<&str> = if args.is_empty() {
        Vec::new()
    } else {
        args.split_whitespace().collect()
    };
    let runtime = get_runtime();
    runtime.execute(script_content, &args_vec)
}

/// Execute a script without AST caching (for REPL/one-off expressions)
pub fn execute_script_uncached(script_content: &str, args: &str) -> Result<String, String> {
    let args_vec: Vec<&str> = if args.is_empty() {
        Vec::new()
    } else {
        args.split_whitespace().collect()
    };
    let runtime = get_runtime();
    runtime.execute_uncached(script_content, &args_vec)
}

pub fn find_script(cmd: &str) -> Option<Vec<u8>> {
    log_trace!("Looking for script: {}", cmd);
    
    let fs_guard = crate::FS_STATE.lock();
    let mut blk_guard = crate::BLK_DEV.lock();
    
    if let (Some(fs), Some(dev)) = (fs_guard.as_ref(), blk_guard.as_mut()) {
        if cmd.contains('/') {
            let full_path = if cmd.starts_with('/') {
                alloc::string::String::from(cmd)
            } else {
                crate::resolve_path(cmd)
            };
            
            log_trace!("Resolved path: {} -> {}", cmd, full_path);
            
            if let Some(content) = fs.read_file(dev, &full_path) {
                log_debug!("Found script at path: {} ({} bytes)", full_path, content.len());
                return Some(content);
            }
            log_trace!("Script not found at path: {}", full_path);
            return None;
        }
        
        let usr_bin_path = format!("/usr/bin/{}", cmd);
        if let Some(content) = fs.read_file(dev, &usr_bin_path) {
            log_debug!("Found script in /usr/bin/: {} ({} bytes)", usr_bin_path, content.len());
            return Some(content);
        }
        
        if let Some(content) = fs.read_file(dev, cmd) {
            log_debug!("Found script in root: {} ({} bytes)", cmd, content.len());
            return Some(content);
        }
    }
    
    log_trace!("Script not found: {}", cmd);
    None
}

pub fn print_info() {
    crate::uart::write_line("");
    crate::uart::write_line("\x1b[1;36m┌─────────────────────────────────────────────────────────────┐\x1b[0m");
    crate::uart::write_line("\x1b[1;36m│\x1b[0m              \x1b[1;97mJavaScript Runtime\x1b[0m                             \x1b[1;36m│\x1b[0m");
    crate::uart::write_line("\x1b[1;36m├─────────────────────────────────────────────────────────────┤\x1b[0m");
    crate::uart::write_line("\x1b[1;36m│\x1b[0m                                                             \x1b[1;36m│\x1b[0m");
    crate::uart::write_line("\x1b[1;36m│\x1b[0m  \x1b[1;33mImport Styles:\x1b[0m                                            \x1b[1;36m│\x1b[0m");
    crate::uart::write_line("\x1b[1;36m│\x1b[0m    import * as fs from \"os:fs\"     \x1b[0;90m// namespace import\x1b[0m    \x1b[1;36m│\x1b[0m");
    crate::uart::write_line("\x1b[1;36m│\x1b[0m    import { ls, read_file } from \"os:fs\"  \x1b[0;90m// named\x1b[0m        \x1b[1;36m│\x1b[0m");
    crate::uart::write_line("\x1b[1;36m│\x1b[0m                                                             \x1b[1;36m│\x1b[0m");
    crate::uart::write_line("\x1b[1;36m│\x1b[0m  \x1b[1;33mModules:\x1b[0m                                                  \x1b[1;36m│\x1b[0m");
    crate::uart::write_line("\x1b[1;36m│\x1b[0m    \x1b[1;32mos:fs\x1b[0m   ls() read(p) write(p,d) exists(p) available()   \x1b[1;36m│\x1b[0m");
    crate::uart::write_line("\x1b[1;36m│\x1b[0m    \x1b[1;32mos:net\x1b[0m  ip() mac() gateway() dns() prefix() available() \x1b[1;36m│\x1b[0m");
    crate::uart::write_line("\x1b[1;36m│\x1b[0m    \x1b[1;32mos:sys\x1b[0m  time() sleep(ms) cwd() version() arch()        \x1b[1;36m│\x1b[0m");
    crate::uart::write_line("\x1b[1;36m│\x1b[0m    \x1b[1;32mos:mem\x1b[0m  total() used() free() stats()                   \x1b[1;36m│\x1b[0m");
    crate::uart::write_line("\x1b[1;36m│\x1b[0m    \x1b[1;32mos:http\x1b[0m get(url) post(url,body,ct) request(opts)      \x1b[1;36m│\x1b[0m");
    crate::uart::write_line("\x1b[1;36m│\x1b[0m                                                             \x1b[1;36m│\x1b[0m");
    crate::uart::write_line("\x1b[1;36m│\x1b[0m  \x1b[1;33mHTTP Response:\x1b[0m  {ok, status, statusText, headers, body}  \x1b[1;36m│\x1b[0m");
    crate::uart::write_line("\x1b[1;36m│\x1b[0m                                                             \x1b[1;36m│\x1b[0m");
    crate::uart::write_line("\x1b[1;36m│\x1b[0m  \x1b[1;33mGlobals:\x1b[0m  print() write() debug() ARGS                    \x1b[1;36m│\x1b[0m");
    crate::uart::write_line("\x1b[1;36m│\x1b[0m            parse_int() parse_float() join() range()...      \x1b[1;36m│\x1b[0m");
    crate::uart::write_line("\x1b[1;36m│\x1b[0m                                                             \x1b[1;36m│\x1b[0m");
    crate::uart::write_line("\x1b[1;36m│\x1b[0m  \x1b[1;33mLimits:\x1b[0m  call_depth=64  ops=1M  strings=16KB  arrays=10K  \x1b[1;36m│\x1b[0m");
    crate::uart::write_line("\x1b[1;36m└─────────────────────────────────────────────────────────────┘\x1b[0m");
    crate::uart::write_line("");
}
</file>

<file path="riscv-vm/src/bus.rs">
use crate::clint::{Clint, CLINT_BASE, CLINT_SIZE};
use crate::plic::{Plic, PLIC_BASE, PLIC_SIZE, UART_IRQ, VIRTIO0_IRQ};
use crate::uart::{Uart, UART_BASE, UART_SIZE};
use crate::virtio::VirtioDevice;
use crate::Trap;
use crate::dram::Dram;

#[cfg(target_arch = "wasm32")]
use js_sys::SharedArrayBuffer;

#[cfg(not(target_arch = "wasm32"))]
use std::sync::Mutex;

/// Global mutex for AMO (Atomic Memory Operations) to ensure atomicity across harts.
/// 
/// On real RISC-V hardware, AMO instructions perform read-modify-write atomically.
/// In our emulator, each hart runs in a separate thread, so we need explicit
/// synchronization to prevent race conditions.
/// 
/// For WASM builds, we use JavaScript Atomics API instead (see atomic_* methods below).
#[cfg(not(target_arch = "wasm32"))]
static AMO_LOCK: Mutex<()> = Mutex::new(());

/// Default DRAM base for the virt platform.
pub const DRAM_BASE: u64 = 0x8000_0000;

/// Base address of the RISC-V test finisher MMIO region.
pub const TEST_FINISHER_BASE: u64 = 0x0010_0000;
pub const TEST_FINISHER_SIZE: u64 = 0x1000;

/// VirtIO MMIO base address (for the first device).
pub const VIRTIO_BASE: u64 = 0x1000_1000;
/// Size of each VirtIO MMIO region.
pub const VIRTIO_STRIDE: u64 = 0x1000;

/// System bus trait for memory and MMIO access.
///
/// All methods take `&self` to allow concurrent access from multiple harts.
/// Implementations must use interior mutability (Mutex, RwLock, atomics)
/// for any mutable state.
///
/// The `Send + Sync` bounds ensure implementations are thread-safe.
pub trait Bus: Send + Sync {
    fn read8(&self, addr: u64) -> Result<u8, Trap>;
    fn read16(&self, addr: u64) -> Result<u16, Trap>;
    fn read32(&self, addr: u64) -> Result<u32, Trap>;
    fn read64(&self, addr: u64) -> Result<u64, Trap>;

    fn write8(&self, addr: u64, val: u8) -> Result<(), Trap>;
    fn write16(&self, addr: u64, val: u16) -> Result<(), Trap>;
    fn write32(&self, addr: u64, val: u32) -> Result<(), Trap>;
    fn write64(&self, addr: u64, val: u64) -> Result<(), Trap>;

    /// Generic load helper used by the MMU for page-table walks.
    fn load(&self, addr: u64, size: u64) -> Result<u64, Trap> {
        match size {
            1 => self.read8(addr).map(|v| v as u64),
            2 => self.read16(addr).map(|v| v as u64),
            4 => self.read32(addr).map(|v| v as u64),
            8 => self.read64(addr),
            _ => Err(Trap::Fatal(format!("Unsupported bus load size: {}", size))),
        }
    }

    /// Generic store helper used by the MMU for page-table A/D updates.
    fn store(&self, addr: u64, size: u64, value: u64) -> Result<(), Trap> {
        match size {
            1 => self.write8(addr, value as u8),
            2 => self.write16(addr, value as u16),
            4 => self.write32(addr, value as u32),
            8 => self.write64(addr, value),
            _ => Err(Trap::Fatal(format!("Unsupported bus store size: {}", size))),
        }
    }

    fn fetch_u32(&self, addr: u64) -> Result<u32, Trap> {
        if addr % 4 != 0 {
            return Err(Trap::InstructionAddressMisaligned(addr));
        }
        // Map LoadAccessFault to InstructionAccessFault for fetch
        self.read32(addr).map_err(|e| match e {
            Trap::LoadAccessFault(a) => Trap::InstructionAccessFault(a),
            Trap::LoadAddressMisaligned(a) => Trap::InstructionAddressMisaligned(a),
            _ => e,
        })
    }

    fn poll_interrupts(&self) -> u64 {
        0
    }

    /// Poll hardware interrupt sources for a specific hart.
    /// Returns MIP bits for that hart.
    /// Default implementation returns 0 (no interrupts).
    fn poll_interrupts_for_hart(&self, _hart_id: usize) -> u64 {
        0
    }

    // ========== Atomic Operations for SMP ==========
    //
    // These are used by AMO instructions. Default implementations use
    // non-atomic read-modify-write which works for single-threaded mode.
    // WASM implementations override these to use JavaScript Atomics API.

    /// Atomic swap (AMOSWAP): atomically replace value and return old value.
    fn atomic_swap(&self, addr: u64, value: u64, is_word: bool) -> Result<u64, Trap> {
        // Default non-atomic implementation (for single-threaded native)
        if is_word {
            let old = self.read32(addr)? as i32 as i64 as u64;
            self.write32(addr, value as u32)?;
            Ok(old)
        } else {
            let old = self.read64(addr)?;
            self.write64(addr, value)?;
            Ok(old)
        }
    }

    /// Atomic add (AMOADD): atomically add and return old value.
    fn atomic_add(&self, addr: u64, value: u64, is_word: bool) -> Result<u64, Trap> {
        if is_word {
            let old = self.read32(addr)? as i32 as i64 as u64;
            self.write32(addr, old.wrapping_add(value) as u32)?;
            Ok(old)
        } else {
            let old = self.read64(addr)?;
            self.write64(addr, old.wrapping_add(value))?;
            Ok(old)
        }
    }

    /// Atomic AND (AMOAND): atomically AND and return old value.
    fn atomic_and(&self, addr: u64, value: u64, is_word: bool) -> Result<u64, Trap> {
        if is_word {
            let old = self.read32(addr)? as i32 as i64 as u64;
            self.write32(addr, (old & value) as u32)?;
            Ok(old)
        } else {
            let old = self.read64(addr)?;
            self.write64(addr, old & value)?;
            Ok(old)
        }
    }

    /// Atomic OR (AMOOR): atomically OR and return old value.
    fn atomic_or(&self, addr: u64, value: u64, is_word: bool) -> Result<u64, Trap> {
        if is_word {
            let old = self.read32(addr)? as i32 as i64 as u64;
            self.write32(addr, (old | value) as u32)?;
            Ok(old)
        } else {
            let old = self.read64(addr)?;
            self.write64(addr, old | value)?;
            Ok(old)
        }
    }

    /// Atomic XOR (AMOXOR): atomically XOR and return old value.
    fn atomic_xor(&self, addr: u64, value: u64, is_word: bool) -> Result<u64, Trap> {
        if is_word {
            let old = self.read32(addr)? as i32 as i64 as u64;
            self.write32(addr, (old ^ value) as u32)?;
            Ok(old)
        } else {
            let old = self.read64(addr)?;
            self.write64(addr, old ^ value)?;
            Ok(old)
        }
    }

    /// Atomic MIN signed (AMOMIN): atomically store min and return old value.
    fn atomic_min(&self, addr: u64, value: u64, is_word: bool) -> Result<u64, Trap> {
        if is_word {
            let old = self.read32(addr)? as i32 as i64 as u64;
            let new = if (old as i64) < (value as i64) { old } else { value };
            self.write32(addr, new as u32)?;
            Ok(old)
        } else {
            let old = self.read64(addr)?;
            let new = if (old as i64) < (value as i64) { old } else { value };
            self.write64(addr, new)?;
            Ok(old)
        }
    }

    /// Atomic MAX signed (AMOMAX): atomically store max and return old value.
    fn atomic_max(&self, addr: u64, value: u64, is_word: bool) -> Result<u64, Trap> {
        if is_word {
            let old = self.read32(addr)? as i32 as i64 as u64;
            let new = if (old as i64) > (value as i64) { old } else { value };
            self.write32(addr, new as u32)?;
            Ok(old)
        } else {
            let old = self.read64(addr)?;
            let new = if (old as i64) > (value as i64) { old } else { value };
            self.write64(addr, new)?;
            Ok(old)
        }
    }

    /// Atomic MIN unsigned (AMOMINU): atomically store min and return old value.
    fn atomic_minu(&self, addr: u64, value: u64, is_word: bool) -> Result<u64, Trap> {
        if is_word {
            let old = self.read32(addr)? as u32 as u64;
            let new = if old < (value as u32 as u64) { old } else { value };
            self.write32(addr, new as u32)?;
            Ok(old as i32 as i64 as u64)
        } else {
            let old = self.read64(addr)?;
            let new = if old < value { old } else { value };
            self.write64(addr, new)?;
            Ok(old)
        }
    }

    /// Atomic MAX unsigned (AMOMAXU): atomically store max and return old value.
    fn atomic_maxu(&self, addr: u64, value: u64, is_word: bool) -> Result<u64, Trap> {
        if is_word {
            let old = self.read32(addr)? as u32 as u64;
            let new = if old > (value as u32 as u64) { old } else { value };
            self.write32(addr, new as u32)?;
            Ok(old as i32 as i64 as u64)
        } else {
            let old = self.read64(addr)?;
            let new = if old > value { old } else { value };
            self.write64(addr, new)?;
            Ok(old)
        }
    }

    /// Atomic compare-and-swap (for SC): returns (success, old_value).
    fn atomic_compare_exchange(
        &self,
        addr: u64,
        expected: u64,
        new_value: u64,
        is_word: bool,
    ) -> Result<(bool, u64), Trap> {
        if is_word {
            let old = self.read32(addr)? as u32;
            if old == expected as u32 {
                self.write32(addr, new_value as u32)?;
                Ok((true, old as i32 as i64 as u64))
            } else {
                Ok((false, old as i32 as i64 as u64))
            }
        } else {
            let old = self.read64(addr)?;
            if old == expected {
                self.write64(addr, new_value)?;
                Ok((true, old))
            } else {
                Ok((false, old))
            }
        }
    }
}

// A simple system bus that just wraps DRAM for now (Phase 1)
pub struct SystemBus {
    pub dram: Dram,
    pub clint: Clint,
    pub plic: Plic,
    pub uart: Uart,
    pub virtio_devices: Vec<Box<dyn VirtioDevice>>,
    /// Shared CLINT for WASM workers (routes CLINT accesses to SharedArrayBuffer)
    #[cfg(target_arch = "wasm32")]
    shared_clint: Option<crate::shared_mem::wasm::SharedClint>,
    /// Shared UART output for WASM workers (routes UART output to main thread)
    #[cfg(target_arch = "wasm32")]
    shared_uart_output: Option<crate::shared_mem::wasm::SharedUartOutput>,
    /// Shared UART input for WASM workers (receives keyboard input from main thread)
    #[cfg(target_arch = "wasm32")]
    shared_uart_input: Option<crate::shared_mem::wasm::SharedUartInput>,
}

impl SystemBus {
    pub fn new(dram_base: u64, dram_size: usize) -> Self {
        Self {
            dram: Dram::new(dram_base, dram_size),
            clint: Clint::new(),
            plic: Plic::new(),
            uart: Uart::new(),
            virtio_devices: Vec::new(),
            #[cfg(target_arch = "wasm32")]
            shared_clint: None,
            #[cfg(target_arch = "wasm32")]
            shared_uart_output: None,
            #[cfg(target_arch = "wasm32")]
            shared_uart_input: None,
        }
    }

    /// Create a SystemBus from an existing SharedArrayBuffer for SMP mode.
    ///
    /// Used by main thread and Web Workers to attach to shared memory.
    /// Both get a view of the shared DRAM and use the shared CLINT region
    /// for cross-hart communication (IPI, timer).
    ///
    /// # Arguments
    /// * `buffer` - The full SharedArrayBuffer containing control + CLINT + UART + DRAM regions
    /// * `dram_offset` - Byte offset where DRAM region starts within the buffer
    /// * `shared_clint` - SharedClint accessor for the shared CLINT region
    /// * `is_worker` - If true, enables shared UART input for receiving keyboard input.
    ///                 Main thread (hart 0) should pass false since it reads from local UART.
    ///
    /// IMPORTANT: Pass the FULL SharedArrayBuffer, not a sliced copy!
    /// SharedArrayBuffer::slice() creates a copy, breaking shared memory.
    #[cfg(target_arch = "wasm32")]
    pub fn from_shared_buffer(
        buffer: SharedArrayBuffer, 
        dram_offset: usize,
        shared_clint: crate::shared_mem::wasm::SharedClint,
        is_worker: bool,
    ) -> Self {
        // Use the shared CLINT's hart count for local CLINT initialization
        // The local CLINT is a fallback; shared_clint is used for actual MMIO
        let num_harts = shared_clint.num_harts();
        let clint = Clint::with_harts(num_harts);
        
        // Create shared UART output for workers to send output to main thread
        let shared_uart_output = crate::shared_mem::wasm::SharedUartOutput::new(&buffer);
        
        // Create shared UART input only for workers - main thread reads from local UART
        let shared_uart_input = if is_worker {
            Some(crate::shared_mem::wasm::SharedUartInput::new(&buffer))
        } else {
            None
        };
        
        Self {
            dram: Dram::from_shared(DRAM_BASE, buffer, dram_offset),
            clint,
            plic: Plic::new(),
            uart: Uart::new(),
            virtio_devices: Vec::new(),
            shared_clint: Some(shared_clint),
            shared_uart_output: Some(shared_uart_output),
            shared_uart_input,
        }
    }

    pub fn dram_base(&self) -> u64 {
        self.dram.base
    }

    pub fn dram_size(&self) -> usize {
        self.dram.size()
    }
    
    /// Set the number of harts (called by emulator at init).
    /// This writes the hart count to a CLINT register so the kernel can read it.
    pub fn set_num_harts(&self, num_harts: usize) {
        self.clint.set_num_harts(num_harts);
    }

    /// Check interrupts for hart 0 (backward compatibility).
    pub fn check_interrupts(&self) -> u64 {
        self.check_interrupts_for_hart(0)
    }

    /// Check interrupts for a specific hart.
    /// 
    /// Each hart has its own:
    /// - MSIP (software interrupt from CLINT)
    /// - MTIP (timer interrupt from CLINT)
    /// - SEIP/MEIP (external interrupt from PLIC)
    /// 
    /// Thread-safe: each device has internal locking.
    /// Optimized to minimize lock acquisitions.
    #[cfg(not(target_arch = "wasm32"))]
    pub fn check_interrupts_for_hart(&self, hart_id: usize) -> u64 {
        // Advance CLINT timer - only from hart 0 to avoid Nx speedup with N harts
        if hart_id == 0 {
            self.clint.tick();
        }

        // Update PLIC with UART interrupt status
        let uart_irq = self.uart.is_interrupting();
        self.plic.set_source_level(UART_IRQ, uart_irq);

        // Update PLIC with VirtIO interrupts
        // Device 0 -> IRQ 1 (VIRTIO0_IRQ)
        // Device 1 -> IRQ 2
        // etc.
        for (i, dev) in self.virtio_devices.iter().enumerate() {
            let irq = VIRTIO0_IRQ + i as u32;
            if irq < 32 {
                self.plic.set_source_level(irq, dev.is_interrupting());
            }
        }

        // Calculate MIP bits for this hart
        let mut mip: u64 = 0;

        // Get CLINT interrupts in a single lock acquisition
        let (msip, timer) = self.clint.check_interrupts_for_hart(hart_id);
        
        // MSIP (Machine Software Interrupt) - Bit 3
        if msip {
            mip |= 1 << 3;
        }

        // MTIP (Machine Timer Interrupt) - Bit 7
        if timer {
            mip |= 1 << 7;
        }

        // SEIP (Supervisor External Interrupt) - Bit 9
        // Use fast lock-free check
        if self.plic.is_interrupt_pending_for_fast(Plic::s_context(hart_id)) {
            mip |= 1 << 9;
        }

        // MEIP (Machine External Interrupt) - Bit 11
        // Use fast lock-free check
        if self.plic.is_interrupt_pending_for_fast(Plic::m_context(hart_id)) {
            mip |= 1 << 11;
        }

        mip
    }
    
    /// Check interrupts for a specific hart (WASM version).
    /// 
    /// For WASM with shared memory, uses the shared CLINT to correctly
    /// receive IPIs between harts.
    #[cfg(target_arch = "wasm32")]
    pub fn check_interrupts_for_hart(&self, hart_id: usize) -> u64 {
        // Calculate MIP bits for this hart
        let mut mip: u64 = 0;

        // Get CLINT interrupts - use shared CLINT if available (for SMP),
        // otherwise fall back to local CLINT
        let (msip, timer) = if let Some(ref shared) = self.shared_clint {
            // Use shared CLINT for cross-hart IPI visibility
            shared.check_interrupts(hart_id)
        } else {
            self.clint.check_interrupts_for_hart(hart_id)
        };
        
        // MSIP (Machine Software Interrupt) - Bit 3
        if msip {
            mip |= 1 << 3;
        }

        // MTIP (Machine Timer Interrupt) - Bit 7
        if timer {
            mip |= 1 << 7;
        }

        // Hart 0 handles devices - advance timer and update PLIC
        // Workers (hart 1+) don't have virtio_devices, so PLIC checks are safe but no-op
        if hart_id == 0 {
            // Advance local CLINT timer from hart 0 only
            // Note: Shared CLINT timer is ticked separately in WasmVm::step()
            self.clint.tick();

            // Update PLIC with UART interrupt status
            let uart_irq = self.uart.is_interrupting();
            self.plic.set_source_level(UART_IRQ, uart_irq);

            // Update PLIC with VirtIO interrupts
            for (i, dev) in self.virtio_devices.iter().enumerate() {
                let irq = VIRTIO0_IRQ + i as u32;
                if irq < 32 {
                    self.plic.set_source_level(irq, dev.is_interrupting());
                }
            }
        }

        // SEIP (Supervisor External Interrupt) - Bit 9
        if self.plic.is_interrupt_pending_for_fast(Plic::s_context(hart_id)) {
            mip |= 1 << 9;
        }

        // MEIP (Machine External Interrupt) - Bit 11
        if self.plic.is_interrupt_pending_for_fast(Plic::m_context(hart_id)) {
            mip |= 1 << 11;
        }

        mip
    }

    fn get_virtio_device(&self, addr: u64) -> Option<(usize, u64)> {
        if addr >= VIRTIO_BASE {
            let offset = addr - VIRTIO_BASE;
            let idx = (offset / VIRTIO_STRIDE) as usize;
            if idx < self.virtio_devices.len() {
                return Some((idx, offset % VIRTIO_STRIDE));
            }
        }
        None
    }
    
    /// Check if an address is in the VirtIO MMIO region (even if no device present).
    /// Returns the offset within the device region if in range.
    fn is_virtio_region(&self, addr: u64) -> Option<u64> {
        if addr >= VIRTIO_BASE && addr < VIRTIO_BASE + VIRTIO_STRIDE * 8 {
            Some((addr - VIRTIO_BASE) % VIRTIO_STRIDE)
        } else {
            None
        }
    }
    
    /// Poll all VirtIO devices for pending work (e.g., incoming network packets).
    /// Should be called periodically from the main emulation loop.
    pub fn poll_virtio(&self) {
        for device in &self.virtio_devices {
            if let Err(e) = device.poll(&self.dram) {
                log::warn!("[Bus] VirtIO poll error: {:?}", e);
            }
        }
    }
    
    /// Load from CLINT, routing through shared CLINT when available (WASM workers).
    #[cfg(target_arch = "wasm32")]
    #[inline]
    fn clint_load(&self, offset: u64, size: u64) -> u64 {
        if let Some(ref shared) = self.shared_clint {
            shared.load(offset, size)
        } else {
            self.clint.load(offset, size)
        }
    }
    
    /// Load from CLINT (native builds always use local CLINT).
    #[cfg(not(target_arch = "wasm32"))]
    #[inline]
    fn clint_load(&self, offset: u64, size: u64) -> u64 {
        self.clint.load(offset, size)
    }
    
    /// Store to CLINT, routing through shared CLINT when available (WASM workers).
    #[cfg(target_arch = "wasm32")]
    #[inline]
    fn clint_store(&self, offset: u64, size: u64, value: u64) {
        if let Some(ref shared) = self.shared_clint {
            shared.store(offset, size, value);
        } else {
            self.clint.store(offset, size, value);
        }
    }
    
    /// Store to CLINT (native builds always use local CLINT).
    #[cfg(not(target_arch = "wasm32"))]
    #[inline]
    fn clint_store(&self, offset: u64, size: u64, value: u64) {
        self.clint.store(offset, size, value);
    }
    
    // Slow path methods for MMIO device access (moved out of hot path)
    
    #[cold]
    fn read8_slow(&self, addr: u64) -> Result<u8, Trap> {
        // Test finisher region: reads are harmless and return zero.
        if addr >= TEST_FINISHER_BASE && addr < TEST_FINISHER_BASE + TEST_FINISHER_SIZE {
            return Ok(0);
        }

        if addr >= CLINT_BASE && addr < CLINT_BASE + CLINT_SIZE {
            let offset = addr - CLINT_BASE;
            let val = self.clint_load(offset, 1);
            return Ok(val as u8);
        }

        if addr >= PLIC_BASE && addr < PLIC_BASE + PLIC_SIZE {
            let offset = addr - PLIC_BASE;
            let val = self.plic.load(offset, 1).map_err(|_| Trap::LoadAccessFault(addr))?;
            return Ok(val as u8);
        }

        if addr >= UART_BASE && addr < UART_BASE + UART_SIZE {
            let offset = addr - UART_BASE;
            // For workers with shared UART input, route reads to shared buffer
            #[cfg(target_arch = "wasm32")]
            if let Some(ref shared_uart) = self.shared_uart_input {
                if offset == 0 {
                    // Offset 0 is RBR (Receiver Buffer Register) - the data input
                    // Read from shared buffer (input from main thread)
                    if let Some(byte) = shared_uart.read_byte() {
                        return Ok(byte);
                    } else {
                        // No data available - return 0
                        return Ok(0);
                    }
                } else if offset == 5 {
                    // Offset 5 is LSR (Line Status Register)
                    // For workers, we need to check shared input for Data Ready bit
                    let mut lsr: u8 = 0x60; // TX empty bits always set
                    if shared_uart.has_data() {
                        lsr |= 0x01; // Data Ready bit
                    }
                    return Ok(lsr);
                }
            }
            // Fall through to local UART for main thread or other registers
            let val = self.uart.load(offset, 1).map_err(|_| Trap::LoadAccessFault(addr))?;
            return Ok(val as u8);
        }

        if let Some((idx, offset)) = self.get_virtio_device(addr) {
            // Emulate narrow MMIO reads by extracting from the 32-bit register value
            let aligned = offset & !3;
            let word = self.virtio_devices[idx].read(aligned).map_err(|_| Trap::LoadAccessFault(addr))?;
            let shift = ((offset & 3) * 8) as u64;
            return Ok(((word >> shift) & 0xff) as u8);
        }
        
        // Unmapped VirtIO slots return 0 (allows safe probing)
        if self.is_virtio_region(addr).is_some() {
            return Ok(0);
        }

        Err(Trap::LoadAccessFault(addr))
    }
    
    #[cold]
    fn read16_slow(&self, addr: u64) -> Result<u16, Trap> {
        if addr >= TEST_FINISHER_BASE && addr < TEST_FINISHER_BASE + TEST_FINISHER_SIZE {
            return Ok(0);
        }

        if addr >= CLINT_BASE && addr < CLINT_BASE + CLINT_SIZE {
            let offset = addr - CLINT_BASE;
            let val = self.clint_load(offset, 2);
            return Ok(val as u16);
        }

        if addr >= PLIC_BASE && addr < PLIC_BASE + PLIC_SIZE {
            let offset = addr - PLIC_BASE;
            let val = self.plic.load(offset, 2).map_err(|_| Trap::LoadAccessFault(addr))?;
            return Ok(val as u16);
        }

        if addr >= UART_BASE && addr < UART_BASE + UART_SIZE {
             let offset = addr - UART_BASE;
             let val = self.uart.load(offset, 2).map_err(|_| Trap::LoadAccessFault(addr))?;
             return Ok(val as u16);
        }

        if let Some((idx, offset)) = self.get_virtio_device(addr) {
            let aligned = offset & !3;
            let word = self.virtio_devices[idx].read(aligned).map_err(|_| Trap::LoadAccessFault(addr))?;
            let shift = ((offset & 3) * 8) as u64;
            return Ok(((word >> shift) & 0xffff) as u16);
        }
        
        // Unmapped VirtIO slots return 0 (allows safe probing)
        if self.is_virtio_region(addr).is_some() {
            return Ok(0);
        }

        Err(Trap::LoadAccessFault(addr))
    }
    
    #[cold]
    fn read32_slow(&self, addr: u64) -> Result<u32, Trap> {
        if addr >= TEST_FINISHER_BASE && addr < TEST_FINISHER_BASE + TEST_FINISHER_SIZE {
            return Ok(0);
        }

        if addr >= CLINT_BASE && addr < CLINT_BASE + CLINT_SIZE {
            let offset = addr - CLINT_BASE;
            let val = self.clint_load(offset, 4);
            return Ok(val as u32);
        }

        if addr >= PLIC_BASE && addr < PLIC_BASE + PLIC_SIZE {
            let offset = addr - PLIC_BASE;
            let val = self.plic.load(offset, 4).map_err(|_| Trap::LoadAccessFault(addr))?;
            return Ok(val as u32);
        }

        if addr >= UART_BASE && addr < UART_BASE + UART_SIZE {
             let offset = addr - UART_BASE;
             let val = self.uart.load(offset, 4).map_err(|_| Trap::LoadAccessFault(addr))?;
             return Ok(val as u32);
        }

        if let Some((idx, offset)) = self.get_virtio_device(addr) {
            let val = self.virtio_devices[idx].read(offset).map_err(|_| Trap::LoadAccessFault(addr))?;
            return Ok(val as u32);
        }
        
        // Unmapped VirtIO slots return 0 (allows safe probing)
        if self.is_virtio_region(addr).is_some() {
            return Ok(0);
        }

        Err(Trap::LoadAccessFault(addr))
    }
    
    #[cold]
    fn read64_slow(&self, addr: u64) -> Result<u64, Trap> {
        if addr >= TEST_FINISHER_BASE && addr < TEST_FINISHER_BASE + TEST_FINISHER_SIZE {
            return Ok(0);
        }

        if addr >= CLINT_BASE && addr < CLINT_BASE + CLINT_SIZE {
            let offset = addr - CLINT_BASE;
            let val = self.clint_load(offset, 8);
            return Ok(val);
        }

        if addr >= PLIC_BASE && addr < PLIC_BASE + PLIC_SIZE {
            let offset = addr - PLIC_BASE;
            let val = self.plic.load(offset, 8).map_err(|_| Trap::LoadAccessFault(addr))?;
            return Ok(val);
        }

        if addr >= UART_BASE && addr < UART_BASE + UART_SIZE {
             let offset = addr - UART_BASE;
             let val = self.uart.load(offset, 8).map_err(|_| Trap::LoadAccessFault(addr))?;
             return Ok(val);
        }

        if let Some((idx, offset)) = self.get_virtio_device(addr) {
            let low = self.virtio_devices[idx].read(offset).map_err(|_| Trap::LoadAccessFault(addr))?;
            let high = self.virtio_devices[idx].read(offset + 4).map_err(|_| Trap::LoadAccessFault(addr + 4))?;
            return Ok((low as u64) | ((high as u64) << 32));
        }
        
        // Unmapped VirtIO slots return 0 (allows safe probing)
        if self.is_virtio_region(addr).is_some() {
            return Ok(0);
        }

        Err(Trap::LoadAccessFault(addr))
    }
    
    #[cold]
    fn write8_slow(&self, addr: u64, val: u8) -> Result<(), Trap> {
        // Any write in the test finisher region signals a requested trap to the host.
        if addr >= TEST_FINISHER_BASE && addr < TEST_FINISHER_BASE + TEST_FINISHER_SIZE {
            return Err(Trap::RequestedTrap(val as u64));
        }

        if addr >= CLINT_BASE && addr < CLINT_BASE + CLINT_SIZE {
            let offset = addr - CLINT_BASE;
            self.clint_store(offset, 1, val as u64);
            return Ok(());
        }

        if addr >= PLIC_BASE && addr < PLIC_BASE + PLIC_SIZE {
            let offset = addr - PLIC_BASE;
            self.plic.store(offset, 1, val as u64).map_err(|_| Trap::StoreAccessFault(addr))?;
            return Ok(());
        }

        if addr >= UART_BASE && addr < UART_BASE + UART_SIZE {
            let offset = addr - UART_BASE;
            // For workers with shared UART output, route THR writes to shared buffer
            #[cfg(target_arch = "wasm32")]
            if offset == 0 {
                // Offset 0 is THR (Transmit Holding Register) - the data output
                if let Some(ref shared_uart) = self.shared_uart_output {
                    // Write to shared buffer so main thread can read it
                    let _ = shared_uart.write_byte(val);
                    return Ok(());
                }
            }
            // Fall through to local UART for main thread or non-THR registers
            self.uart.store(offset, 1, val as u64).map_err(|_| Trap::StoreAccessFault(addr))?;
            return Ok(());
        }

        if let Some((_idx, _offset)) = self.get_virtio_device(addr) {
            // VirtIO registers are 32-bit. Byte writes are not strictly supported by the spec for all registers.
            // We ignore them for now to be safe.
            return Ok(());
        }

        Err(Trap::StoreAccessFault(addr))
    }
    
    #[cold]
    fn write16_slow(&self, addr: u64, val: u16) -> Result<(), Trap> {
        if addr >= TEST_FINISHER_BASE && addr < TEST_FINISHER_BASE + TEST_FINISHER_SIZE {
            return Err(Trap::RequestedTrap(val as u64));
        }

        if addr >= CLINT_BASE && addr < CLINT_BASE + CLINT_SIZE {
            let offset = addr - CLINT_BASE;
            self.clint_store(offset, 2, val as u64);
            return Ok(());
        }

        if addr >= PLIC_BASE && addr < PLIC_BASE + PLIC_SIZE {
            let offset = addr - PLIC_BASE;
            self.plic.store(offset, 2, val as u64).map_err(|_| Trap::StoreAccessFault(addr))?;
            return Ok(());
        }

        if addr >= UART_BASE && addr < UART_BASE + UART_SIZE {
             let offset = addr - UART_BASE;
             self.uart.store(offset, 2, val as u64).map_err(|_| Trap::StoreAccessFault(addr))?;
             return Ok(());
        }

        if let Some((_idx, _offset)) = self.get_virtio_device(addr) {
            return Ok(());
        }

        Err(Trap::StoreAccessFault(addr))
    }
    
    #[cold]
    fn write32_slow(&self, addr: u64, val: u32) -> Result<(), Trap> {
        if addr >= TEST_FINISHER_BASE && addr < TEST_FINISHER_BASE + TEST_FINISHER_SIZE {
            return Err(Trap::RequestedTrap(val as u64));
        }

        if addr >= CLINT_BASE && addr < CLINT_BASE + CLINT_SIZE {
            let offset = addr - CLINT_BASE;
            self.clint_store(offset, 4, val as u64);
            return Ok(());
        }

        if addr >= PLIC_BASE && addr < PLIC_BASE + PLIC_SIZE {
            let offset = addr - PLIC_BASE;
            self.plic.store(offset, 4, val as u64).map_err(|_| Trap::StoreAccessFault(addr))?;
            return Ok(());
        }

        if addr >= UART_BASE && addr < UART_BASE + UART_SIZE {
             let offset = addr - UART_BASE;
             self.uart.store(offset, 4, val as u64).map_err(|_| Trap::StoreAccessFault(addr))?;
             return Ok(());
        }

        if let Some((idx, offset)) = self.get_virtio_device(addr) {
            self.virtio_devices[idx].write(offset, val as u64, &self.dram)
                .map_err(|_| Trap::StoreAccessFault(addr))?;
            return Ok(());
        }
        
        // Writes to unmapped VirtIO slots are silently ignored (allows safe probing)
        if self.is_virtio_region(addr).is_some() {
            return Ok(());
        }

        Err(Trap::StoreAccessFault(addr))
    }
    
    #[cold]
    fn write64_slow(&self, addr: u64, val: u64) -> Result<(), Trap> {
        if addr >= TEST_FINISHER_BASE && addr < TEST_FINISHER_BASE + TEST_FINISHER_SIZE {
            return Err(Trap::RequestedTrap(val));
        }

        if addr >= CLINT_BASE && addr < CLINT_BASE + CLINT_SIZE {
            let offset = addr - CLINT_BASE;
            self.clint_store(offset, 8, val);
            return Ok(());
        }

        if addr >= PLIC_BASE && addr < PLIC_BASE + PLIC_SIZE {
            let offset = addr - PLIC_BASE;
            self.plic.store(offset, 8, val).map_err(|_| Trap::StoreAccessFault(addr))?;
            return Ok(());
        }

        if addr >= UART_BASE && addr < UART_BASE + UART_SIZE {
             let offset = addr - UART_BASE;
             self.uart.store(offset, 8, val).map_err(|_| Trap::StoreAccessFault(addr))?;
             return Ok(());
        }

        if let Some((_idx, _offset)) = self.get_virtio_device(addr) {
            // VirtIO registers are 32-bit. 64-bit writes are not typically supported directly via MMIO
            // except for legacy queue PFN which is 32-bit anyway.
            return Ok(());
        }
        
        // Writes to unmapped VirtIO slots are silently ignored (allows safe probing)
        if self.is_virtio_region(addr).is_some() {
            return Ok(());
        }

        Err(Trap::StoreAccessFault(addr))
    }
}

impl Bus for SystemBus {
    #[inline]
    fn poll_interrupts(&self) -> u64 {
        self.check_interrupts()
    }

    #[inline]
    fn poll_interrupts_for_hart(&self, hart_id: usize) -> u64 {
        self.check_interrupts_for_hart(hart_id)
    }

    // ========== WASM Atomic Operations ==========
    //
    // For WASM with SharedArrayBuffer, we use JavaScript Atomics API
    // to ensure proper synchronization across Web Workers.

    #[cfg(target_arch = "wasm32")]
    fn atomic_swap(&self, addr: u64, value: u64, is_word: bool) -> Result<u64, Trap> {
        if let Some(off) = self.dram.offset(addr) {
            if is_word {
                let old = self.dram.atomic_swap_32(off as u64, value as u32)
                    .map_err(|_| Trap::StoreAccessFault(addr))?;
                Ok(old as i32 as i64 as u64)
            } else {
                let old = self.dram.atomic_swap_64(off as u64, value)
                    .map_err(|_| Trap::StoreAccessFault(addr))?;
                Ok(old)
            }
        } else {
            // Non-DRAM addresses use non-atomic fallback
            if is_word {
                let old = self.read32(addr)? as i32 as i64 as u64;
                self.write32(addr, value as u32)?;
                Ok(old)
            } else {
                let old = self.read64(addr)?;
                self.write64(addr, value)?;
                Ok(old)
            }
        }
    }

    #[cfg(target_arch = "wasm32")]
    fn atomic_add(&self, addr: u64, value: u64, is_word: bool) -> Result<u64, Trap> {
        if let Some(off) = self.dram.offset(addr) {
            if is_word {
                let old = self.dram.atomic_add_32(off as u64, value as u32)
                    .map_err(|_| Trap::StoreAccessFault(addr))?;
                Ok(old as i32 as i64 as u64)
            } else {
                let old = self.dram.atomic_add_64(off as u64, value)
                    .map_err(|_| Trap::StoreAccessFault(addr))?;
                Ok(old)
            }
        } else {
            if is_word {
                let old = self.read32(addr)? as i32 as i64 as u64;
                self.write32(addr, old.wrapping_add(value) as u32)?;
                Ok(old)
            } else {
                let old = self.read64(addr)?;
                self.write64(addr, old.wrapping_add(value))?;
                Ok(old)
            }
        }
    }

    #[cfg(target_arch = "wasm32")]
    fn atomic_and(&self, addr: u64, value: u64, is_word: bool) -> Result<u64, Trap> {
        if let Some(off) = self.dram.offset(addr) {
            if is_word {
                let old = self.dram.atomic_and_32(off as u64, value as u32)
                    .map_err(|_| Trap::StoreAccessFault(addr))?;
                Ok(old as i32 as i64 as u64)
            } else {
                let old = self.dram.atomic_and_64(off as u64, value)
                    .map_err(|_| Trap::StoreAccessFault(addr))?;
                Ok(old)
            }
        } else {
            if is_word {
                let old = self.read32(addr)? as i32 as i64 as u64;
                self.write32(addr, (old & value) as u32)?;
                Ok(old)
            } else {
                let old = self.read64(addr)?;
                self.write64(addr, old & value)?;
                Ok(old)
            }
        }
    }

    #[cfg(target_arch = "wasm32")]
    fn atomic_or(&self, addr: u64, value: u64, is_word: bool) -> Result<u64, Trap> {
        if let Some(off) = self.dram.offset(addr) {
            if is_word {
                let old = self.dram.atomic_or_32(off as u64, value as u32)
                    .map_err(|_| Trap::StoreAccessFault(addr))?;
                Ok(old as i32 as i64 as u64)
            } else {
                let old = self.dram.atomic_or_64(off as u64, value)
                    .map_err(|_| Trap::StoreAccessFault(addr))?;
                Ok(old)
            }
        } else {
            if is_word {
                let old = self.read32(addr)? as i32 as i64 as u64;
                self.write32(addr, (old | value) as u32)?;
                Ok(old)
            } else {
                let old = self.read64(addr)?;
                self.write64(addr, old | value)?;
                Ok(old)
            }
        }
    }

    #[cfg(target_arch = "wasm32")]
    fn atomic_xor(&self, addr: u64, value: u64, is_word: bool) -> Result<u64, Trap> {
        if let Some(off) = self.dram.offset(addr) {
            if is_word {
                let old = self.dram.atomic_xor_32(off as u64, value as u32)
                    .map_err(|_| Trap::StoreAccessFault(addr))?;
                Ok(old as i32 as i64 as u64)
            } else {
                let old = self.dram.atomic_xor_64(off as u64, value)
                    .map_err(|_| Trap::StoreAccessFault(addr))?;
                Ok(old)
            }
        } else {
            if is_word {
                let old = self.read32(addr)? as i32 as i64 as u64;
                self.write32(addr, (old ^ value) as u32)?;
                Ok(old)
            } else {
                let old = self.read64(addr)?;
                self.write64(addr, old ^ value)?;
                Ok(old)
            }
        }
    }

    #[cfg(target_arch = "wasm32")]
    fn atomic_min(&self, addr: u64, value: u64, is_word: bool) -> Result<u64, Trap> {
        // AMOMIN doesn't have direct Atomics support, use CAS loop
        if let Some(off) = self.dram.offset(addr) {
            loop {
                let old = if is_word {
                    self.dram.atomic_load_32(off as u64)
                        .map_err(|_| Trap::LoadAccessFault(addr))? as i32 as i64 as u64
                } else {
                    self.dram.atomic_load_64(off as u64)
                        .map_err(|_| Trap::LoadAccessFault(addr))?
                };
                let new = if (old as i64) < (value as i64) { old } else { value };
                if is_word {
                    let (success, _) = self.dram.atomic_compare_exchange_32(
                        off as u64, old as u32, new as u32
                    ).map_err(|_| Trap::StoreAccessFault(addr))?;
                    if success { return Ok(old); }
                } else {
                    let (success, _) = self.dram.atomic_compare_exchange_64(
                        off as u64, old, new
                    ).map_err(|_| Trap::StoreAccessFault(addr))?;
                    if success { return Ok(old); }
                }
                std::hint::spin_loop();
            }
        } else {
            // Fallback for non-DRAM
            if is_word {
                let old = self.read32(addr)? as i32 as i64 as u64;
                let new = if (old as i64) < (value as i64) { old } else { value };
                self.write32(addr, new as u32)?;
                Ok(old)
            } else {
                let old = self.read64(addr)?;
                let new = if (old as i64) < (value as i64) { old } else { value };
                self.write64(addr, new)?;
                Ok(old)
            }
        }
    }

    #[cfg(target_arch = "wasm32")]
    fn atomic_max(&self, addr: u64, value: u64, is_word: bool) -> Result<u64, Trap> {
        if let Some(off) = self.dram.offset(addr) {
            loop {
                let old = if is_word {
                    self.dram.atomic_load_32(off as u64)
                        .map_err(|_| Trap::LoadAccessFault(addr))? as i32 as i64 as u64
                } else {
                    self.dram.atomic_load_64(off as u64)
                        .map_err(|_| Trap::LoadAccessFault(addr))?
                };
                let new = if (old as i64) > (value as i64) { old } else { value };
                if is_word {
                    let (success, _) = self.dram.atomic_compare_exchange_32(
                        off as u64, old as u32, new as u32
                    ).map_err(|_| Trap::StoreAccessFault(addr))?;
                    if success { return Ok(old); }
                } else {
                    let (success, _) = self.dram.atomic_compare_exchange_64(
                        off as u64, old, new
                    ).map_err(|_| Trap::StoreAccessFault(addr))?;
                    if success { return Ok(old); }
                }
                std::hint::spin_loop();
            }
        } else {
            if is_word {
                let old = self.read32(addr)? as i32 as i64 as u64;
                let new = if (old as i64) > (value as i64) { old } else { value };
                self.write32(addr, new as u32)?;
                Ok(old)
            } else {
                let old = self.read64(addr)?;
                let new = if (old as i64) > (value as i64) { old } else { value };
                self.write64(addr, new)?;
                Ok(old)
            }
        }
    }

    #[cfg(target_arch = "wasm32")]
    fn atomic_minu(&self, addr: u64, value: u64, is_word: bool) -> Result<u64, Trap> {
        if let Some(off) = self.dram.offset(addr) {
            loop {
                let old = if is_word {
                    self.dram.atomic_load_32(off as u64)
                        .map_err(|_| Trap::LoadAccessFault(addr))? as u64
                } else {
                    self.dram.atomic_load_64(off as u64)
                        .map_err(|_| Trap::LoadAccessFault(addr))?
                };
                let cmp_old = if is_word { old as u32 as u64 } else { old };
                let cmp_val = if is_word { value as u32 as u64 } else { value };
                let new = if cmp_old < cmp_val { old } else { value };
                if is_word {
                    let (success, _) = self.dram.atomic_compare_exchange_32(
                        off as u64, old as u32, new as u32
                    ).map_err(|_| Trap::StoreAccessFault(addr))?;
                    if success { return Ok(old as i32 as i64 as u64); }
                } else {
                    let (success, _) = self.dram.atomic_compare_exchange_64(
                        off as u64, old, new
                    ).map_err(|_| Trap::StoreAccessFault(addr))?;
                    if success { return Ok(old); }
                }
                std::hint::spin_loop();
            }
        } else {
            if is_word {
                let old = self.read32(addr)? as u32 as u64;
                let new = if old < (value as u32 as u64) { old } else { value };
                self.write32(addr, new as u32)?;
                Ok(old as i32 as i64 as u64)
            } else {
                let old = self.read64(addr)?;
                let new = if old < value { old } else { value };
                self.write64(addr, new)?;
                Ok(old)
            }
        }
    }

    #[cfg(target_arch = "wasm32")]
    fn atomic_maxu(&self, addr: u64, value: u64, is_word: bool) -> Result<u64, Trap> {
        if let Some(off) = self.dram.offset(addr) {
            loop {
                let old = if is_word {
                    self.dram.atomic_load_32(off as u64)
                        .map_err(|_| Trap::LoadAccessFault(addr))? as u64
                } else {
                    self.dram.atomic_load_64(off as u64)
                        .map_err(|_| Trap::LoadAccessFault(addr))?
                };
                let cmp_old = if is_word { old as u32 as u64 } else { old };
                let cmp_val = if is_word { value as u32 as u64 } else { value };
                let new = if cmp_old > cmp_val { old } else { value };
                if is_word {
                    let (success, _) = self.dram.atomic_compare_exchange_32(
                        off as u64, old as u32, new as u32
                    ).map_err(|_| Trap::StoreAccessFault(addr))?;
                    if success { return Ok(old as i32 as i64 as u64); }
                } else {
                    let (success, _) = self.dram.atomic_compare_exchange_64(
                        off as u64, old, new
                    ).map_err(|_| Trap::StoreAccessFault(addr))?;
                    if success { return Ok(old); }
                }
                std::hint::spin_loop();
            }
        } else {
            if is_word {
                let old = self.read32(addr)? as u32 as u64;
                let new = if old > (value as u32 as u64) { old } else { value };
                self.write32(addr, new as u32)?;
                Ok(old as i32 as i64 as u64)
            } else {
                let old = self.read64(addr)?;
                let new = if old > value { old } else { value };
                self.write64(addr, new)?;
                Ok(old)
            }
        }
    }

    #[cfg(target_arch = "wasm32")]
    fn atomic_compare_exchange(
        &self,
        addr: u64,
        expected: u64,
        new_value: u64,
        is_word: bool,
    ) -> Result<(bool, u64), Trap> {
        if let Some(off) = self.dram.offset(addr) {
            if is_word {
                let (success, old) = self.dram.atomic_compare_exchange_32(
                    off as u64, expected as u32, new_value as u32
                ).map_err(|_| Trap::StoreAccessFault(addr))?;
                Ok((success, old as i32 as i64 as u64))
            } else {
                let (success, old) = self.dram.atomic_compare_exchange_64(
                    off as u64, expected, new_value
                ).map_err(|_| Trap::StoreAccessFault(addr))?;
                Ok((success, old))
            }
        } else {
            // Fallback for non-DRAM
            if is_word {
                let old = self.read32(addr)? as u32;
                if old == expected as u32 {
                    self.write32(addr, new_value as u32)?;
                    Ok((true, old as i32 as i64 as u64))
                } else {
                    Ok((false, old as i32 as i64 as u64))
                }
            } else {
                let old = self.read64(addr)?;
                if old == expected {
                    self.write64(addr, new_value)?;
                    Ok((true, old))
                } else {
                    Ok((false, old))
                }
            }
        }
    }

    // ========== Native Atomic Operations ==========
    //
    // For native builds, we use a global lock to ensure atomicity of AMO operations.
    // This is simpler than per-address locking and correct for RISC-V semantics.

    #[cfg(not(target_arch = "wasm32"))]
    fn atomic_swap(&self, addr: u64, value: u64, is_word: bool) -> Result<u64, Trap> {
        let _guard = AMO_LOCK.lock().unwrap();
        if is_word {
            let old = self.read32(addr)? as i32 as i64 as u64;
            self.write32(addr, value as u32)?;
            Ok(old)
        } else {
            let old = self.read64(addr)?;
            self.write64(addr, value)?;
            Ok(old)
        }
    }

    #[cfg(not(target_arch = "wasm32"))]
    fn atomic_add(&self, addr: u64, value: u64, is_word: bool) -> Result<u64, Trap> {
        let _guard = AMO_LOCK.lock().unwrap();
        if is_word {
            let old = self.read32(addr)? as i32 as i64 as u64;
            self.write32(addr, old.wrapping_add(value) as u32)?;
            Ok(old)
        } else {
            let old = self.read64(addr)?;
            self.write64(addr, old.wrapping_add(value))?;
            Ok(old)
        }
    }

    #[cfg(not(target_arch = "wasm32"))]
    fn atomic_and(&self, addr: u64, value: u64, is_word: bool) -> Result<u64, Trap> {
        let _guard = AMO_LOCK.lock().unwrap();
        if is_word {
            let old = self.read32(addr)? as i32 as i64 as u64;
            self.write32(addr, (old & value) as u32)?;
            Ok(old)
        } else {
            let old = self.read64(addr)?;
            self.write64(addr, old & value)?;
            Ok(old)
        }
    }

    #[cfg(not(target_arch = "wasm32"))]
    fn atomic_or(&self, addr: u64, value: u64, is_word: bool) -> Result<u64, Trap> {
        let _guard = AMO_LOCK.lock().unwrap();
        if is_word {
            let old = self.read32(addr)? as i32 as i64 as u64;
            self.write32(addr, (old | value) as u32)?;
            Ok(old)
        } else {
            let old = self.read64(addr)?;
            self.write64(addr, old | value)?;
            Ok(old)
        }
    }

    #[cfg(not(target_arch = "wasm32"))]
    fn atomic_xor(&self, addr: u64, value: u64, is_word: bool) -> Result<u64, Trap> {
        let _guard = AMO_LOCK.lock().unwrap();
        if is_word {
            let old = self.read32(addr)? as i32 as i64 as u64;
            self.write32(addr, (old ^ value) as u32)?;
            Ok(old)
        } else {
            let old = self.read64(addr)?;
            self.write64(addr, old ^ value)?;
            Ok(old)
        }
    }

    #[cfg(not(target_arch = "wasm32"))]
    fn atomic_min(&self, addr: u64, value: u64, is_word: bool) -> Result<u64, Trap> {
        let _guard = AMO_LOCK.lock().unwrap();
        if is_word {
            let old = self.read32(addr)? as i32 as i64 as u64;
            let new = if (old as i64) < (value as i64) { old } else { value };
            self.write32(addr, new as u32)?;
            Ok(old)
        } else {
            let old = self.read64(addr)?;
            let new = if (old as i64) < (value as i64) { old } else { value };
            self.write64(addr, new)?;
            Ok(old)
        }
    }

    #[cfg(not(target_arch = "wasm32"))]
    fn atomic_max(&self, addr: u64, value: u64, is_word: bool) -> Result<u64, Trap> {
        let _guard = AMO_LOCK.lock().unwrap();
        if is_word {
            let old = self.read32(addr)? as i32 as i64 as u64;
            let new = if (old as i64) > (value as i64) { old } else { value };
            self.write32(addr, new as u32)?;
            Ok(old)
        } else {
            let old = self.read64(addr)?;
            let new = if (old as i64) > (value as i64) { old } else { value };
            self.write64(addr, new)?;
            Ok(old)
        }
    }

    #[cfg(not(target_arch = "wasm32"))]
    fn atomic_minu(&self, addr: u64, value: u64, is_word: bool) -> Result<u64, Trap> {
        let _guard = AMO_LOCK.lock().unwrap();
        if is_word {
            let old = self.read32(addr)? as u32 as u64;
            let new = if old < (value as u32 as u64) { old } else { value };
            self.write32(addr, new as u32)?;
            Ok(old as i32 as i64 as u64)
        } else {
            let old = self.read64(addr)?;
            let new = if old < value { old } else { value };
            self.write64(addr, new)?;
            Ok(old)
        }
    }

    #[cfg(not(target_arch = "wasm32"))]
    fn atomic_maxu(&self, addr: u64, value: u64, is_word: bool) -> Result<u64, Trap> {
        let _guard = AMO_LOCK.lock().unwrap();
        if is_word {
            let old = self.read32(addr)? as u32 as u64;
            let new = if old > (value as u32 as u64) { old } else { value };
            self.write32(addr, new as u32)?;
            Ok(old as i32 as i64 as u64)
        } else {
            let old = self.read64(addr)?;
            let new = if old > value { old } else { value };
            self.write64(addr, new)?;
            Ok(old)
        }
    }

    #[cfg(not(target_arch = "wasm32"))]
    fn atomic_compare_exchange(
        &self,
        addr: u64,
        expected: u64,
        new_value: u64,
        is_word: bool,
    ) -> Result<(bool, u64), Trap> {
        let _guard = AMO_LOCK.lock().unwrap();
        if is_word {
            let old = self.read32(addr)? as u32;
            if old == expected as u32 {
                self.write32(addr, new_value as u32)?;
                Ok((true, old as i32 as i64 as u64))
            } else {
                Ok((false, old as i32 as i64 as u64))
            }
        } else {
            let old = self.read64(addr)?;
            if old == expected {
                self.write64(addr, new_value)?;
                Ok((true, old))
            } else {
                Ok((false, old))
            }
        }
    }

    #[inline(always)]
    fn read8(&self, addr: u64) -> Result<u8, Trap> {
        // Fast path: DRAM access (most common case)
        if let Some(off) = self.dram.offset(addr) {
            return self.dram.load_8(off as u64).map_err(|_| Trap::LoadAccessFault(addr));
        }
        // Slow path: MMIO devices
        self.read8_slow(addr)
    }

    #[inline(always)]
    fn read16(&self, addr: u64) -> Result<u16, Trap> {
        if addr % 2 != 0 {
            return Err(Trap::LoadAddressMisaligned(addr));
        }
        // Fast path: DRAM access (most common case)
        if let Some(off) = self.dram.offset(addr) {
            return self.dram.load_16(off as u64).map_err(|_| Trap::LoadAccessFault(addr));
        }
        // Slow path: MMIO devices
        self.read16_slow(addr)
    }

    #[inline(always)]
    fn read32(&self, addr: u64) -> Result<u32, Trap> {
        if addr % 4 != 0 {
            return Err(Trap::LoadAddressMisaligned(addr));
        }
        // Fast path: DRAM access (most common case)
        if let Some(off) = self.dram.offset(addr) {
            return self.dram.load_32(off as u64).map_err(|_| Trap::LoadAccessFault(addr));
        }
        // Slow path: MMIO devices
        self.read32_slow(addr)
    }

    #[inline(always)]
    fn read64(&self, addr: u64) -> Result<u64, Trap> {
        if addr % 8 != 0 {
            return Err(Trap::LoadAddressMisaligned(addr));
        }
        // Fast path: DRAM access (most common case)
        if let Some(off) = self.dram.offset(addr) {
            return self.dram.load_64(off as u64).map_err(|_| Trap::LoadAccessFault(addr));
        }
        // Slow path: MMIO devices
        self.read64_slow(addr)
    }

    #[inline(always)]
    fn write8(&self, addr: u64, val: u8) -> Result<(), Trap> {
        // Fast path: DRAM access (most common case)
        if let Some(off) = self.dram.offset(addr) {
            return self.dram.store_8(off as u64, val as u64).map_err(|_| Trap::StoreAccessFault(addr));
        }
        // Slow path: MMIO devices
        self.write8_slow(addr, val)
    }

    #[inline(always)]
    fn write16(&self, addr: u64, val: u16) -> Result<(), Trap> {
        if addr % 2 != 0 {
            return Err(Trap::StoreAddressMisaligned(addr));
        }
        // Fast path: DRAM access (most common case)
        if let Some(off) = self.dram.offset(addr) {
            return self.dram.store_16(off as u64, val as u64).map_err(|_| Trap::StoreAccessFault(addr));
        }
        // Slow path: MMIO devices
        self.write16_slow(addr, val)
    }

    #[inline(always)]
    fn write32(&self, addr: u64, val: u32) -> Result<(), Trap> {
        if addr % 4 != 0 {
            return Err(Trap::StoreAddressMisaligned(addr));
        }
        // Fast path: DRAM access (most common case)
        if let Some(off) = self.dram.offset(addr) {
            return self.dram.store_32(off as u64, val as u64).map_err(|_| Trap::StoreAccessFault(addr));
        }
        // Slow path: MMIO devices
        self.write32_slow(addr, val)
    }

    #[inline(always)]
    fn write64(&self, addr: u64, val: u64) -> Result<(), Trap> {
        if addr % 8 != 0 {
            return Err(Trap::StoreAddressMisaligned(addr));
        }
        // Fast path: DRAM access (most common case)
        if let Some(off) = self.dram.offset(addr) {
            return self.dram.store_64(off as u64, val).map_err(|_| Trap::StoreAccessFault(addr));
        }
        // Slow path: MMIO devices
        self.write64_slow(addr, val)
    }
}
</file>

<file path="riscv-vm/src/net_webtransport.rs">
//! WebTransport network backend with P2P relay protocol support.
//!
//! This backend tunnels Ethernet frames over WebTransport DATAGRAMs
//! using the relay protocol:
//! - 0x00 prefix: Control messages (JSON-encoded)
//! - 0x01 prefix: Ethernet data frames

use crate::net::NetworkBackend;

/// Message type prefix for control messages
const MSG_TYPE_CONTROL: u8 = 0x00;
/// Message type prefix for Ethernet data frames
const MSG_TYPE_DATA: u8 = 0x01;

/// Heartbeat interval in seconds (reduced for better keepalive in browsers)
const HEARTBEAT_INTERVAL_SECS: u64 = 15;

/// QUIC keep-alive interval in seconds.
/// Client sends QUIC PING frames at this interval to keep the connection alive.
const QUIC_KEEP_ALIVE_SECS: u64 = 10;

/// Control message for registration
fn make_register_message(mac: &[u8; 6]) -> Vec<u8> {
    let json = format!(
        r#"{{"type":"Register","mac":[{},{},{},{},{},{}]}}"#,
        mac[0], mac[1], mac[2], mac[3], mac[4], mac[5]
    );
    let mut msg = Vec::with_capacity(1 + json.len());
    msg.push(MSG_TYPE_CONTROL);
    msg.extend(json.bytes());
    msg
}

/// Control message for heartbeat
fn make_heartbeat_message() -> Vec<u8> {
    let json = r#"{"type":"Heartbeat"}"#;
    let mut msg = Vec::with_capacity(1 + json.len());
    msg.push(MSG_TYPE_CONTROL);
    msg.extend(json.bytes());
    msg
}

/// Encode an Ethernet frame with the data prefix
fn encode_data_frame(ethernet_frame: &[u8]) -> Vec<u8> {
    let mut frame = Vec::with_capacity(1 + ethernet_frame.len());
    frame.push(MSG_TYPE_DATA);
    frame.extend(ethernet_frame);
    frame
}

/// Decode a received message, stripping the type prefix for data frames
fn decode_message(data: &[u8]) -> Option<Vec<u8>> {
    if data.is_empty() {
        return None;
    }
    
    match data[0] {
        MSG_TYPE_DATA => {
            // Return the Ethernet frame without the prefix
            Some(data[1..].to_vec())
        }
        MSG_TYPE_CONTROL => {
            // Control messages are handled internally, not passed to the VM
            // Log assigned IP if present
            if let Ok(json_str) = std::str::from_utf8(&data[1..]) {
                if json_str.contains("\"type\":\"Assigned\"") {
                    log::info!("[WebTransport] Received IP assignment: {}", json_str);
                } else if json_str.contains("\"type\":\"HeartbeatAck\"") {
                    log::trace!("[WebTransport] Heartbeat acknowledged");
                } else if json_str.contains("\"type\":\"Error\"") {
                    log::error!("[WebTransport] Error from relay: {}", json_str);
                }
            }
            None
        }
        _ => {
            log::warn!("[WebTransport] Unknown message type: {}", data[0]);
            None
        }
    }
}

/// Parse IP address from JSON string containing "ip":[a,b,c,d]
fn parse_ip_from_json(json_str: &str) -> Option<[u8; 4]> {
    // Look for "ip":[ pattern
    let start_marker = "\"ip\":[";
    if let Some(start) = json_str.find(start_marker) {
        let rest = &json_str[start + start_marker.len()..];
        if let Some(end) = rest.find(']') {
            let ip_str = &rest[..end]; // e.g. "10,0,2,15"
            let parts: Vec<&str> = ip_str.split(',').collect();
            if parts.len() == 4 {
                let b0 = parts[0].trim().parse().ok()?;
                let b1 = parts[1].trim().parse().ok()?;
                let b2 = parts[2].trim().parse().ok()?;
                let b3 = parts[3].trim().parse().ok()?;
                return Some([b0, b1, b2, b3]);
            }
        }
    }
    None
}

#[cfg(not(target_arch = "wasm32"))]
mod native {
    use super::*;
    use std::sync::Arc;
    use std::sync::atomic::{AtomicBool, AtomicU32, Ordering};
    use std::sync::mpsc::{channel, Receiver, Sender, TryRecvError};
    use std::sync::Mutex;
    use std::thread;
    use std::time::Duration;
    use tokio::runtime::Runtime;
    use wtransport::tls::Sha256Digest;
    use wtransport::ClientConfig;
    use wtransport::Endpoint;

    /// Maximum reconnection delay in seconds
    const MAX_RECONNECT_DELAY_SECS: u64 = 30;
    /// Initial reconnection delay in seconds
    const INITIAL_RECONNECT_DELAY_SECS: u64 = 2;

    pub struct WebTransportBackend {
        tx_to_transport: Option<Sender<Vec<u8>>>,
        rx_from_transport: Option<Receiver<Vec<u8>>>,
        mac: [u8; 6],
        registered: Arc<AtomicBool>,
        /// IP address assigned by the relay server
        assigned_ip: Arc<Mutex<Option<[u8; 4]>>>,
        /// Connection attempt counter (for debugging)
        connection_attempts: Arc<AtomicU32>,
    }

    impl WebTransportBackend {
        pub fn new(url: &str, cert_hash: Option<String>) -> Self {
            log::warn!("[WebTransport] Creating backend for URL: {}", url);
            
            // Generate a random MAC address (locally administered, unicast)
            // Use system time + process id for randomness
            let now = std::time::SystemTime::now()
                .duration_since(std::time::UNIX_EPOCH)
                .unwrap_or_default();
            let nanos = now.as_nanos() as u64;
            let pid = std::process::id() as u64;
            
            // Mix in URL hash for additional entropy
            let url_hash: u64 = url
                .bytes()
                .fold(0u64, |acc, b| acc.wrapping_mul(31).wrapping_add(b as u64));
            
            // Combine all sources of entropy
            let seed = nanos ^ (pid << 32) ^ url_hash;
            
            let mut mac = [0x52, 0x54, 0x00, 0x00, 0x00, 0x00];
            // Set locally administered bit (0x02) and clear multicast bit (0x01)
            mac[0] = 0x52; // Already has locally administered bit set
            mac[1] = 0x54;
            mac[2] = ((seed >> 40) & 0xff) as u8;
            mac[3] = ((seed >> 32) & 0xff) as u8;
            mac[4] = ((seed >> 16) & 0xff) as u8;
            mac[5] = (seed & 0xff) as u8;

            let (tx_to_transport, rx_to_transport) = channel::<Vec<u8>>();
            let (tx_from_transport, rx_from_transport) = channel::<Vec<u8>>();

            let url = url.to_string();
            let mac_copy = mac;
            let registered = Arc::new(AtomicBool::new(false));
            let registered_clone = registered.clone();
            let assigned_ip = Arc::new(Mutex::new(None));
            let assigned_ip_clone = assigned_ip.clone();
            let connection_attempts = Arc::new(AtomicU32::new(0));
            let connection_attempts_clone = connection_attempts.clone();

            thread::spawn(move || {
                let rt = Runtime::new().unwrap();
                rt.block_on(async move {
                    // Parse cert hash once outside the reconnection loop
                    let cert_digest = if let Some(hash_str) = &cert_hash {
                        log::warn!("[WebTransport] Using certificate hash: {}", hash_str);
                        let bytes = match hex::decode(hash_str.replace(":", "")) {
                            Ok(b) => b,
                            Err(e) => {
                                log::warn!("[WebTransport] ERROR: Invalid hex hash: {}", e);
                                return;
                            }
                        };
                        let bytes_len = bytes.len();
                        let array: [u8; 32] = match bytes.try_into() {
                            Ok(a) => a,
                            Err(_) => {
                                log::warn!("[WebTransport] ERROR: Hash must be 32 bytes, got {} bytes", bytes_len);
                                return;
                            }
                        };
                        Some(Sha256Digest::from(array))
                    } else {
                        log::warn!("[WebTransport] WARNING: No certificate hash provided, disabling cert validation");
                        None
                    };
                    
                    log::warn!("[WebTransport] QUIC keep-alive interval: {}s", QUIC_KEEP_ALIVE_SECS);

                    // Reconnection loop - keeps trying to connect/reconnect forever
                    let mut reconnect_delay = INITIAL_RECONNECT_DELAY_SECS;
                    
                    loop {
                        let attempt = connection_attempts_clone.fetch_add(1, Ordering::SeqCst) + 1;
                        
                        if attempt > 1 {
                            log::warn!("[WebTransport] Reconnection attempt {} (delay was {}s)...", attempt, reconnect_delay);
                        } else {
                            log::warn!("[WebTransport] Starting connection to {}...", url);
                        }
                        
                        // Reset registered state on reconnection
                        registered_clone.store(false, Ordering::SeqCst);
                        
                        // Build config for this connection attempt
                        let config = if let Some(ref digest) = cert_digest {
                            ClientConfig::builder()
                                .with_bind_default()
                                .with_server_certificate_hashes(vec![digest.clone()])
                                .keep_alive_interval(Some(Duration::from_secs(QUIC_KEEP_ALIVE_SECS)))
                                .build()
                        } else {
                            ClientConfig::builder()
                                .with_bind_default()
                                .with_no_cert_validation()
                                .keep_alive_interval(Some(Duration::from_secs(QUIC_KEEP_ALIVE_SECS)))
                                .build()
                        };

                        let endpoint = match Endpoint::client(config) {
                            Ok(ep) => ep,
                            Err(e) => {
                                log::warn!("[WebTransport] ERROR: Failed to provision endpoint: {}", e);
                                tokio::time::sleep(Duration::from_secs(reconnect_delay)).await;
                                reconnect_delay = (reconnect_delay * 2).min(MAX_RECONNECT_DELAY_SECS);
                                continue;
                            }
                        };

                        log::warn!("[WebTransport] Connecting to {}...", url);
                        let connection = match endpoint.connect(&url).await {
                            Ok(conn) => {
                                // Reset delay on successful connection
                                reconnect_delay = INITIAL_RECONNECT_DELAY_SECS;
                                conn
                            }
                            Err(e) => {
                                log::warn!("[WebTransport] ERROR: Connection failed: {}", e);
                                log::error!("[WebTransport] Connection failed: {}", e);
                                tokio::time::sleep(Duration::from_secs(reconnect_delay)).await;
                                reconnect_delay = (reconnect_delay * 2).min(MAX_RECONNECT_DELAY_SECS);
                                continue;
                            }
                        };
                        log::warn!("[WebTransport] Connected successfully!");

                        // Send registration message
                        let register_msg = make_register_message(&mac_copy);
                        if let Err(e) = connection.send_datagram(register_msg) {
                            log::warn!("[WebTransport] ERROR: Failed to send registration: {}", e);
                            tokio::time::sleep(Duration::from_secs(reconnect_delay)).await;
                            reconnect_delay = (reconnect_delay * 2).min(MAX_RECONNECT_DELAY_SECS);
                            continue;
                        }
                        log::warn!("[WebTransport] Registration sent, MAC: {:02x}:{:02x}:{:02x}:{:02x}:{:02x}:{:02x}",
                            mac_copy[0], mac_copy[1], mac_copy[2], mac_copy[3], mac_copy[4], mac_copy[5]);

                        let connection = Arc::new(connection);
                        
                        // Run sender/receiver/heartbeat in a combined loop using select!
                        // This avoids issues with sharing channels across tasks
                        let mut heartbeat_interval = tokio::time::interval(Duration::from_secs(HEARTBEAT_INTERVAL_SECS));
                        let mut send_check_interval = tokio::time::interval(Duration::from_millis(1));
                        
                        'connection_loop: loop {
                            tokio::select! {
                                // Check for data to send to relay
                                _ = send_check_interval.tick() => {
                                    // Drain all pending sends
                                    loop {
                                        match rx_to_transport.try_recv() {
                                            Ok(data) => {
                                                if let Err(e) = connection.send_datagram(data) {
                                                    log::error!("Failed to send datagram: {}", e);
                                                    break 'connection_loop;
                                                }
                                            }
                                            Err(TryRecvError::Empty) => break,
                                            Err(TryRecvError::Disconnected) => {
                                                log::warn!("[WebTransport] TX channel disconnected, shutting down");
                                                return; // Permanent shutdown
                                            }
                                        }
                                    }
                                }
                                
                                // Send periodic heartbeats
                                _ = heartbeat_interval.tick() => {
                                    let heartbeat = make_heartbeat_message();
                                    if let Err(e) = connection.send_datagram(heartbeat) {
                                        log::warn!("[WebTransport] Failed to send heartbeat: {}", e);
                                        break 'connection_loop;
                                    }
                                    log::trace!("[WebTransport] Heartbeat sent");
                                }
                                
                                // Receive data from relay
                                result = connection.receive_datagram() => {
                                    match result {
                                        Ok(datagram) => {
                                            let data = datagram.to_vec();
                                            
                                            // Check for Assigned message to confirm registration and extract IP
                                            if !data.is_empty() && data[0] == MSG_TYPE_CONTROL {
                                                if let Ok(json_str) = std::str::from_utf8(&data[1..]) {
                                                    if json_str.contains("\"type\":\"Assigned\"") {
                                                        registered_clone.store(true, Ordering::SeqCst);
                                                        
                                                        // Parse IP from JSON: {"type":"Assigned","ip":[10,0,2,X],...}
                                                        if let Some(ip) = parse_ip_from_json(json_str) {
                                                            if let Ok(mut guard) = assigned_ip_clone.lock() {
                                                                *guard = Some(ip);
                                                            }
                                                            log::warn!("[WebTransport] IP Assigned: {}.{}.{}.{}", 
                                                                ip[0], ip[1], ip[2], ip[3]);
                                                        }
                                                        
                                                        log::warn!("[WebTransport] Registered with relay: {}", json_str);
                                                    }
                                                }
                                            }
                                            
                                            // Decode and forward Ethernet frames
                                            if let Some(ethernet_frame) = decode_message(&data) {
                                                let _ = tx_from_transport.send(ethernet_frame);
                                            }
                                        }
                                        Err(e) => {
                                            log::warn!("[WebTransport] Connection lost: {}", e);
                                            log::error!("[WebTransport] Receive error: {}", e);
                                            break 'connection_loop;
                                        }
                                    }
                                }
                            }
                        }
                        
                        // Connection lost, wait before reconnecting
                        log::warn!("[WebTransport] Scheduling reconnection in {}s...", reconnect_delay);
                        tokio::time::sleep(Duration::from_secs(reconnect_delay)).await;
                        reconnect_delay = (reconnect_delay * 2).min(MAX_RECONNECT_DELAY_SECS);
                    }
                });
            });

            Self {
                tx_to_transport: Some(tx_to_transport),
                rx_from_transport: Some(rx_from_transport),
                mac,
                registered,
                assigned_ip,
                connection_attempts,
            }
        }

        /// Check if registered with the relay
        pub fn is_registered(&self) -> bool {
            self.registered.load(Ordering::SeqCst)
        }
    }

    impl NetworkBackend for WebTransportBackend {
        fn init(&mut self) -> Result<(), String> {
            Ok(())
        }

        fn recv(&mut self) -> Result<Option<Vec<u8>>, String> {
            if let Some(rx) = &self.rx_from_transport {
                match rx.try_recv() {
                    Ok(data) => Ok(Some(data)),
                    Err(std::sync::mpsc::TryRecvError::Empty) => Ok(None),
                    Err(_) => Err("Disconnected".to_string()),
                }
            } else {
                Ok(None)
            }
        }

        fn send(&self, buf: &[u8]) -> Result<(), String> {
            if let Some(tx) = &self.tx_to_transport {
                // Frame the Ethernet data with the protocol prefix
                let framed = encode_data_frame(buf);
                tx.send(framed).map_err(|e| e.to_string())?;
                Ok(())
            } else {
                Err("Not connected".to_string())
            }
        }

        fn mac_address(&self) -> [u8; 6] {
            self.mac
        }
        
        fn get_assigned_ip(&self) -> Option<[u8; 4]> {
            if let Ok(guard) = self.assigned_ip.lock() {
                *guard
            } else {
                None
            }
        }
    }
}

#[cfg(target_arch = "wasm32")]
mod wasm {
    use super::*;
    use js_sys::{Array, Uint8Array};
    use std::cell::RefCell;
    use std::collections::VecDeque;
    use std::rc::Rc;
    use wasm_bindgen::prelude::*;
    use wasm_bindgen::JsCast;
    use wasm_bindgen_futures::JsFuture;
    use web_sys::{
        ReadableStreamDefaultReader, WebTransport, WebTransportHash, WebTransportOptions,
        WritableStreamDefaultWriter,
    };

    /// Connection state for tracking and reconnection
    #[derive(Clone, Copy, PartialEq, Debug)]
    enum ConnectionState {
        Disconnected,
        Connecting,
        Connected,
    }

    /// Shared state between the backend and async tasks
    struct SharedState {
        rx_queue: VecDeque<Vec<u8>>,
        registered: bool,
        assigned_ip: Option<[u8; 4]>,
        connection_state: ConnectionState,
        /// Counter incremented on each reconnect to invalidate old tasks
        connection_generation: u32,
        /// Heartbeat interval ID for cleanup
        heartbeat_interval_id: Option<i32>,
    }

    pub struct WebTransportBackend {
        url: String,
        cert_hash: Option<String>,
        mac: [u8; 6],
        transport: Rc<RefCell<Option<WebTransport>>>,
        writer: Rc<RefCell<Option<WritableStreamDefaultWriter>>>,
        state: Rc<RefCell<SharedState>>,
    }

    // WASM is single threaded
    unsafe impl Send for WebTransportBackend {}

    impl WebTransportBackend {
        pub fn new(url: &str, cert_hash: Option<String>) -> Self {
            // Generate a random MAC address using JS Math.random()
            // This ensures each browser tab/VM instance gets a unique MAC
            let rand1 = (js_sys::Math::random() * 0xFFFFFFFFu32 as f64) as u32;
            let rand2 = (js_sys::Math::random() * 0xFFFFu32 as f64) as u32;
            
            let mut mac = [0x52, 0x54, 0x00, 0x00, 0x00, 0x00];
            // Set locally administered bit (0x02) and clear multicast bit (0x01)
            mac[0] = 0x52; // Already has locally administered bit set
            mac[1] = 0x54;
            mac[2] = ((rand1 >> 24) & 0xff) as u8;
            mac[3] = ((rand1 >> 16) & 0xff) as u8;
            mac[4] = ((rand1 >> 8) & 0xff) as u8;
            mac[5] = (rand2 & 0xff) as u8;

            let state = Rc::new(RefCell::new(SharedState {
                rx_queue: VecDeque::new(),
                registered: false,
                assigned_ip: None,
                connection_state: ConnectionState::Disconnected,
                connection_generation: 0,
                heartbeat_interval_id: None,
            }));

            Self {
                url: url.to_string(),
                cert_hash,
                mac,
                transport: Rc::new(RefCell::new(None)),
                writer: Rc::new(RefCell::new(None)),
                state,
            }
        }

        /// Check if registered with the relay
        pub fn is_registered(&self) -> bool {
            self.state.borrow().registered
        }
        
        /// Check if connected
        pub fn is_connected(&self) -> bool {
            self.state.borrow().connection_state == ConnectionState::Connected
        }
        
        /// Start the connection process
        fn start_connection(&self) {
            let url = self.url.clone();
            let cert_hash = self.cert_hash.clone();
            let mac = self.mac;
            let state = self.state.clone();
            let transport_rc = self.transport.clone();
            let writer_rc = self.writer.clone();
            
            // Increment generation and mark as connecting
            {
                let mut s = state.borrow_mut();
                s.connection_generation += 1;
                s.connection_state = ConnectionState::Connecting;
                s.registered = false;
                // Clear old heartbeat interval
                if let Some(id) = s.heartbeat_interval_id.take() {
                    clear_interval(id);
                }
            }
            let generation = state.borrow().connection_generation;
            
            console_log(&format!("[WebTransport] Starting connection (gen={}) to {}", generation, url));
            
            wasm_bindgen_futures::spawn_local(async move {
                // Check if this connection attempt is still valid
                if state.borrow().connection_generation != generation {
                    console_log("[WebTransport] Connection attempt superseded, aborting");
                    return;
                }
                
                let options = WebTransportOptions::new();

                if let Some(hash_hex) = &cert_hash {
                    match hex::decode(hash_hex.replace(":", "")) {
                        Ok(bytes) => {
                            let array = Uint8Array::from(&bytes[..]);
                            let hash_obj = WebTransportHash::new();
                            hash_obj.set_algorithm("sha-256");
                            hash_obj.set_value(&array);
                            let hashes = Array::new();
                            hashes.push(&hash_obj);
                            options.set_server_certificate_hashes(&hashes);
                        }
                        Err(e) => {
                            console_error(&format!("[WebTransport] Invalid cert hash: {}", e));
                            state.borrow_mut().connection_state = ConnectionState::Disconnected;
                            return;
                        }
                    }
                }

                let transport = match WebTransport::new_with_options(&url, &options) {
                    Ok(t) => t,
                    Err(e) => {
                        console_error(&format!("[WebTransport] Failed to create transport: {:?}", e));
                        state.borrow_mut().connection_state = ConnectionState::Disconnected;
                        // Schedule reconnection
                        schedule_reconnect(state.clone(), transport_rc.clone(), writer_rc.clone(), 
                                         url.clone(), cert_hash.clone(), mac, 5000);
                        return;
                    }
                };

                let datagrams = transport.datagrams();
                let writable = datagrams.writable();
                let writer = match writable.get_writer() {
                    Ok(w) => w,
                    Err(e) => {
                        console_error(&format!("[WebTransport] Failed to get writer: {:?}", e));
                        state.borrow_mut().connection_state = ConnectionState::Disconnected;
                        schedule_reconnect(state.clone(), transport_rc.clone(), writer_rc.clone(),
                                         url.clone(), cert_hash.clone(), mac, 5000);
                        return;
                    }
                };

                let ready_promise = transport.ready();
                
                match JsFuture::from(ready_promise).await {
                    Ok(_) => {
                        // Check generation again
                        if state.borrow().connection_generation != generation {
                            console_log("[WebTransport] Connection superseded during handshake");
                            return;
                        }
                        
                        console_log("[WebTransport] Connected successfully!");
                        
                        // Send registration
                        let register_msg = make_register_message(&mac);
                        let array = Uint8Array::from(&register_msg[..]);
                        if let Err(e) = JsFuture::from(writer.write_with_chunk(&array)).await {
                            console_error(&format!("[WebTransport] Failed to register: {:?}", e));
                            state.borrow_mut().connection_state = ConnectionState::Disconnected;
                            schedule_reconnect(state.clone(), transport_rc.clone(), writer_rc.clone(),
                                             url.clone(), cert_hash.clone(), mac, 5000);
                            return;
                        }
                        
                        console_log(&format!(
                            "[WebTransport] Registration sent, MAC: {:02x}:{:02x}:{:02x}:{:02x}:{:02x}:{:02x}",
                            mac[0], mac[1], mac[2], mac[3], mac[4], mac[5]
                        ));
                        
                        // Store transport and writer
                        *transport_rc.borrow_mut() = Some(transport.clone());
                        *writer_rc.borrow_mut() = Some(writer.clone());
                        
                        // Setup heartbeat with visibility-aware interval
                        let writer_hb = writer.clone();
                        let state_hb = state.clone();
                        let generation_hb = generation;
                        
                        let heartbeat_closure = Closure::wrap(Box::new(move || {
                            // Only send if still same generation
                            if state_hb.borrow().connection_generation == generation_hb {
                                let heartbeat = make_heartbeat_message();
                                let array = Uint8Array::from(&heartbeat[..]);
                                let _ = writer_hb.write_with_chunk(&array);
                            }
                        }) as Box<dyn Fn()>);
                        
                        let interval_id = set_interval(&heartbeat_closure, (HEARTBEAT_INTERVAL_SECS * 1000) as i32);
                        heartbeat_closure.forget();
                        state.borrow_mut().heartbeat_interval_id = Some(interval_id);
                        
                        // Setup visibility change handler for immediate heartbeat on tab focus
                        setup_visibility_handler(writer.clone(), state.clone(), generation);
                        
                        // Mark as connected
                        state.borrow_mut().connection_state = ConnectionState::Connected;
                        
                        // Start reader loop
                        let readable = transport.datagrams().readable();
                        let reader: ReadableStreamDefaultReader = readable.get_reader().unchecked_into();
                        
                        loop {
                            // Check if we should stop
                            if state.borrow().connection_generation != generation {
                                console_log("[WebTransport] Reader loop: generation changed, stopping");
                                break;
                            }
                            
                            match JsFuture::from(reader.read()).await {
                                Ok(result) => {
                                    let done = js_sys::Reflect::get(&result, &JsValue::from_str("done"))
                                        .unwrap()
                                        .as_bool()
                                        .unwrap_or(true);
                                    if done {
                                        console_log("[WebTransport] Reader stream ended");
                                        break;
                                    }
                                    
                                    let value = js_sys::Reflect::get(&result, &JsValue::from_str("value")).unwrap();
                                    let array = Uint8Array::new(&value);
                                    let data = array.to_vec();
                                    
                                    // Handle control messages
                                    if !data.is_empty() && data[0] == MSG_TYPE_CONTROL {
                                        if let Ok(json_str) = std::str::from_utf8(&data[1..]) {
                                            if json_str.contains("\"type\":\"Assigned\"") {
                                                let mut s = state.borrow_mut();
                                                s.registered = true;
                                                if let Some(ip) = parse_ip_from_json(json_str) {
                                                    s.assigned_ip = Some(ip);
                                                    drop(s);
                                                    console_log(&format!(
                                                        "[WebTransport] IP Assigned: {}.{}.{}.{}",
                                                        ip[0], ip[1], ip[2], ip[3]
                                                    ));
                                                }
                                            } else if json_str.contains("\"type\":\"Error\"") {
                                                console_error(&format!("[WebTransport] Relay error: {}", json_str));
                                            }
                                        }
                                    }
                                    
                                    // Queue Ethernet frames
                                    if let Some(frame) = decode_message(&data) {
                                        state.borrow_mut().rx_queue.push_back(frame);
                                    }
                                }
                                Err(e) => {
                                    console_error(&format!("[WebTransport] Read error: {:?}", e));
                                    break;
                                }
                            }
                        }
                        
                        // Connection ended - cleanup and reconnect
                        console_log("[WebTransport] Connection lost, scheduling reconnection...");
                        {
                            let mut s = state.borrow_mut();
                            if s.connection_generation == generation {
                                s.connection_state = ConnectionState::Disconnected;
                                s.registered = false;
                                if let Some(id) = s.heartbeat_interval_id.take() {
                                    clear_interval(id);
                                }
                            }
                        }
                        *transport_rc.borrow_mut() = None;
                        *writer_rc.borrow_mut() = None;
                        
                        // Only reconnect if this is still the current generation
                        if state.borrow().connection_generation == generation {
                            schedule_reconnect(state, transport_rc, writer_rc, url, cert_hash, mac, 3000);
                        }
                    }
                    Err(e) => {
                        console_error(&format!("[WebTransport] Failed to connect: {:?}", e));
                        state.borrow_mut().connection_state = ConnectionState::Disconnected;
                        schedule_reconnect(state.clone(), transport_rc.clone(), writer_rc.clone(),
                                         url.clone(), cert_hash.clone(), mac, 5000);
                    }
                }
            });
        }
    }

    // Helper to log to browser console
    fn console_log(msg: &str) {
        web_sys::console::log_1(&JsValue::from_str(msg));
    }
    
    fn console_error(msg: &str) {
        web_sys::console::error_1(&JsValue::from_str(msg));
    }
    
    /// Set up a JS interval and return its ID
    fn set_interval(closure: &Closure<dyn Fn()>, ms: i32) -> i32 {
        let global = js_sys::global();
        let set_interval = js_sys::Reflect::get(&global, &JsValue::from_str("setInterval"))
            .expect("setInterval should exist");
        let set_interval_fn: js_sys::Function = set_interval.unchecked_into();
        let result = set_interval_fn.call2(&JsValue::NULL, closure.as_ref(), &JsValue::from(ms))
            .unwrap_or(JsValue::from(0));
        result.as_f64().unwrap_or(0.0) as i32
    }
    
    /// Clear a JS interval
    fn clear_interval(id: i32) {
        let global = js_sys::global();
        if let Ok(clear) = js_sys::Reflect::get(&global, &JsValue::from_str("clearInterval")) {
            let clear_fn: js_sys::Function = clear.unchecked_into();
            let _ = clear_fn.call1(&JsValue::NULL, &JsValue::from(id));
        }
    }
    
    /// Set up a JS timeout and return its ID
    fn set_timeout(closure: &Closure<dyn FnMut()>, ms: i32) -> i32 {
        let global = js_sys::global();
        let set_timeout = js_sys::Reflect::get(&global, &JsValue::from_str("setTimeout"))
            .expect("setTimeout should exist");
        let set_timeout_fn: js_sys::Function = set_timeout.unchecked_into();
        let result = set_timeout_fn.call2(&JsValue::NULL, closure.as_ref(), &JsValue::from(ms))
            .unwrap_or(JsValue::from(0));
        result.as_f64().unwrap_or(0.0) as i32
    }
    
    /// Schedule a reconnection attempt
    fn schedule_reconnect(
        state: Rc<RefCell<SharedState>>,
        transport_rc: Rc<RefCell<Option<WebTransport>>>,
        writer_rc: Rc<RefCell<Option<WritableStreamDefaultWriter>>>,
        url: String,
        cert_hash: Option<String>,
        mac: [u8; 6],
        delay_ms: i32,
    ) {
        console_log(&format!("[WebTransport] Scheduling reconnect in {}ms...", delay_ms));
        
        let closure = Closure::once(move || {
            // Create a temporary backend to trigger reconnection
            let backend = WebTransportBackend {
                url: url.clone(),
                cert_hash: cert_hash.clone(),
                mac,
                transport: transport_rc,
                writer: writer_rc,
                state,
            };
            backend.start_connection();
        });
        
        set_timeout(&closure, delay_ms);
        closure.forget();
    }
    
    /// Setup visibility change handler to send heartbeat when tab becomes visible
    fn setup_visibility_handler(
        writer: WritableStreamDefaultWriter,
        state: Rc<RefCell<SharedState>>,
        generation: u32,
    ) {
        let closure = Closure::wrap(Box::new(move || {
            // Check if document is visible
            let global = js_sys::global();
            if let Ok(document) = js_sys::Reflect::get(&global, &JsValue::from_str("document")) {
                if let Ok(hidden) = js_sys::Reflect::get(&document, &JsValue::from_str("hidden")) {
                    if !hidden.as_bool().unwrap_or(true) {
                        // Tab became visible - send immediate heartbeat
                        if state.borrow().connection_generation == generation {
                            console_log("[WebTransport] Tab visible - sending immediate heartbeat");
                            let heartbeat = make_heartbeat_message();
                            let array = Uint8Array::from(&heartbeat[..]);
                            let _ = writer.write_with_chunk(&array);
                        }
                    }
                }
            }
        }) as Box<dyn Fn()>);
        
        // Add event listener
        let global = js_sys::global();
        if let Ok(document) = js_sys::Reflect::get(&global, &JsValue::from_str("document")) {
            if let Ok(add_listener) = js_sys::Reflect::get(&document, &JsValue::from_str("addEventListener")) {
                let add_fn: js_sys::Function = add_listener.unchecked_into();
                let _ = add_fn.call2(&document, &JsValue::from_str("visibilitychange"), closure.as_ref());
            }
        }
        closure.forget();
    }

    impl NetworkBackend for WebTransportBackend {
        fn init(&mut self) -> Result<(), String> {
            console_log(&format!("[WebTransport] Initializing connection to {}", self.url));
            self.start_connection();
            Ok(())
        }

        fn recv(&mut self) -> Result<Option<Vec<u8>>, String> {
            Ok(self.state.borrow_mut().rx_queue.pop_front())
        }

        fn send(&self, buf: &[u8]) -> Result<(), String> {
            if let Some(writer) = self.writer.borrow().as_ref() {
                // Frame the Ethernet data with the protocol prefix
                let framed = encode_data_frame(buf);
                let array = Uint8Array::from(&framed[..]);
                let _ = writer.write_with_chunk(&array);
                Ok(())
            } else {
                Err("Not connected".to_string())
            }
        }

        fn mac_address(&self) -> [u8; 6] {
            self.mac
        }
        
        fn get_assigned_ip(&self) -> Option<[u8; 4]> {
            self.state.borrow().assigned_ip
        }
    }
}

#[cfg(not(target_arch = "wasm32"))]
pub use native::WebTransportBackend;

#[cfg(target_arch = "wasm32")]
pub use wasm::WebTransportBackend;
</file>

<file path="relay/Cargo.toml">
[package]
name = "relay"
version = "0.1.3"
edition = "2024"
description = "P2P WebTransport Relay Server for RISC-V VM networking"

[dependencies]
# Async runtime
tokio = { version = "1", features = ["full", "process"] }

# WebTransport
wtransport = "0.6.1"

# Logging
tracing = "0.1"
tracing-subscriber = { version = "0.3", features = ["env-filter"] }

# CLI
clap = { version = "4.4", features = ["derive", "env"] }

# Error handling
anyhow = "1.0"

# Serialization for protocol messages
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0"
</file>

<file path="relay/CHANGELOG.md">
## 0.1.3 (2025-12-02)

This was a version bump only for relay to align it with other projects, there were no code changes.

## 0.1.2 (2025-12-02)

### 🩹 Fixes

- major refactor for wasm multi threading Signed-off-by: Javier Ribó <elribonazo@gmail.com> ([46a6c21](https://github.com/elribonazo/riscv-vm/commit/46a6c21))

### ❤️ Thank You

- Javier Ribó

## 0.1.1 (2025-11-30)

This was a version bump only for relay to align it with other projects, there were no code changes.

## 0.1.0 (2025-11-29)

### 🚀 Features

- implement http with tls 1.2 and 1.3 over webTransport Signed-off-by: Javier Ribó <elribonazo@gmail.com> ([ae5ff04](https://github.com/elribonazo/riscv-vm/commit/ae5ff04))

### ❤️ Thank You

- Javier Ribó

## 0.0.5 (2025-11-29)

### 🩹 Fixes

- relay improvement + vm reconnect Signed-off-by: Javier Ribó <elribonazo@gmail.com> ([91300e7](https://github.com/elribonazo/riscv-vm/commit/91300e7))

### ❤️ Thank You

- Javier Ribó

## 0.0.4 (2025-11-29)

This was a version bump only for relay to align it with other projects, there were no code changes.

## 0.0.3 (2025-11-29)

This was a version bump only for relay to align it with other projects, there were no code changes.

## 0.0.2 (2025-11-28)

### 🩹 Fixes

- relay improvements Signed-off-by: Javier Ribó <elribonazo@gmail.com> ([1c17123](https://github.com/elribonazo/riscv-vm/commit/1c17123))

### ❤️ Thank You

- Javier Ribó

## 0.0.1 (2025-11-28)

### 🩹 Fixes

- build release Signed-off-by: Javier Ribó <elribonazo@gmail.com> ([94ad7a1](https://github.com/elribonazo/riscv-vm/commit/94ad7a1))
- pipelines Signed-off-by: Javier Ribó <elribonazo@gmail.com> ([34664a9](https://github.com/elribonazo/riscv-vm/commit/34664a9))
- improve kernel Signed-off-by: Javier Ribó <elribonazo@gmail.com> ([39a361a](https://github.com/elribonazo/riscv-vm/commit/39a361a))
- versions Signed-off-by: Javier Ribó <elribonazo@gmail.com> ([b715645](https://github.com/elribonazo/riscv-vm/commit/b715645))
- test ci Signed-off-by: Javier Ribó <elribonazo@gmail.com> ([7d15c50](https://github.com/elribonazo/riscv-vm/commit/7d15c50))
- build images and certificates Signed-off-by: Javier Ribó <elribonazo@gmail.com> ([8fc8377](https://github.com/elribonazo/riscv-vm/commit/8fc8377))
- refactor images and context Signed-off-by: Javier Ribó <elribonazo@gmail.com> ([7ec91b6](https://github.com/elribonazo/riscv-vm/commit/7ec91b6))
- relay service Signed-off-by: Javier Ribó <elribonazo@gmail.com> ([bc45c89](https://github.com/elribonazo/riscv-vm/commit/bc45c89))
- wip network Signed-off-by: Javier Ribó <elribonazo@gmail.com> ([bec5717](https://github.com/elribonazo/riscv-vm/commit/bec5717))
- image Signed-off-by: Javier Ribó <elribonazo@gmail.com> ([951af5f](https://github.com/elribonazo/riscv-vm/commit/951af5f))
- networking improvement Signed-off-by: Javier Ribó <elribonazo@gmail.com> ([2929223](https://github.com/elribonazo/riscv-vm/commit/2929223))
- relay improvements Signed-off-by: Javier Ribó <elribonazo@gmail.com> ([9170737](https://github.com/elribonazo/riscv-vm/commit/9170737))
- ui changes Signed-off-by: Javier Ribó <elribonazo@gmail.com> ([207c9e1](https://github.com/elribonazo/riscv-vm/commit/207c9e1))
- implement networking Signed-off-by: Javier Ribó <elribonazo@gmail.com> ([217fcdb](https://github.com/elribonazo/riscv-vm/commit/217fcdb))

### ❤️ Thank You

- Javier Ribó
</file>

<file path="riscv-vm/src/lib.rs">
pub mod bus;
pub mod cpu;
pub mod decoder;
pub mod csr;
pub mod mmu;
pub mod dram;
pub mod clint;
pub mod plic;
pub mod uart;
pub mod net;
#[cfg(not(target_arch = "wasm32"))]
pub mod net_async;
pub mod net_webtransport;
pub mod net_external;
pub mod virtio;
pub mod emulator;
pub mod shared_mem;

// Node.js native addon bindings (napi-rs)
#[cfg(all(feature = "napi", not(target_arch = "wasm32")))]
pub mod napi_bindings;

#[cfg(not(target_arch = "wasm32"))]
pub mod console;

#[cfg(target_arch = "wasm32")]
pub mod worker;

use serde::{Deserialize, Serialize};

// WASM bindings
#[cfg(target_arch = "wasm32")]
use wasm_bindgen::prelude::*;

#[cfg(target_arch = "wasm32")]
use crate::bus::{SystemBus, DRAM_BASE};

/// Network connection status for the WASM VM.
#[cfg(target_arch = "wasm32")]
#[wasm_bindgen]
#[derive(Clone, Copy, PartialEq, Eq)]
pub enum NetworkStatus {
    Disconnected = 0,
    Connecting = 1,
    Connected = 2,
    Error = 3,
}

// ============================================================================
// Hart Count Detection
// ============================================================================

/// Detect the number of hardware threads available.
/// Limits to half the available CPU cores to leave resources for the host.
#[cfg(target_arch = "wasm32")]
#[allow(dead_code)] // Used in WASM builds only
fn detect_hart_count() -> usize {
    // In browsers, navigator.hardwareConcurrency gives logical CPU count
    let count = web_sys::window()
        .and_then(|w| Some(w.navigator().hardware_concurrency() as usize))
        .unwrap_or(2);
    
    (count / 2).max(1) // Use half the CPUs, ensure at least 1
}

/// Check if SharedArrayBuffer is available for multi-threaded execution.
#[cfg(target_arch = "wasm32")]
fn check_shared_array_buffer_available() -> bool {
    // SharedArrayBuffer requires cross-origin isolation (COOP/COEP headers)
    
    // Check if we're in a browser context
    if let Some(window) = web_sys::window() {
        // Check crossOriginIsolated property
        let isolated: bool = js_sys::Reflect::get(&window, &JsValue::from_str("crossOriginIsolated"))
            .ok()
            .and_then(|v| v.as_bool())
            .unwrap_or(false);
        
        if !isolated {
            web_sys::console::warn_1(&JsValue::from_str(
                "[VM] Not cross-origin isolated. Add COOP/COEP headers for SMP support."));
            return false;
        }
        
        web_sys::console::log_1(&JsValue::from_str(
            "[VM] Cross-origin isolated - SharedArrayBuffer should be available"));
    }
    
    // If cross-origin isolated, SharedArrayBuffer should work
    // Note: catch_unwind doesn't work in WASM, so we trust the isolation check
    true
}

#[cfg(not(target_arch = "wasm32"))]
fn detect_hart_count() -> usize {
    let count = std::thread::available_parallelism()
        .map(|n| n.get())
        .unwrap_or(2);
    (count / 2).max(1) // Use half the CPUs, ensure at least 1
}

/// WASM-exposed VM wrapper for running RISC-V kernels in the browser.
///
/// ## Multi-Hart Architecture
///
/// When `SharedArrayBuffer` is available (requires COOP/COEP headers):
/// - Hart 0 runs on the main thread (handles I/O devices)
/// - Harts 1+ run on Web Workers (parallel execution)
/// - DRAM and CLINT are shared via SharedArrayBuffer
/// - Workers are managed automatically
///
/// When `SharedArrayBuffer` is NOT available:
/// - Falls back to single-threaded round-robin execution
#[cfg(target_arch = "wasm32")]
#[wasm_bindgen]
pub struct WasmVm {
    bus: SystemBus,
    cpu: cpu::Cpu,              // Primary CPU (hart 0)
    num_harts: usize,           // Total hart count
    net_status: NetworkStatus,
    poll_counter: u32,
    halted: bool,
    halt_code: u64,
    /// Shared memory buffer (for passing to workers)
    shared_buffer: Option<js_sys::SharedArrayBuffer>,
    /// Shared control region accessor
    shared_control: Option<shared_mem::wasm::SharedControl>,
    /// Shared CLINT accessor
    shared_clint: Option<shared_mem::wasm::SharedClint>,
    /// Shared UART output accessor (for reading worker output)
    shared_uart_output: Option<shared_mem::wasm::SharedUartOutput>,
    /// Shared UART input accessor (for sending keyboard input to workers)
    shared_uart_input: Option<shared_mem::wasm::SharedUartInput>,
    /// Worker handles
    workers: Vec<web_sys::Worker>,
    /// Worker ready flags
    workers_ready: Vec<bool>,
    /// Whether workers have been started
    workers_started: bool,
    /// Entry PC for workers
    entry_pc: u64,
    /// Boot step counter - used to delay worker start
    boot_steps: u64,
    /// Whether workers have been signaled to start
    workers_signaled: bool,
    /// External network backend for Node.js native addon bridging
    external_net: Option<std::sync::Arc<net_external::ExternalNetworkBackend>>,
}

#[cfg(target_arch = "wasm32")]
#[wasm_bindgen]
impl WasmVm {
    /// Create a new VM instance and load a kernel (ELF or raw binary).
    ///
    /// If SharedArrayBuffer is available, the VM will use true parallel
    /// execution with Web Workers. Otherwise, falls back to single-threaded mode.
    ///
    /// Hart count is auto-detected as half of hardware_concurrency.
    /// Use `new_with_harts()` to specify a custom hart count.
    #[wasm_bindgen(constructor)]
    pub fn new(kernel: &[u8]) -> Result<WasmVm, JsValue> {
        Self::create_vm_internal(kernel, None)
    }
    
    /// Create a new VM instance with a specified number of harts.
    ///
    /// # Arguments
    /// * `kernel` - ELF kernel binary
    /// * `num_harts` - Number of harts (0 = auto-detect)
    pub fn new_with_harts(kernel: &[u8], num_harts: usize) -> Result<WasmVm, JsValue> {
        let harts = if num_harts == 0 { None } else { Some(num_harts) };
        Self::create_vm_internal(kernel, harts)
    }
    
    /// Internal constructor with optional hart count.
    fn create_vm_internal(kernel: &[u8], num_harts: Option<usize>) -> Result<WasmVm, JsValue> {
        // Set up panic hook for better error messages in the browser console
        console_error_panic_hook::set_once();
        
        web_sys::console::log_1(&wasm_bindgen::JsValue::from_str(
            &format!("[VM] Creating new VM, kernel size: {} bytes", kernel.len())));

        const DRAM_SIZE: usize = 512 * 1024 * 1024; // 512 MiB
        
        // Detect or use specified hart count
        let num_harts = num_harts.unwrap_or_else(detect_hart_count);
        
        // Check if SharedArrayBuffer is available for true parallelism
        let sab_available = check_shared_array_buffer_available();
        
        if sab_available {
            web_sys::console::log_1(&wasm_bindgen::JsValue::from_str(
                "[VM] SharedArrayBuffer available - enabling SMP mode"));
        } else {
            web_sys::console::warn_1(&wasm_bindgen::JsValue::from_str(
                "[VM] SharedArrayBuffer not available - running single-threaded"));
        }
        
        // Create bus with shared memory if available
        let (bus, shared_buffer, shared_control, shared_clint, shared_uart_output, shared_uart_input) = if sab_available {
            // Create SharedArrayBuffer for shared memory
            let total_size = shared_mem::total_shared_size(DRAM_SIZE);
            let sab = js_sys::SharedArrayBuffer::new(total_size as u32);
            
            // Initialize shared memory regions
            shared_mem::wasm::init_shared_memory(&sab, num_harts);
            
            // Create bus with DRAM backed by shared buffer
            // IMPORTANT: Pass the full SharedArrayBuffer with the DRAM byte offset,
            // NOT a sliced copy (slice() creates a copy, breaking shared memory!)
            // Also pass SharedClint so CLINT MMIO accesses go through shared memory.
            let dram_offset = shared_mem::dram_offset();
            let shared_clint_for_bus = shared_mem::wasm::SharedClint::new(&sab);
            // Main thread (hart 0) reads from local UART, not shared input
            let bus = SystemBus::from_shared_buffer(sab.clone(), dram_offset, shared_clint_for_bus, false);
            
            let control = shared_mem::wasm::SharedControl::new(&sab);
            let clint = shared_mem::wasm::SharedClint::new(&sab);
            let uart_output = shared_mem::wasm::SharedUartOutput::new(&sab);
            let uart_input = shared_mem::wasm::SharedUartInput::new(&sab);
            
            (bus, Some(sab), Some(control), Some(clint), Some(uart_output), Some(uart_input))
        } else {
            // Standard bus without shared memory
            let bus = SystemBus::new(DRAM_BASE, DRAM_SIZE);
            (bus, None, None, None, None, None)
        };
        
        // Load kernel
        let entry_pc = if kernel.starts_with(b"\x7FELF") {
            web_sys::console::log_1(&wasm_bindgen::JsValue::from_str("[VM] Detected ELF kernel"));
            let entry = load_elf_wasm(kernel, &bus)
                .map_err(|e| JsValue::from_str(&format!("Failed to load ELF kernel: {}", e)))?;
            web_sys::console::log_1(&wasm_bindgen::JsValue::from_str(
                &format!("[VM] ELF loaded, entry point: 0x{:x}", entry)));
            entry
        } else {
            web_sys::console::warn_1(&wasm_bindgen::JsValue::from_str(
                &format!("[VM] Warning: kernel does not appear to be an ELF file (magic: {:02x?}). Loading as raw binary.",
                    &kernel[..kernel.len().min(4)])));
            bus.dram
                .load(kernel, 0)
                .map_err(|e| JsValue::from_str(&format!("Failed to load kernel: {}", e)))?;
            DRAM_BASE
        };

        // Set hart count in CLINT (native CLINT in bus)
        bus.set_num_harts(num_harts);
        
        // Create primary CPU (hart 0)
        let cpu = cpu::Cpu::new(entry_pc, 0);
        
        web_sys::console::log_1(&wasm_bindgen::JsValue::from_str(
            &format!("[VM] Created {} harts, entry PC=0x{:x}, SMP={}", 
                num_harts, entry_pc, sab_available)));

        Ok(WasmVm { 
            bus, 
            cpu,
            num_harts,
            net_status: NetworkStatus::Disconnected,
            poll_counter: 0,
            halted: false,
            halt_code: 0,
            shared_buffer,
            shared_control,
            shared_clint,
            shared_uart_output,
            shared_uart_input,
            workers: Vec::new(),
            workers_ready: Vec::new(),
            workers_started: false,
            entry_pc,
            boot_steps: 0,
            workers_signaled: false,
            external_net: None,
        })
    }

    /// Load a disk image and attach it as a VirtIO block device.
    /// This should be called before starting execution if the kernel needs a filesystem.
    pub fn load_disk(&mut self, disk_image: &[u8]) {
        let vblk = virtio::VirtioBlock::new(disk_image.to_vec());
        self.bus.virtio_devices.push(Box::new(vblk));
    }
    
    /// Connect to a WebTransport relay server.
    /// Note: Connection is asynchronous. Check network_status() to monitor connection state.
    pub fn connect_webtransport(&mut self, url: &str, cert_hash: Option<String>) -> Result<(), JsValue> {
        use crate::net_webtransport::WebTransportBackend;
        use crate::virtio::VirtioNet;

        // Status stays as Connecting until we can verify the connection is established
        // (when IP is assigned, the connection is confirmed)
        self.net_status = NetworkStatus::Connecting;

        let backend = WebTransportBackend::new(url, cert_hash);
        // Note: WebTransport connect is async, so backend.init() will start connection
        // but actual connection happens in background.
        let vnet = VirtioNet::new(Box::new(backend));
        // debug defaults to false in VirtioNet

        self.bus.virtio_devices.push(Box::new(vnet));
        // Don't set to Connected here - let network_status() check the actual state

        Ok(())
    }

    /// Disconnect from the network.
    pub fn disconnect_network(&mut self) {
        // Remove VirtioNet devices (device_id == 1)
        self.bus.virtio_devices.retain(|dev| dev.device_id() != 1);
        self.net_status = NetworkStatus::Disconnected;
        self.external_net = None;
    }
    
    // ========================================================================
    // External Network Backend (for Node.js native addon bridging)
    // ========================================================================
    
    /// Set up an external network backend for packet bridging.
    /// This is used by the Node.js CLI to bridge packets between the native
    /// WebTransport addon and the WASM VM.
    /// 
    /// @param mac_bytes - MAC address as 6 bytes [0x52, 0x54, 0x00, 0x12, 0x34, 0x56]
    pub fn setup_external_network(&mut self, mac_bytes: js_sys::Uint8Array) -> Result<(), JsValue> {
        use crate::net_external::{ExternalNetworkBackend, ExternalBackendWrapper};
        use crate::virtio::VirtioNet;
        use std::sync::Arc;
        
        // Parse MAC address
        let mac_vec = mac_bytes.to_vec();
        if mac_vec.len() != 6 {
            return Err(JsValue::from_str("MAC address must be 6 bytes"));
        }
        let mut mac = [0u8; 6];
        mac.copy_from_slice(&mac_vec);
        
        // Create external backend
        let backend = Arc::new(ExternalNetworkBackend::new(mac));
        self.external_net = Some(backend.clone());
        
        // Create a wrapper that implements NetworkBackend
        let wrapper = ExternalBackendWrapper { inner: backend };
        
        // Create VirtIO network device
        let vnet = VirtioNet::new(Box::new(wrapper));
        self.bus.virtio_devices.push(Box::new(vnet));
        
        self.net_status = NetworkStatus::Connecting;
        
        // Log to console (works in both browser and Node.js with WASM)
        let msg = format!("[VM] External network setup, MAC: {:02x}:{:02x}:{:02x}:{:02x}:{:02x}:{:02x}",
            mac[0], mac[1], mac[2], mac[3], mac[4], mac[5]);
        web_sys::console::log_1(&wasm_bindgen::JsValue::from_str(&msg));
        
        Ok(())
    }
    
    /// Inject a network packet to be received by the guest.
    /// Called from JavaScript when the native WebTransport addon receives a packet.
    pub fn inject_network_packet(&self, packet: js_sys::Uint8Array) -> bool {
        if let Some(ref backend) = self.external_net {
            backend.inject_rx_packet(packet.to_vec());
            true
        } else {
            false
        }
    }
    
    /// Extract a network packet sent by the guest.
    /// Returns the packet data or null if no packet is pending.
    pub fn extract_network_packet(&self) -> Option<js_sys::Uint8Array> {
        if let Some(ref backend) = self.external_net {
            backend.extract_tx_packet().map(|p| {
                let arr = js_sys::Uint8Array::new_with_length(p.len() as u32);
                arr.copy_from(&p);
                arr
            })
        } else {
            None
        }
    }
    
    /// Extract all pending network packets sent by the guest.
    /// Returns an array of packet data.
    pub fn extract_all_network_packets(&self) -> js_sys::Array {
        let arr = js_sys::Array::new();
        if let Some(ref backend) = self.external_net {
            for p in backend.extract_all_tx_packets() {
                let uint8 = js_sys::Uint8Array::new_with_length(p.len() as u32);
                uint8.copy_from(&p);
                arr.push(&uint8);
            }
        }
        arr
    }
    
    /// Set the assigned IP address for the external network.
    /// Called when the native WebTransport addon receives an IP assignment.
    pub fn set_external_network_ip(&self, ip_bytes: js_sys::Uint8Array) -> bool {
        let ip_vec = ip_bytes.to_vec();
        if ip_vec.len() != 4 {
            return false;
        }
        if let Some(ref backend) = self.external_net {
            let mut ip = [0u8; 4];
            ip.copy_from_slice(&ip_vec);
            backend.set_assigned_ip(ip);
            backend.set_connected(true);
            true
        } else {
            false
        }
    }
    
    /// Check if external network is connected (has IP assigned).
    pub fn is_external_network_connected(&self) -> bool {
        if let Some(ref backend) = self.external_net {
            backend.is_connected()
        } else {
            false
        }
    }
    
    /// Get the number of pending RX packets.
    pub fn external_network_rx_pending(&self) -> usize {
        if let Some(ref backend) = self.external_net {
            backend.rx_queue_len()
        } else {
            0
        }
    }
    
    /// Get the number of pending TX packets.
    pub fn external_network_tx_pending(&self) -> usize {
        if let Some(ref backend) = self.external_net {
            backend.tx_queue_len()
        } else {
            0
        }
    }
    
    /// Get the current network connection status.
    /// This checks the actual connection state by seeing if an IP was assigned.
    pub fn network_status(&mut self) -> NetworkStatus {
        // If we think we're connecting, check if we've actually connected
        // by seeing if we can read an assigned IP from the VirtIO config space
        if self.net_status == NetworkStatus::Connecting {
            // Look for a VirtioNet device (device_id == 1) and check if IP is assigned
            for (idx, device) in self.bus.virtio_devices.iter_mut().enumerate() {
                let dev_id = device.device_id();
                if dev_id == 1 {
                    // Read config space offset 8 (IP address)
                    // IP is at config offset 0x108 - 0x100 = 8
                    if let Ok(ip_val) = device.read(0x108) {
                        web_sys::console::log_1(&wasm_bindgen::JsValue::from_str(
                            &format!("[network_status] Device idx={} id={} read(0x108)={:#x}", 
                                idx, dev_id, ip_val)));
                        if ip_val != 0 {
                            self.net_status = NetworkStatus::Connected;
                            break;
                        }
                    }
                }
            }
        }
        self.net_status
    }

    /// Execute one instruction on hart 0 (primary hart).
    ///
    /// In SMP mode, secondary harts run in Web Workers and execute in parallel.
    /// This method only steps hart 0, which handles I/O coordination.
    ///
    /// Returns true if the VM is still running, false if halted.
    pub fn step(&mut self) -> bool {
        // If already halted, don't execute more instructions
        if self.halted {
            return false;
        }
        
        // Check if workers reported halt
        if let Some(ref control) = self.shared_control {
            if control.is_halted() {
                self.halted = true;
                self.halt_code = control.halt_code();
                web_sys::console::log_1(&wasm_bindgen::JsValue::from_str(
                    &format!("[VM] Worker signaled halt (code: {:#x})", self.halt_code)));
                return false;
            }
        }
        
        // Track boot progress and signal workers after initial boot
        // This ensures hart 0 has time to set up memory, page tables, etc.
        // before secondary harts start executing.
        const BOOT_STEPS_THRESHOLD: u64 = 500_000; // ~500K instructions for boot
        if !self.workers_signaled {
            self.boot_steps += 1;
            if self.boot_steps >= BOOT_STEPS_THRESHOLD {
                if let Some(ref control) = self.shared_control {
                    control.allow_workers_to_start();
                    self.workers_signaled = true;
                    web_sys::console::log_1(&wasm_bindgen::JsValue::from_str(
                        &format!("[VM] Workers signaled to start after {} boot steps", self.boot_steps)));
                }
            }
        }
        
        // Poll VirtIO devices periodically for incoming network packets
        // Poll every 100 instructions for good network responsiveness
        self.poll_counter = self.poll_counter.wrapping_add(1);
        if self.poll_counter % 100 == 0 {
            self.bus.poll_virtio();
            
            // Update shared CLINT timer (if in SMP mode)
            if let Some(ref clint) = self.shared_clint {
                // Increment mtime in shared memory
                clint.tick(100); // 100 ticks per poll
            }
        }
        
        // Execute one instruction on hart 0 only
        // (Secondary harts run in workers)
        match self.cpu.step(&self.bus) {
            Ok(()) => {}
            Err(Trap::RequestedTrap(code)) => {
                self.halted = true;
                self.halt_code = code;
                // Signal halt to workers
                if let Some(ref control) = self.shared_control {
                    control.signal_halted(code);
                }
                web_sys::console::log_1(&wasm_bindgen::JsValue::from_str(
                    &format!("[VM] Hart 0 requested halt (code: {:#x})", code)));
                return false;
            }
            Err(Trap::Fatal(msg)) => {
                web_sys::console::error_1(&wasm_bindgen::JsValue::from_str(
                    &format!("[VM] Fatal error: {} at PC=0x{:x}", msg, self.cpu.pc)));
                self.halted = true;
                if let Some(ref control) = self.shared_control {
                    control.signal_halted(0xDEAD);
                }
                return false;
            }
            Err(_trap) => {
                // Architectural traps handled by CPU
            }
        }
        
        true
    }
    
    /// Start worker threads for secondary harts (1..num_harts).
    ///
    /// Workers run in parallel with the main thread, sharing DRAM and CLINT
    /// via SharedArrayBuffer.
    ///
    /// # Arguments
    /// * `worker_url` - URL to the worker script (e.g., "/worker.js")
    pub fn start_workers(&mut self, worker_url: &str) -> Result<(), JsValue> {
        // Only start workers if we have shared memory and more than 1 hart
        if self.shared_buffer.is_none() || self.num_harts <= 1 {
            web_sys::console::log_1(&JsValue::from_str(
                "[VM] Skipping worker creation (single-threaded mode or 1 hart)"));
            return Ok(());
        }
        
        if self.workers_started {
            return Ok(());
        }
        
        let shared_buffer = self.shared_buffer.as_ref().unwrap();
        
        web_sys::console::log_1(&JsValue::from_str(
            &format!("[VM] Starting {} workers at {}", self.num_harts - 1, worker_url)));
        
        for hart_id in 1..self.num_harts {
            // Create worker with ESM module type
            let mut opts = web_sys::WorkerOptions::new();
            opts.type_(web_sys::WorkerType::Module);
            
            let worker = web_sys::Worker::new_with_options(worker_url, &opts)
                .map_err(|e| JsValue::from_str(&format!("Failed to create worker: {:?}", e)))?;
            
            // Set up message handler for this worker
            let hart_id_copy = hart_id;
            let onmessage = wasm_bindgen::closure::Closure::wrap(Box::new(move |event: web_sys::MessageEvent| {
                let data = event.data();
                if let Some(type_str) = js_sys::Reflect::get(&data, &JsValue::from_str("type"))
                    .ok()
                    .and_then(|v| v.as_string())
                {
                    match type_str.as_str() {
                        "ready" => {
                            web_sys::console::log_1(&JsValue::from_str(
                                &format!("[VM] Worker {} ready", hart_id_copy)));
                        }
                        "halted" => {
                            web_sys::console::log_1(&JsValue::from_str(
                                &format!("[VM] Worker {} halted", hart_id_copy)));
                        }
                        "error" => {
                            if let Ok(error) = js_sys::Reflect::get(&data, &JsValue::from_str("error")) {
                                web_sys::console::error_1(&JsValue::from_str(
                                    &format!("[VM] Worker {} error: {:?}", hart_id_copy, error)));
                            }
                        }
                        _ => {}
                    }
                }
            }) as Box<dyn FnMut(_)>);
            
            worker.set_onmessage(Some(onmessage.as_ref().unchecked_ref()));
            onmessage.forget(); // Leak the closure (lives for program lifetime)
            
            // Send init message to worker
            let init_msg = js_sys::Object::new();
            js_sys::Reflect::set(&init_msg, &JsValue::from_str("hartId"), &JsValue::from(hart_id as u32)).unwrap();
            js_sys::Reflect::set(&init_msg, &JsValue::from_str("sharedMem"), shared_buffer).unwrap();
            js_sys::Reflect::set(&init_msg, &JsValue::from_str("entryPc"), &JsValue::from(self.entry_pc as f64)).unwrap();
            
            worker.post_message(&init_msg)
                .map_err(|e| JsValue::from_str(&format!("Failed to send init message: {:?}", e)))?;
            
            self.workers.push(worker);
            self.workers_ready.push(false);
        }
        
        self.workers_started = true;
        web_sys::console::log_1(&JsValue::from_str(
            &format!("[VM] Started {} workers", self.workers.len())));
        
        Ok(())
    }
    
    /// Get the number of harts configured.
    pub fn num_harts(&self) -> usize {
        self.num_harts
    }
    
    /// Check if running in SMP mode (with workers).
    pub fn is_smp(&self) -> bool {
        self.shared_buffer.is_some() && self.num_harts > 1
    }
    
    /// Get the SharedArrayBuffer for external worker management.
    /// Returns None if not in SMP mode.
    pub fn get_shared_buffer(&self) -> Option<js_sys::SharedArrayBuffer> {
        self.shared_buffer.clone()
    }
    
    /// Get the entry PC address for workers.
    /// This is the address where secondary harts should start executing.
    pub fn entry_pc(&self) -> u64 {
        self.entry_pc
    }
    
    /// Signal that workers can start executing.
    /// Called by the main thread after hart 0 has finished initializing
    /// kernel data structures.
    pub fn allow_workers_to_start(&mut self) {
        if let Some(ref control) = self.shared_control {
            control.allow_workers_to_start();
            self.workers_signaled = true;
            web_sys::console::log_1(&JsValue::from_str("[VM] Workers signaled to start"));
        }
    }
    
    /// Terminate all workers.
    pub fn terminate_workers(&mut self) {
        // Signal halt to workers
        if let Some(ref control) = self.shared_control {
            control.request_halt();
        }
        
        // Terminate worker threads
        for worker in &self.workers {
            worker.terminate();
        }
        self.workers.clear();
        self.workers_ready.clear();
        self.workers_started = false;
        
        web_sys::console::log_1(&JsValue::from_str("[VM] All workers terminated"));
    }

    /// Execute up to N instructions in a batch.
    /// Returns the number of instructions actually executed.
    /// This is more efficient than calling step() N times due to reduced
    /// JS-WASM boundary crossings.
    pub fn step_n(&mut self, count: u32) -> u32 {
        for i in 0..count {
            if !self.step() {
                return i;
            }
        }
        count
    }
    
    /// Check if the VM has halted (e.g., due to shutdown command).
    pub fn is_halted(&self) -> bool {
        self.halted
    }
    
    /// Get the halt code if the VM has halted.
    /// Code 0x5555 typically means successful shutdown (PASS).
    pub fn halt_code(&self) -> u64 {
        self.halt_code
    }

    /// Get a byte from the UART output buffer, if available.
    /// 
    /// In SMP mode, this checks both the shared UART output buffer (for worker output)
    /// and the local UART buffer (for hart 0 output).
    pub fn get_output(&mut self) -> Option<u8> {
        // First check shared UART output from workers
        if let Some(ref shared_uart) = self.shared_uart_output {
            if let Some(byte) = shared_uart.read_byte() {
                return Some(byte);
            }
        }
        
        // Then check local UART (hart 0 output)
        let byte = self.bus.uart.pop_output();
        // Uncomment for debugging UART output:
        // if let Some(b) = byte {
        //     web_sys::console::log_1(&wasm_bindgen::JsValue::from_str(
        //         &format!("[UART] Output: {:02x} '{}'", b, if b.is_ascii_graphic() { b as char } else { '.' })));
        // }
        byte
    }
    
    /// Check how many bytes are pending in the UART output buffer.
    /// Useful for debugging output issues.
    pub fn uart_output_pending(&self) -> usize {
        self.bus.uart.output_len()
    }
    
    /// Write a string to the UART output buffer (VM host message).
    /// This allows the VM to emit its own messages that the browser can display
    /// alongside kernel output.
    fn emit_to_uart(&mut self, s: &str) {
        self.bus.uart.push_output_str(s);
    }
    
    /// Log a message to both browser console and UART output.
    /// This ensures VM messages appear in both the developer console 
    /// and the terminal UI visible to users.
    fn log_to_uart(&mut self, prefix: &str, message: &str) {
        // Log to browser console
        web_sys::console::log_1(&wasm_bindgen::JsValue::from_str(
            &format!("{} {}", prefix, message)));
        // Also emit to UART so it appears in the terminal UI
        self.emit_to_uart(prefix);
        self.emit_to_uart(" ");
        self.emit_to_uart(message);
        self.emit_to_uart("\n");
    }
    
    /// Print the VM banner to UART output (visible in browser).
    /// Call this after creating the VM to show a boot banner.
    pub fn print_banner(&mut self) {
        let banner = format!("\x1b[1;36m\
┌─────────────────────────────────────────────────────────────────────────┐
│                                                                         │
│   ██████╗  █████╗ ██╗   ██╗██╗   ██╗    ██╗   ██╗███╗   ███╗            │
│   ██╔══██╗██╔══██╗██║   ██║╚██╗ ██╔╝    ██║   ██║████╗ ████║            │
│   ██████╔╝███████║██║   ██║ ╚████╔╝     ██║   ██║██╔████╔██║            │
│   ██╔══██╗██╔══██║╚██╗ ██╔╝  ╚██╔╝      ╚██╗ ██╔╝██║╚██╔╝██║            │
│   ██████╔╝██║  ██║ ╚████╔╝    ██║        ╚████╔╝ ██║ ╚═╝ ██║            │
│   ╚═════╝ ╚═╝  ╚═╝  ╚═══╝     ╚═╝         ╚═══╝  ╚═╝     ╚═╝            │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
\x1b[0m\n");
        self.emit_to_uart(&banner);
    }
    
    /// Print a status message to UART output (visible in browser).
    pub fn print_status(&mut self, message: &str) {
        self.emit_to_uart("\x1b[1;33m[VM]\x1b[0m ");
        self.emit_to_uart(message);
        self.emit_to_uart("\n");
    }

    /// Push an input byte to the UART.
    /// In SMP mode, this also writes to the shared input buffer so workers can receive it.
    pub fn input(&mut self, byte: u8) {
        // Push to local UART for hart 0
        self.bus.uart.push_input(byte);
        
        // Also push to shared input buffer for workers to receive
        if let Some(ref shared_input) = self.shared_uart_input {
            let _ = shared_input.write_byte(byte);
        }
    }

    /// Get current memory usage (DRAM size) in bytes.
    pub fn get_memory_usage(&self) -> u64 {
        self.bus.dram_size() as u64
    }
}

/// Load an ELF kernel into DRAM (WASM-compatible version).
#[cfg(target_arch = "wasm32")]
fn load_elf_wasm(buffer: &[u8], bus: &SystemBus) -> Result<u64, String> {
    use goblin::elf::{program_header::PT_LOAD, Elf};
    
    let elf = Elf::parse(buffer).map_err(|e| format!("ELF parse error: {}", e))?;
    let base = bus.dram_base();
    let dram_end = base + bus.dram_size() as u64;

    for ph in &elf.program_headers {
        if ph.p_type != PT_LOAD || ph.p_memsz == 0 {
            continue;
        }

        let file_size = ph.p_filesz as usize;
        let mem_size = ph.p_memsz as usize;
        let file_offset = ph.p_offset as usize;
        if file_offset + file_size > buffer.len() {
            return Err(format!(
                "ELF segment exceeds file bounds (offset 0x{:x})",
                file_offset
            ));
        }

        let target_addr = if ph.p_paddr != 0 {
            ph.p_paddr
        } else {
            ph.p_vaddr
        };
        if target_addr < base {
            return Err(format!(
                "Segment start 0x{:x} lies below DRAM base 0x{:x}",
                target_addr, base
            ));
        }
        let seg_end = target_addr
            .checked_add(mem_size as u64)
            .ok_or_else(|| "Segment end overflow".to_string())?;
        if seg_end > dram_end {
            return Err(format!(
                "Segment 0x{:x}-0x{:x} exceeds DRAM (end 0x{:x})",
                target_addr, seg_end, dram_end
            ));
        }

        let dram_offset = (target_addr - base) as u64;
        if file_size > 0 {
            let end = file_offset + file_size;
            bus.dram
                .load(&buffer[file_offset..end], dram_offset)
                .map_err(|e| format!("Failed to load segment: {}", e))?;
        }
        if mem_size > file_size {
            let zero_start = dram_offset as usize + file_size;
            bus.dram
                .zero_range(zero_start, mem_size - file_size)
                .map_err(|e| format!("Failed to zero bss: {}", e))?;
        }
    }

    Ok(elf.entry)
}

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub enum Trap {
    InstructionAddressMisaligned(u64),
    InstructionAccessFault(u64),
    IllegalInstruction(u64),
    Breakpoint,
    LoadAddressMisaligned(u64),
    LoadAccessFault(u64),
    StoreAddressMisaligned(u64),
    StoreAccessFault(u64),
    EnvironmentCallFromU,
    EnvironmentCallFromS,
    EnvironmentCallFromM,
    InstructionPageFault(u64),
    LoadPageFault(u64),
    StorePageFault(u64),
    
    MachineSoftwareInterrupt,
    MachineTimerInterrupt,
    MachineExternalInterrupt,
    SupervisorSoftwareInterrupt,
    SupervisorTimerInterrupt,
    SupervisorExternalInterrupt,

    // Custom internal errors
    RequestedTrap(u64), // For testing (software interrupts, etc)
    Fatal(String),
}

impl std::fmt::Display for Trap {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{:?}", self)
    }
}

impl std::error::Error for Trap {}
</file>

<file path="kernel/src/main.rs">
#![no_std]
#![no_main]

// Override riscv-rt's _max_hart_id to allow multiple harts to boot
// This MUST be defined before riscv-rt's startup code runs
// Set to 127 to support up to 128 harts (matching MAX_HARTS)
core::arch::global_asm!(
    ".global _max_hart_id",
    "_max_hart_id = 127"
);

mod allocator;
mod dns;
mod lock;

// Re-export Spinlock for convenience
pub use lock::Spinlock;
mod fs;
mod http;
mod net;
mod scripting;
mod tls;
mod tls12;
mod uart;
mod virtio_blk;
mod virtio_net;

// Process management modules
mod task;
mod scheduler;
mod klog;
mod init;

pub use scheduler::SCHEDULER;

extern crate alloc;
use alloc::{format, string::String, vec::Vec};
use core::arch::asm;
use core::sync::atomic::{fence, AtomicBool, AtomicU64, AtomicUsize, Ordering};
use panic_halt as _;
use riscv_rt::entry;

/// Flag indicating primary boot is complete.
/// Secondary harts spin on this before proceeding.
static BOOT_READY: AtomicBool = AtomicBool::new(false);

/// Counter of harts that have completed initialization.
static HARTS_ONLINE: AtomicUsize = AtomicUsize::new(0);

/// CLINT MSIP register base address.
const CLINT_MSIP_BASE: usize = 0x0200_0000;

/// CLINT hart count register (set by emulator, read by kernel)
const CLINT_HART_COUNT: usize = 0x0200_0F00;

/// Read the hart count from the CLINT register (set by emulator)
fn get_expected_harts() -> usize {
    let count = unsafe { core::ptr::read_volatile(CLINT_HART_COUNT as *const u32) } as usize;
    // Clamp to valid range [1, MAX_HARTS]
    if count == 0 { 1 } else { count.min(MAX_HARTS) }
}

/// Maximum number of harts supported.
/// Set high enough to support modern multi-core systems.
pub const MAX_HARTS: usize = 128;

// ═══════════════════════════════════════════════════════════════════════════════
// BENCHMARK STATE (for multi-hart CPU testing)
// ═══════════════════════════════════════════════════════════════════════════════

/// Benchmark mode for parallel computation
#[derive(Clone, Copy, PartialEq, Eq)]
#[repr(u8)]
enum BenchmarkMode {
    Idle = 0,
    PrimeCount = 1,
}

/// Shared benchmark state for coordinating work across harts
struct BenchmarkState {
    /// Current benchmark mode (0 = idle, 1 = prime counting)
    mode: AtomicUsize,
    /// Start of range for prime counting
    range_start: AtomicU64,
    /// End of range for prime counting  
    range_end: AtomicU64,
    /// Number of harts that should participate
    num_harts: AtomicUsize,
    /// Counter for harts that have completed their work
    completed: AtomicUsize,
    /// Results from each hart (prime counts)
    results: [AtomicU64; MAX_HARTS],
}

impl BenchmarkState {
    const fn new() -> Self {
        const ZERO: AtomicU64 = AtomicU64::new(0);
        Self {
            mode: AtomicUsize::new(0),
            range_start: AtomicU64::new(0),
            range_end: AtomicU64::new(0),
            num_harts: AtomicUsize::new(0),
            completed: AtomicUsize::new(0),
            results: [ZERO; MAX_HARTS],
        }
    }
    
    /// Start a new benchmark
    fn start(&self, mode: BenchmarkMode, start: u64, end: u64, num_harts: usize) {
        // Reset results
        for i in 0..MAX_HARTS {
            self.results[i].store(0, Ordering::Relaxed);
        }
        self.completed.store(0, Ordering::Relaxed);
        self.range_start.store(start, Ordering::Relaxed);
        self.range_end.store(end, Ordering::Relaxed);
        self.num_harts.store(num_harts, Ordering::Relaxed);
        fence(Ordering::SeqCst);
        // Set mode last to signal start
        self.mode.store(mode as usize, Ordering::Release);
    }
    
    /// Clear benchmark (return to idle)
    fn clear(&self) {
        self.mode.store(BenchmarkMode::Idle as usize, Ordering::Release);
    }
    
    /// Check if benchmark is active
    fn is_active(&self) -> bool {
        self.mode.load(Ordering::Acquire) != BenchmarkMode::Idle as usize
    }
    
    /// Get work range for a specific hart
    fn get_work_range(&self, hart_id: usize) -> (u64, u64) {
        let start = self.range_start.load(Ordering::Relaxed);
        let end = self.range_end.load(Ordering::Relaxed);
        let num_harts = self.num_harts.load(Ordering::Relaxed);
        
        if num_harts == 0 || hart_id >= num_harts {
            return (0, 0);
        }
        
        let total_range = end - start;
        let chunk_size = total_range / num_harts as u64;
        
        let my_start = start + (hart_id as u64 * chunk_size);
        let my_end = if hart_id == num_harts - 1 {
            end // Last hart takes remainder
        } else {
            my_start + chunk_size
        };
        
        (my_start, my_end)
    }
    
    /// Report result from a hart
    fn report_result(&self, hart_id: usize, count: u64) {
        if hart_id < MAX_HARTS {
            self.results[hart_id].store(count, Ordering::Relaxed);
        }
        fence(Ordering::SeqCst);
        self.completed.fetch_add(1, Ordering::SeqCst);
    }
    
    /// Get total result from all harts
    fn total_result(&self) -> u64 {
        let mut total = 0u64;
        let num_harts = self.num_harts.load(Ordering::Relaxed);
        for i in 0..num_harts {
            total += self.results[i].load(Ordering::Relaxed);
        }
        total
    }
    
    /// Check if all harts have completed
    fn all_completed(&self) -> bool {
        let num_harts = self.num_harts.load(Ordering::Relaxed);
        self.completed.load(Ordering::Acquire) >= num_harts
    }
}

/// Global benchmark state
static BENCHMARK: BenchmarkState = BenchmarkState::new();

// ═══════════════════════════════════════════════════════════════════════════════
// PRIME NUMBER FUNCTIONS (for CPU benchmarking)
// ═══════════════════════════════════════════════════════════════════════════════

/// Check if a number is prime using trial division
/// Optimized with early exits and only checking up to sqrt(n)
#[inline(never)] // Prevent inlining to ensure fair timing
fn is_prime(n: u64) -> bool {
    if n < 2 {
        return false;
    }
    if n == 2 {
        return true;
    }
    if n % 2 == 0 {
        return false;
    }
    if n == 3 {
        return true;
    }
    if n % 3 == 0 {
        return false;
    }
    
    // Check divisors of form 6k±1 up to sqrt(n)
    let mut i = 5u64;
    while i * i <= n {
        if n % i == 0 || n % (i + 2) == 0 {
            return false;
        }
        i += 6;
    }
    true
}

/// Count primes in a range [start, end)
#[inline(never)]
fn count_primes_in_range(start: u64, end: u64) -> u64 {
    let mut count = 0u64;
    for n in start..end {
        if is_prime(n) {
            count += 1;
        }
    }
    count
}

/// Multi-processing hook called by riscv-rt before main().
///
/// - Hart 0: Returns true to continue to main()
/// - Other harts: Enter parking loop, call secondary_hart_entry when woken
/// 
/// # Safety
/// This is called very early in boot, before Rust runtime is fully initialized.
/// Only use assembly and no allocations.
#[export_name = "_mp_hook"]
#[inline(never)]
pub unsafe extern "C" fn mp_hook() -> bool {
    let hart_id: usize;
    asm!(
        "csrr {}, mhartid",
        out(reg) hart_id,
        options(nomem, nostack, preserves_flags)
    );

    if hart_id == 0 {
        // Primary hart: continue to main()
        true
    } else {
        // Secondary harts: park and wait for IPI
        secondary_hart_park(hart_id);
        // Never returns, but we need to satisfy the return type
        // This is unreachable
    }
}

/// Secondary hart parking loop.
///
/// Waits for IPI, then transfers to secondary_hart_entry.
/// 
/// # Safety
/// Called very early in boot, before Rust runtime is fully initialized.
#[inline(never)]
unsafe fn secondary_hart_park(hart_id: usize) -> ! {
    // Wait for IPI to wake us
    loop {
        asm!("wfi", options(nomem, nostack));
        
        // Check if this was our wake-up call
        if is_msip_pending(hart_id) {
            // Clear the interrupt
            clear_msip(hart_id);
            break;
        }
        // Spurious wakeup - go back to sleep
    }
    
    // Transfer to secondary entry point
    secondary_hart_entry(hart_id);
}

/// Get the current hart ID from mhartid CSR.
#[inline]
pub fn get_hart_id() -> usize {
    let id: usize;
    unsafe {
        asm!("csrr {}, mhartid", out(reg) id, options(nomem, nostack));
    }
    id
}

/// Entry point for secondary harts (called after waking from WFI).
/// 
/// This function is called after the secondary hart has:
/// 1. Been woken by an IPI from the primary hart
/// 2. Checked that BOOT_READY is true
/// 
/// # Arguments
/// * `hart_id` - This hart's ID (1, 2, 3, ...)
fn secondary_hart_entry(hart_id: usize) -> ! {
    // Wait for primary boot to complete (double-check after WFI wake)
    while !BOOT_READY.load(Ordering::Acquire) {
        core::hint::spin_loop();
    }
    
    // Memory fence ensures we see all init writes from primary hart
    fence(Ordering::SeqCst);
    
    // Register this hart as online
    HARTS_ONLINE.fetch_add(1, Ordering::SeqCst);
    
   
    
    // Enter the secondary hart idle loop
    secondary_hart_idle(hart_id);
}

/// Secondary hart idle loop.
/// 
/// Secondary harts wait for work (IPI wakeup), then check for:
/// 1. Benchmark tasks (high priority, checked first)
/// 2. Scheduler tasks (including long-running daemons)
fn secondary_hart_idle(hart_id: usize) -> ! {
    loop {
        // Wait for work via IPI - this is the primary coordination mechanism
        unsafe {
            core::arch::asm!("wfi", options(nomem, nostack));
        }
        
        // Check if we were woken by an IPI
        if !is_my_msip_pending() {
            // Spurious wakeup - go back to sleep
            continue;
        }
        
        // Clear the IPI
        clear_my_msip();
        
        // Check for benchmark work first (high priority)
        if BENCHMARK.is_active() {
            let mode = BENCHMARK.mode.load(Ordering::Acquire);
            if mode == BenchmarkMode::PrimeCount as usize {
                // Get our work range
                let (start, end) = BENCHMARK.get_work_range(hart_id);
                if start < end {
                    // Count primes in our range
                    let count = count_primes_in_range(start, end);
                    // Report result
                    BENCHMARK.report_result(hart_id, count);
                } else {
                    // No work for this hart
                    BENCHMARK.report_result(hart_id, 0);
                }
                continue;
            }
        }
        
        // Check for scheduler tasks
        if SCHEDULER.is_running() {
            if let Some(task) = SCHEDULER.pick_next(hart_id) {
                // Mark task as running on this hart
                task.mark_running(hart_id);
                
                let start_time = get_time_ms() as u64;
                
                // Execute the task's entry point
                // Note: Daemon tasks have infinite loops and won't return
                (task.entry)();
                
                // If we get here, the task returned (non-daemon or daemon that exited)
                let elapsed = (get_time_ms() as u64).saturating_sub(start_time);
                task.add_cpu_time(elapsed);
                
                // Mark task as finished
                SCHEDULER.finish_task(task.pid, 0);
            }
        }
    }
}

/// Send an Inter-Processor Interrupt to the specified hart.
///
/// This triggers a `MachineSoftwareInterrupt` on the target hart,
/// waking it from WFI if sleeping.
///
/// # Arguments
/// * `hart_id` - The target hart ID (0-7)
///
/// # Safety
/// This function writes to MMIO registers but is safe to call
/// from any context.
#[inline]
pub fn send_ipi(hart_id: usize) {
    if hart_id >= MAX_HARTS {
        return; // Invalid hart ID, silently ignore
    }

    let msip_addr = CLINT_MSIP_BASE + (hart_id * 4);

    // Write 1 to MSIP[hart_id] to trigger software interrupt
    unsafe {
        core::ptr::write_volatile(msip_addr as *mut u32, 1);
    }

    // Memory fence to ensure write is visible
    fence(Ordering::SeqCst);
}

/// Send IPI to all harts except the caller.
///
/// Useful for broadcast notifications.
#[allow(dead_code)]
pub fn send_ipi_all_others() {
    let my_hart = get_hart_id();
    let expected_harts = get_expected_harts();
    for hart in 0..expected_harts {
        if hart != my_hart {
            send_ipi(hart);
        }
    }
}

/// Clear the software interrupt for a hart.
///
/// Must be called by the target hart to acknowledge the IPI.
/// Typically called in the software interrupt handler.
#[inline]
pub fn clear_msip(hart_id: usize) {
    if hart_id >= MAX_HARTS {
        return;
    }
    let msip_addr = CLINT_MSIP_BASE + (hart_id * 4);
    unsafe {
        core::ptr::write_volatile(msip_addr as *mut u32, 0);
    }
}

/// Clear the software interrupt for the current hart.
#[inline]
#[allow(dead_code)]
pub fn clear_my_msip() {
    clear_msip(get_hart_id());
}

/// Check if software interrupt is pending for a hart.
#[inline]
#[allow(dead_code)]
pub fn is_msip_pending(hart_id: usize) -> bool {
    if hart_id >= MAX_HARTS {
        return false;
    }
    let msip_addr = CLINT_MSIP_BASE + (hart_id * 4);
    unsafe { core::ptr::read_volatile(msip_addr as *const u32) & 1 != 0 }
}

/// Check if software interrupt is pending for current hart.
#[inline]
#[allow(dead_code)]
pub fn is_my_msip_pending() -> bool {
    is_msip_pending(get_hart_id())
}

const CLINT_MTIME: usize = 0x0200_BFF8;
const TEST_FINISHER: usize = 0x0010_0000;

// ═══════════════════════════════════════════════════════════════════════════════
// SPINLOCK-PROTECTED GLOBAL STATE
// ═══════════════════════════════════════════════════════════════════════════════

/// Network state, protected by spinlock.
static NET_STATE: Spinlock<Option<net::NetState>> = Spinlock::new(None);

/// Filesystem state, protected by spinlock.
static FS_STATE: Spinlock<Option<fs::FileSystem>> = Spinlock::new(None);

/// Block device, protected by spinlock.
static BLK_DEV: Spinlock<Option<virtio_blk::VirtioBlock>> = Spinlock::new(None);

/// State for continuous ping (like Linux ping command)
struct PingState {
    target: smoltcp::wire::Ipv4Address,
    seq: u16,
    sent_time: i64,           // Time when current ping was sent
    last_send_time: i64,      // Time when we last sent a ping (for 1s interval)
    waiting: bool,            // Waiting for reply to current ping
    continuous: bool,         // Whether running in continuous mode
    // Statistics
    packets_sent: u32,
    packets_received: u32,
    min_rtt: i64,
    max_rtt: i64,
    total_rtt: i64,
}

impl PingState {
    fn new(target: smoltcp::wire::Ipv4Address, timestamp: i64) -> Self {
        PingState {
            target,
            seq: 0,
            sent_time: timestamp,
            last_send_time: 0,
            waiting: false,
            continuous: true,
            packets_sent: 0,
            packets_received: 0,
            min_rtt: i64::MAX,
            max_rtt: 0,
            total_rtt: 0,
        }
    }
    
    fn record_reply(&mut self, rtt: i64) {
        self.packets_received += 1;
        self.total_rtt += rtt;
        if rtt < self.min_rtt {
            self.min_rtt = rtt;
        }
        if rtt > self.max_rtt {
            self.max_rtt = rtt;
        }
    }
    
    fn avg_rtt(&self) -> i64 {
        if self.packets_received > 0 {
            self.total_rtt / self.packets_received as i64
        } else {
            0
        }
    }
    
    fn packet_loss_percent(&self) -> u32 {
        if self.packets_sent > 0 {
            ((self.packets_sent - self.packets_received) * 100) / self.packets_sent
        } else {
            0
        }
    }
}

/// Ping state, protected by spinlock.
static PING_STATE: Spinlock<Option<PingState>> = Spinlock::new(None);

/// Command running flag, protected by spinlock.
static COMMAND_RUNNING: Spinlock<bool> = Spinlock::new(false);

// ─── CURRENT WORKING DIRECTORY ────────────────────────────────────────────────
const CWD_MAX_LEN: usize = 128;

/// Current working directory state
struct CwdState {
    path: [u8; CWD_MAX_LEN],
    len: usize,
}

impl CwdState {
    const fn new() -> Self {
        let mut path = [0u8; CWD_MAX_LEN];
        path[0] = b'/';
        Self { path, len: 1 }
    }
}

/// Current working directory, protected by spinlock.
static CWD_STATE: Spinlock<CwdState> = Spinlock::new(CwdState::new());

/// Initialize CWD to root
fn cwd_init() {
    let mut cwd = CWD_STATE.lock();
    cwd.path[0] = b'/';
    cwd.len = 1;
}

/// Get current working directory as String
pub fn cwd_get() -> alloc::string::String {
    let cwd = CWD_STATE.lock();
    core::str::from_utf8(&cwd.path[..cwd.len])
        .unwrap_or("/")
        .into()
}

/// Set current working directory
fn cwd_set(path: &str) {
    let mut cwd = CWD_STATE.lock();
    let bytes = path.as_bytes();
    let len = core::cmp::min(bytes.len(), CWD_MAX_LEN);
    cwd.path[..len].copy_from_slice(&bytes[..len]);
    cwd.len = len;
}

// ─── OUTPUT CAPTURE FOR REDIRECTION ────────────────────────────────────────────
const OUTPUT_BUFFER_SIZE: usize = 4096;

/// Output capture state for redirection
struct OutputCapture {
    buffer: [u8; OUTPUT_BUFFER_SIZE],
    len: usize,
    capturing: bool,
}

impl OutputCapture {
    const fn new() -> Self {
        Self {
            buffer: [0u8; OUTPUT_BUFFER_SIZE],
            len: 0,
            capturing: false,
        }
    }
}

/// Output capture state, protected by spinlock.
static OUTPUT_CAPTURE: Spinlock<OutputCapture> = Spinlock::new(OutputCapture::new());

/// Start capturing output to the buffer
fn output_capture_start() {
    let mut cap = OUTPUT_CAPTURE.lock();
    cap.capturing = true;
    cap.len = 0;
}

/// Stop capturing and return the captured bytes as a Vec
fn output_capture_stop() -> Vec<u8> {
    let mut cap = OUTPUT_CAPTURE.lock();
    cap.capturing = false;
    Vec::from(&cap.buffer[..cap.len])
}

/// Write a string - respects capture mode
fn out_str(s: &str) {
    let mut cap = OUTPUT_CAPTURE.lock();
    if cap.capturing {
        for &b in s.as_bytes() {
            let idx = cap.len;
            if idx < OUTPUT_BUFFER_SIZE {
                cap.buffer[idx] = b;
                cap.len += 1;
            }
        }
    } else {
        drop(cap); // Release lock before UART
        uart::write_str(s);
    }
}

/// Write a string with newline - respects capture mode
fn out_line(s: &str) {
    out_str(s);
    out_str("\n");
}

/// Write bytes - respects capture mode
fn out_bytes(bytes: &[u8]) {
    let mut cap = OUTPUT_CAPTURE.lock();
    if cap.capturing {
        for &b in bytes {
            let idx = cap.len;
            if idx < OUTPUT_BUFFER_SIZE {
                cap.buffer[idx] = b;
                cap.len += 1;
            }
        }
    } else {
        drop(cap); // Release lock before UART
        uart::write_bytes(bytes);
    }
}

/// Write u64 - respects capture mode
fn out_u64(n: u64) {
    let mut cap = OUTPUT_CAPTURE.lock();
    if cap.capturing {
        if n == 0 {
            let idx = cap.len;
            if idx < OUTPUT_BUFFER_SIZE {
                cap.buffer[idx] = b'0';
                cap.len += 1;
            }
            return;
        }
        let mut buf = [0u8; 20];
        let mut i = 0;
        let mut val = n;
        while val > 0 && i < buf.len() {
            buf[i] = b'0' + (val % 10) as u8;
            val /= 10;
            i += 1;
        }
        while i > 0 {
            i -= 1;
            let idx = cap.len;
            if idx < OUTPUT_BUFFER_SIZE {
                cap.buffer[idx] = buf[i];
                cap.len += 1;
            }
        }
    } else {
        drop(cap); // Release lock before UART
        uart::write_u64(n);
    }
}

/// Write hex - respects capture mode  
fn out_hex(n: u64) {
    let mut cap = OUTPUT_CAPTURE.lock();
    if cap.capturing {
        let hex_digits = b"0123456789abcdef";
        if n == 0 {
            let idx = cap.len;
            if idx < OUTPUT_BUFFER_SIZE {
                cap.buffer[idx] = b'0';
                cap.len += 1;
            }
            return;
        }
        let mut buf = [0u8; 16];
        let mut i = 0;
        let mut val = n;
        while val > 0 && i < buf.len() {
            buf[i] = hex_digits[(val & 0xf) as usize];
            val >>= 4;
            i += 1;
        }
        while i > 0 {
            i -= 1;
            let idx = cap.len;
            if idx < OUTPUT_BUFFER_SIZE {
                cap.buffer[idx] = buf[i];
                cap.len += 1;
            }
        }
    } else {
        drop(cap); // Release lock before UART
        uart::write_hex(n);
    }
}

#[derive(Clone, Copy, PartialEq)]
enum RedirectMode {
    None,
    Overwrite, // >
    Append,    // >>
}

/// Read current time in milliseconds from CLINT mtime register
pub fn get_time_ms() -> i64 {
    let mtime = unsafe { core::ptr::read_volatile(CLINT_MTIME as *const u64) };
    (mtime / 10_000) as i64
}

/// Print a section header
fn print_section(title: &str) {
    uart::write_line("");
    uart::write_line("\x1b[1;33m────────────────────────────────────────────────────────────────────────\x1b[0m");
    uart::write_str("\x1b[1;33m  ◆ ");
    uart::write_str(title);
    uart::write_line("\x1b[0m");
    uart::write_line("\x1b[1;33m────────────────────────────────────────────────────────────────────────\x1b[0m");
}

/// Print a boot status line
fn print_boot_status(component: &str, ok: bool) {
    if ok {
        uart::write_str("    \x1b[1;32m[✓]\x1b[0m ");
    } else {
        uart::write_str("    \x1b[1;31m[✗]\x1b[0m ");
    }
    uart::write_line(component);
}

/// Print a boot info line
fn print_boot_info(key: &str, value: &str) {
    uart::write_str("    \x1b[0;90m├─\x1b[0m ");
    uart::write_str(key);
    uart::write_str(": \x1b[1;97m");
    uart::write_str(value);
    uart::write_line("\x1b[0m");
}

#[entry]
fn main() -> ! {
    // ═══════════════════════════════════════════════════════════════════
    // VERIFY WE'RE THE PRIMARY HART
    // ═══════════════════════════════════════════════════════════════════
    
    let hart_id = get_hart_id();
    if hart_id != 0 {
        // Should never happen if _mp_hook works correctly
        loop { unsafe { asm!("wfi"); } }
    }

    // ─── CPU & ARCHITECTURE INFO ──────────────────────────────────────────────
    print_section("CPU & ARCHITECTURE");
    print_boot_info("Primary Hart", "0");
    print_boot_info("Architecture", "RISC-V 64-bit (RV64GC)");
    print_boot_info("Mode", "Machine Mode (M-Mode)");
    print_boot_info("Timer Source", "CLINT @ 0x02000000");
    print_boot_status("CPU initialized", true);
    
    // ─── MEMORY SUBSYSTEM ─────────────────────────────────────────────────────
    print_section("MEMORY SUBSYSTEM");
    allocator::init();
    let total_heap = allocator::heap_size();
    uart::write_str("    \x1b[0;90m├─\x1b[0m Heap Base: \x1b[1;97m0x");
    uart::write_hex(0x8080_0000u64); // Approximate heap start
    uart::write_line("\x1b[0m");
    uart::write_str("    \x1b[0;90m├─\x1b[0m Heap Size: \x1b[1;97m");
    uart::write_u64(total_heap as u64 / 1024);
    uart::write_line(" KiB\x1b[0m");
    print_boot_status("Heap allocator ready", true);
    
    // ─── STORAGE SUBSYSTEM ────────────────────────────────────────────────────
    init_storage();
    
    // ─── SCRIPTING ENGINE ──────────────────────────────────────────────────────
    // Preload scripts from /usr/bin/ into AST cache for faster first execution
    scripting::preload_scripts();
    
    // ─── NETWORK SUBSYSTEM ────────────────────────────────────────────────────
    print_section("NETWORK SUBSYSTEM");
    init_network();
    
    // ═══════════════════════════════════════════════════════════════════
    // SMP INITIALIZATION
    // ═══════════════════════════════════════════════════════════════════
    
    print_section("SMP INITIALIZATION");
    
    // Read expected hart count from emulator (CLINT register)
    let expected_harts = get_expected_harts();
    print_boot_info("Expected harts", &format!("{}", expected_harts));
    
    // Memory fence ensures all init writes are visible to other harts
    fence(Ordering::SeqCst);
    
    // Signal that boot is complete
    BOOT_READY.store(true, Ordering::Release);
    
    // Register primary hart as online
    HARTS_ONLINE.fetch_add(1, Ordering::SeqCst);
    print_boot_info("Primary hart", "online");
    
    // Wake secondary harts via IPI
    for hart in 1..expected_harts {
        uart::write_str("    Sending IPI to hart ");
        uart::write_u64(hart as u64);
        uart::write_line("");
        send_ipi(hart);
    }
    
    // Wait for all harts to come online (with timeout)
    let timeout = get_time_ms() + 1000; // 1 second timeout
    while HARTS_ONLINE.load(Ordering::Acquire) < expected_harts {
        if get_time_ms() > timeout {
            uart::write_str("    \x1b[1;33m[!]\x1b[0m Warning: Only ");
            uart::write_u64(HARTS_ONLINE.load(Ordering::Relaxed) as u64);
            uart::write_str("/");
            uart::write_u64(expected_harts as u64);
            uart::write_line(" harts online after timeout");
            break;
        }
        core::hint::spin_loop();
    }
    
    let online = HARTS_ONLINE.load(Ordering::Relaxed);
    uart::write_str("    \x1b[1;32m[✓]\x1b[0m Harts online: ");
    uart::write_u64(online as u64);
    uart::write_str("/");
    uart::write_u64(expected_harts as u64);
    uart::write_line("");
    
    // ═══════════════════════════════════════════════════════════════════
    // PROCESS MANAGER INITIALIZATION
    // ═══════════════════════════════════════════════════════════════════
    
    print_section("PROCESS MANAGER");
    
    // Initialize scheduler with number of online harts
    SCHEDULER.init(online);
    print_boot_status("Scheduler initialized", true);
    print_boot_info("Run queues", &format!("{} (one per hart)", online));
    
    // Run init directly on primary hart (spawns daemons to secondary harts)
    // Note: We don't spawn init as a task - it runs synchronously during boot
    print_boot_info("Init process", "running");
    init::init_main();
    
    // Report services started
    let services = init::service_count();
    print_boot_status(&format!("System services started ({})", services), services > 0);
    
    // ─── BOOT COMPLETE ────────────────────────────────────────────────────────
    print_section(&format!("\x1b[1;97mBAVY OS BOOT COMPLETE!\x1b[0m"));
    uart::write_line("");
    uart::write_line("");

    cwd_init();
    print_prompt();

    let console = uart::Console::new();
    let mut buffer = [0u8; 128];
    let mut len = 0usize;
    let mut count: usize = 0;
    let mut last_newline: u8 = 0; // Track last newline char to handle \r\n sequences
    
    // Command history
    const HISTORY_SIZE: usize = 16;
    let mut history: [[u8; 128]; HISTORY_SIZE] = [[0u8; 128]; HISTORY_SIZE];
    let mut history_lens: [usize; HISTORY_SIZE] = [0; HISTORY_SIZE];
    let mut history_count: usize = 0;  // Total commands stored
    let mut history_pos: usize = 0;    // Current position when navigating (0 = newest)
    let mut browsing_history: bool = false;
    
    // Escape sequence state
    let mut esc_state: u8 = 0; // 0 = normal, 1 = got ESC, 2 = got ESC[

    loop {
        // Poll network stack
        poll_network();
        
        let byte = console.read_byte();

        // 0 means "no input" in our UART model
        if byte == 0 {
            continue;
        }
        
        // Check for Ctrl+C (0x03) to cancel running commands
        if byte == 0x03 {
            if cancel_running_command() {
                // Command was cancelled, print new prompt
                print_prompt();
                len = 0;
                browsing_history = false;
                history_pos = 0;
            }
            continue;
        }
        
        // Handle escape sequences for arrow keys
        if esc_state == 1 {
            if byte == b'[' {
                esc_state = 2;
                continue;
            } else {
                esc_state = 0;
                // Fall through to handle the byte normally
            }
        } else if esc_state == 2 {
            esc_state = 0;
            match byte {
                b'A' => {
                    // Up arrow - go to older command
                    if history_count > 0 {
                        let max_pos = if history_count < HISTORY_SIZE { history_count } else { HISTORY_SIZE };
                        if history_pos < max_pos {
                            if !browsing_history {
                                browsing_history = true;
                                history_pos = 0;
                            }
                            if history_pos < max_pos {
                                // Clear current line
                                clear_input_line(len);
                                
                                // Get command from history (0 = most recent)
                                let idx = ((history_count - 1 - history_pos) % HISTORY_SIZE) as usize;
                                len = history_lens[idx];
                                buffer[..len].copy_from_slice(&history[idx][..len]);
                                
                                // Display the command
                                uart::write_bytes(&buffer[..len]);
                                
                                if history_pos + 1 < max_pos {
                                    history_pos += 1;
                                }
                            }
                        }
                    }
                    continue;
                }
                b'B' => {
                    // Down arrow - go to newer command
                    if browsing_history && history_pos > 0 {
                        history_pos -= 1;
                        
                        // Clear current line
                        clear_input_line(len);
                        
                        if history_pos == 0 {
                            // Back to empty line (current input)
                            browsing_history = false;
                            len = 0;
                        } else {
                            // Get command from history
                            let idx = ((history_count - history_pos) % HISTORY_SIZE) as usize;
                            len = history_lens[idx];
                            buffer[..len].copy_from_slice(&history[idx][..len]);
                            
                            // Display the command
                            uart::write_bytes(&buffer[..len]);
                        }
                    } else if browsing_history {
                        // At position 0, clear and go back to empty
                        clear_input_line(len);
                        browsing_history = false;
                        len = 0;
                    }
                    continue;
                }
                b'C' | b'D' => {
                    // Right/Left arrow - ignore for now
                    continue;
                }
                _ => {
                    // Unknown escape sequence, ignore
                    continue;
                }
            }
        }

        match byte {
            0x1b => {
                // ESC - start of escape sequence
                esc_state = 1;
            }
            b'\r' | b'\n' => {
                // Skip second char of \r\n or \n\r sequence
                if (last_newline == b'\r' && byte == b'\n') || (last_newline == b'\n' && byte == b'\r') {
                    last_newline = 0;
                    continue;
                }
                last_newline = byte;
                uart::write_line("");  // Echo the newline
                
                // Save to history if non-empty
                if len > 0 {
                    let idx = history_count % HISTORY_SIZE;
                    history[idx][..len].copy_from_slice(&buffer[..len]);
                    history_lens[idx] = len;
                    history_count += 1;
                }
                
                handle_line(&buffer, len, &mut count);
                print_prompt();
                len = 0;
                browsing_history = false;
                history_pos = 0;
            }
            // Backspace / Delete
            8 | 0x7f => {
                if len > 0 {
                    len -= 1;
                    // Move cursor back, erase char, move back again.
                    // (Simple TTY-style backspace handling.)
                    uart::write_str("\u{8} \u{8}");
                }
            }
            // Tab - autocomplete
            b'\t' => {
                last_newline = 0;
                let new_len = handle_tab_completion(&mut buffer, len);
                len = new_len;
            }
            _ => {
                last_newline = 0; // Reset newline tracking on regular input
                if len < buffer.len() {
                    buffer[len] = byte;
                    len += 1;
                    uart::Console::new().write_byte(byte);
                }
            }
        }
    }
}

/// Clear the current input line on the terminal
fn clear_input_line(len: usize) {
    // Move cursor back and clear each character
    for _ in 0..len {
        uart::write_str("\u{8} \u{8}");
    }
}

/// Handle tab completion
/// Returns the new buffer length after completion
fn handle_tab_completion(buffer: &mut [u8], len: usize) -> usize {
    use alloc::string::String;
    use alloc::vec::Vec;
    
    if len == 0 {
        return 0;
    }
    
    let input = match core::str::from_utf8(&buffer[..len]) {
        Ok(s) => s,
        Err(_) => return len,
    };
    
    // Find the word being completed (last space-separated token)
    let last_space = input.rfind(' ');
    let (prefix, word_to_complete) = match last_space {
        Some(pos) => (&input[..=pos], &input[pos+1..]),
        None => ("", input),
    };
    
    let is_command = prefix.is_empty();
    
    let mut matches: Vec<String> = Vec::new();
    
    if is_command {
        // Complete commands - check built-ins first
        let builtins = [
            "clear", "shutdown", "cd", "pwd", "ping", "nslookup", "node", "help",
            "ls", "cat", "echo", "cowsay", "sysinfo", "ip", "netstat", "memstats",
            "uptime", "write", "wget",
        ];
        
        for cmd in builtins.iter() {
            if cmd.starts_with(word_to_complete) {
                matches.push(String::from(*cmd));
            }
        }
        
        // Also check /usr/bin/ for scripts
        {
            let fs_guard = FS_STATE.lock();
            let mut blk_guard = BLK_DEV.lock();
            if let (Some(fs), Some(dev)) = (fs_guard.as_ref(), blk_guard.as_mut()) {
                let files = fs.list_dir(dev, "/");
                for f in files {
                    if f.name.starts_with("/usr/bin/") {
                        let script_name = &f.name[9..]; // Strip "/usr/bin/"
                        if script_name.starts_with(word_to_complete) {
                            // Avoid duplicates with builtins
                            if !matches.iter().any(|m| m == script_name) {
                                matches.push(String::from(script_name));
                            }
                        }
                    }
                }
            }
        }
    } else {
        // Complete file/directory paths
        let path_to_complete = if word_to_complete.starts_with('/') {
            String::from(word_to_complete)
        } else {
            resolve_path(word_to_complete)
        };
        
        // Find the directory part and file prefix
        let (dir_path, file_prefix) = if let Some(last_slash) = path_to_complete.rfind('/') {
            if last_slash == 0 {
                ("/", &path_to_complete[1..])
            } else {
                (&path_to_complete[..last_slash], &path_to_complete[last_slash+1..])
            }
        } else {
            ("/", path_to_complete.as_str())
        };
        
        {
            let fs_guard = FS_STATE.lock();
            let mut blk_guard = BLK_DEV.lock();
            if let (Some(fs), Some(dev)) = (fs_guard.as_ref(), blk_guard.as_mut()) {
                let files = fs.list_dir(dev, "/");
                let mut seen_dirs: Vec<String> = Vec::new();
                
                for f in files {
                    // Check if file is in the target directory
                    let check_prefix = if dir_path == "/" {
                        "/"
                    } else {
                        dir_path
                    };
                    
                    if !f.name.starts_with(check_prefix) {
                        continue;
                    }
                    
                    // Get the part after the directory
                    let relative = if dir_path == "/" {
                        &f.name[1..]
                    } else if f.name.len() > check_prefix.len() + 1 {
                        &f.name[check_prefix.len() + 1..]
                    } else {
                        continue;
                    };
                    
                    // Get just the immediate child (first path component)
                    let child_name = if let Some(slash_pos) = relative.find('/') {
                        &relative[..slash_pos]
                    } else {
                        relative
                    };
                    
                    if child_name.is_empty() {
                        continue;
                    }
                    
                    // Check if it matches the prefix
                    if !child_name.starts_with(file_prefix) {
                        continue;
                    }
                    
                    // Check if this is a directory (has more path after)
                    let is_dir = relative.len() > child_name.len();
                    
                    let completion = if is_dir {
                        let dir_name = String::from(child_name) + "/";
                        if seen_dirs.contains(&dir_name) {
                            continue;
                        }
                        seen_dirs.push(dir_name.clone());
                        dir_name
                    } else {
                        String::from(child_name)
                    };
                    
                    if !matches.iter().any(|m| m == &completion) {
                        matches.push(completion);
                    }
                }
            }
        }
    }
    
    matches.sort();
    
    if matches.is_empty() {
        // No matches - beep or do nothing
        return len;
    }
    
    if matches.len() == 1 {
        // Single match - complete it
        let completion = &matches[0];
        let to_add = &completion[word_to_complete.len()..];
        
        // Add completion to buffer
        let new_len = len + to_add.len();
        if new_len <= buffer.len() {
            for (i, b) in to_add.bytes().enumerate() {
                buffer[len + i] = b;
            }
            uart::write_str(to_add);
            
            // Add space after command completion (not for paths ending in /)
            if is_command && new_len + 1 <= buffer.len() {
                buffer[new_len] = b' ';
                uart::write_str(" ");
                return new_len + 1;
            }
            
            return new_len;
        }
        return len;
    }
    
    // Multiple matches - find common prefix and show options
    let common = find_common_prefix(&matches);
    
    if common.len() > word_to_complete.len() {
        // Complete up to common prefix
        let to_add = &common[word_to_complete.len()..];
        let new_len = len + to_add.len();
        if new_len <= buffer.len() {
            for (i, b) in to_add.bytes().enumerate() {
                buffer[len + i] = b;
            }
            uart::write_str(to_add);
            return new_len;
        }
        return len;
    }
    
    // Show all matches
    uart::write_line("");
    let mut col = 0;
    let col_width = 16;
    let num_cols = 4;
    
    for m in &matches {
        let display_len = m.len();
        uart::write_str(m);
        
        col += 1;
        if col >= num_cols {
            uart::write_line("");
            col = 0;
        } else {
            // Pad to column width
            for _ in display_len..col_width {
                uart::write_str(" ");
            }
        }
    }
    if col > 0 {
        uart::write_line("");
    }
    
    // Redraw prompt and current input
    print_prompt();
    uart::write_bytes(&buffer[..len]);
    
    len
}

/// Find common prefix among strings
fn find_common_prefix(strings: &[alloc::string::String]) -> alloc::string::String {
    use alloc::string::String;
    
    if strings.is_empty() {
        return String::new();
    }
    
    let first = &strings[0];
    let mut prefix_len = first.len();
    
    for s in strings.iter().skip(1) {
        let mut common = 0;
        for (a, b) in first.chars().zip(s.chars()) {
            if a == b && common < prefix_len {
                common += 1;
            } else {
                break;
            }
        }
        prefix_len = common;
    }
    
    String::from(&first[..prefix_len])
}


fn init_storage() {
    print_section("STORAGE SUBSYSTEM");
    if let Some(blk) = virtio_blk::VirtioBlock::probe() {
        uart::write_str("    \x1b[0;90m├─\x1b[0m Block Device: \x1b[1;97m");
        uart::write_u64(blk.capacity() * 512 / 1024 / 1024);
        uart::write_line(" MiB\x1b[0m");
        *BLK_DEV.lock() = Some(blk);
        print_boot_status("VirtIO-Block driver loaded", true);
    } else {
        print_boot_status("No storage device found", false);
    }
    
    let mut blk_guard = BLK_DEV.lock();
    if let Some(ref mut blk) = *blk_guard {
        if let Some(fs) = fs::FileSystem::init(blk) {
            uart::write_line("    \x1b[1;32m[✓]\x1b[0m SFS Mounted (R/W)");
            *FS_STATE.lock() = Some(fs);
        }
    }
}

fn init_fs() {
    if let Some(blk) = virtio_blk::VirtioBlock::probe() {
        uart::write_line("    \x1b[1;32m[✓]\x1b[0m VirtIO Block found");
        *BLK_DEV.lock() = Some(blk);
        
        let mut blk_guard = BLK_DEV.lock();
        if let Some(ref mut dev) = *blk_guard {
            if let Some(fs) = fs::FileSystem::init(dev) {
                *FS_STATE.lock() = Some(fs);
                uart::write_line("    \x1b[1;32m[✓]\x1b[0m FileSystem Mounted");
            }
        }
    }
}

/// Initialize the network stack
fn init_network() {
    uart::write_line("    \x1b[0;90m├─\x1b[0m Probing for VirtIO devices...");
    
    // Probe for VirtIO network device
    match virtio_net::VirtioNet::probe() {
        Some(device) => {
            uart::write_str("    \x1b[0;90m├─\x1b[0m VirtIO-Net found at: \x1b[1;97m0x");
            uart::write_hex(device.base_addr() as u64);
            uart::write_line("\x1b[0m");
            
            match net::NetState::new(device) {
                Ok(state) => {
                    // Store in static FIRST, then finalize
                    {
                        let mut net_guard = NET_STATE.lock();
                        *net_guard = Some(state);
                        if let Some(ref mut s) = *net_guard {
                            s.finalize();
                            
                            // Print network configuration
                            uart::write_line("");
                            uart::write_str("    \x1b[0m  MAC Address:   \x1b[1;97m");
                            uart::write_bytes(&s.mac_str());
                            uart::write_line("\x1b[0m                    \x1b[0m");
                            
                            let mut ip_buf = [0u8; 16];
                            let my_ip = net::get_my_ip();
                            let ip_len = net::format_ipv4(my_ip, &mut ip_buf);
                            uart::write_str("    \x1b[0m  IPv4 Address:  \x1b[1;97m");
                            uart::write_bytes(&ip_buf[..ip_len]);
                            uart::write_str("/");
                            uart::write_u64(net::PREFIX_LEN as u64);
                            uart::write_line("\x1b[0m                   \x1b[0m");
                            
                            let gw_len = net::format_ipv4(net::GATEWAY, &mut ip_buf);
                            uart::write_str("    \x1b[0m  Gateway:       \x1b[1;97m");
                            uart::write_bytes(&ip_buf[..gw_len]);
                            uart::write_line("\x1b[0m                       \x1b[0m");
                            
                            let dns_len = net::format_ipv4(net::DNS_SERVER, &mut ip_buf);
                            uart::write_str("    \x1b[0m  DNS Server:    \x1b[1;97m");
                            uart::write_bytes(&ip_buf[..dns_len]);
                            uart::write_line("\x1b[0m                       \x1b[0m");
                            uart::write_line("");
                        }
                    }
                    print_boot_status("Network stack initialized (smoltcp)", true);
                    print_boot_status("VirtIO-Net driver loaded", true);
                }
                Err(_e) => {
                    // Network initialization failed - no IP assigned
                    // Networking is disabled, NET_STATE remains None
                    uart::write_line("    \x1b[0;90m    └─ Network features will be unavailable\x1b[0m");
                }
            }
        }
        None => {
            uart::write_line("    \x1b[1;33m[!]\x1b[0m No VirtIO network device detected");
            uart::write_line("    \x1b[0;90m    └─ Network features will be unavailable\x1b[0m");
        }
    }
}

/// Cancel any running command (called when Ctrl+C is pressed)
fn cancel_running_command() -> bool {
    let running = *COMMAND_RUNNING.lock();
    if !running {
        return false;
    }
    
    // Check if ping is running
    let should_print_stats = {
        let ping_guard = PING_STATE.lock();
        if let Some(ref ping) = *ping_guard {
            ping.continuous
        } else {
            false
        }
    };
    
    if should_print_stats {
        uart::write_line("^C");
        print_ping_statistics();
        *PING_STATE.lock() = None;
        *COMMAND_RUNNING.lock() = false;
        return true;
    }
    
    // Generic command cancellation
    *COMMAND_RUNNING.lock() = false;
    uart::write_line("^C");
    true
}

/// Print ping statistics summary (like Linux ping)
fn print_ping_statistics() {
    let ping_guard = PING_STATE.lock();
    if let Some(ref ping) = *ping_guard {
        let mut ip_buf = [0u8; 16];
        let ip_len = net::format_ipv4(ping.target, &mut ip_buf);
        
        uart::write_line("");
        uart::write_str("--- ");
        uart::write_bytes(&ip_buf[..ip_len]);
        uart::write_line(" ping statistics ---");
        
        uart::write_u64(ping.packets_sent as u64);
        uart::write_str(" packets transmitted, ");
        uart::write_u64(ping.packets_received as u64);
        uart::write_str(" received, ");
        uart::write_u64(ping.packet_loss_percent() as u64);
        uart::write_line("% packet loss");
        
        if ping.packets_received > 0 {
            uart::write_str("rtt min/avg/max = ");
            uart::write_u64(ping.min_rtt as u64);
            uart::write_str("/");
            uart::write_u64(ping.avg_rtt() as u64);
            uart::write_str("/");
            uart::write_u64(ping.max_rtt as u64);
            uart::write_line(" ms");
        }
        uart::write_line("");
    }
}

/// Poll the network stack
fn poll_network() {
    let timestamp = get_time_ms();
    
    // First, poll the network state
    {
        let mut net_guard = NET_STATE.lock();
        if let Some(ref mut state) = *net_guard {
            state.poll(timestamp);
        }
    }
    
    // Then handle ping state separately to avoid holding both locks
    let mut ping_guard = PING_STATE.lock();
    if let Some(ref mut ping) = *ping_guard {
        // Check for ping reply
        if ping.waiting {
            let reply = {
                let mut net_guard = NET_STATE.lock();
                if let Some(ref mut state) = *net_guard {
                    state.check_ping_reply()
                } else {
                    None
                }
            };
            
            if let Some((from, _ident, seq)) = reply {
                if seq == ping.seq {
                    let rtt = timestamp - ping.sent_time;
                    ping.record_reply(rtt);
                    
                    let mut ip_buf = [0u8; 16];
                    let ip_len = net::format_ipv4(from, &mut ip_buf);
                    uart::write_str("64 bytes from ");
                    uart::write_bytes(&ip_buf[..ip_len]);
                    uart::write_str(": icmp_seq=");
                    uart::write_u64(seq as u64);
                    uart::write_str(" time=");
                    uart::write_u64(rtt as u64);
                    uart::write_line(" ms");
                    ping.waiting = false;
                }
            }
            
            // Timeout after 5 seconds for current ping
            if timestamp - ping.sent_time > 5000 {
                uart::write_str("Request timeout for icmp_seq ");
                uart::write_u64(ping.seq as u64);
                uart::write_line("");
                ping.waiting = false;
            }
        }
        
        // In continuous mode, send next ping after 1 second interval
        if ping.continuous && !ping.waiting {
            if timestamp - ping.last_send_time >= 1000 {
                ping.seq = ping.seq.wrapping_add(1);
                ping.sent_time = timestamp;
                ping.last_send_time = timestamp;
                ping.packets_sent += 1;
                
                let send_result = {
                    let mut net_guard = NET_STATE.lock();
                    if let Some(ref mut state) = *net_guard {
                        state.send_ping(ping.target, ping.seq, timestamp)
                    } else {
                        Err("Network not available")
                    }
                };
                
                match send_result {
                    Ok(()) => {
                        ping.waiting = true;
                    }
                    Err(_e) => {
                        // Failed to send, will retry next interval
                    }
                }
            }
        }
    }
}

fn print_prompt() {
    let cwd = cwd_get();
    let prompt_path = if cwd == "/" {
        String::new()
    } else {
        format!(" {}", cwd)
    };
    
    uart::write_str(&format!("\x1b[1;35mBavy\x1b[0m\x1b[1;34m{}\x1b[0m # ", prompt_path));
}

/// Parse a command line for redirection operators
/// Returns: (command_part, redirect_mode, filename)
fn parse_redirection(line: &[u8]) -> (&[u8], RedirectMode, &[u8]) {
    // Look for >> first (must check before >)
    for i in 0..line.len().saturating_sub(1) {
        if line[i] == b'>' && line[i + 1] == b'>' {
            let cmd_part = trim_bytes(&line[..i]);
            let file_part = trim_bytes(&line[i + 2..]);
            return (cmd_part, RedirectMode::Append, file_part);
        }
    }
    
    // Look for single >
    for i in 0..line.len() {
        if line[i] == b'>' {
            let cmd_part = trim_bytes(&line[..i]);
            let file_part = trim_bytes(&line[i + 1..]);
            return (cmd_part, RedirectMode::Overwrite, file_part);
        }
    }
    
    (line, RedirectMode::None, &[])
}

/// Trim whitespace from byte slice
fn trim_bytes(bytes: &[u8]) -> &[u8] {
    let mut start = 0;
    let mut end = bytes.len();
    
    while start < end && (bytes[start] == b' ' || bytes[start] == b'\t') {
        start += 1;
    }
    while end > start && (bytes[end - 1] == b' ' || bytes[end - 1] == b'\t') {
        end -= 1;
    }
    
    &bytes[start..end]
}

fn handle_line(buffer: &[u8], len: usize, _count: &mut usize) {
    // Trim leading/trailing whitespace (spaces and tabs only)
    let mut start = 0;
    let mut end = len;

    while start < end && (buffer[start] == b' ' || buffer[start] == b'\t') {
        start += 1;
    }
    while end > start && (buffer[end - 1] == b' ' || buffer[end - 1] == b'\t') {
        end -= 1;
    }

    if start >= end {
        // Empty line -> do nothing
        return;
    }

    let full_line = &buffer[start..end];
    
    // Parse for redirection
    let (line, redirect_mode, redirect_file) = parse_redirection(full_line);
    
    // Validate redirection target
    if redirect_mode != RedirectMode::None && redirect_file.is_empty() {
        uart::write_line("");
        uart::write_line("\x1b[1;31mError:\x1b[0m Missing filename for redirection");
        return;
    }

    // Split into command and arguments (first whitespace)
    let mut i = 0;
    while i < line.len() && line[i] != b' ' && line[i] != b'\t' {
        i += 1;
    }
    let cmd = &line[..i];

    let mut arg_start = i;
    while arg_start < line.len() && (line[arg_start] == b' ' || line[arg_start] == b'\t') {
        arg_start += 1;
    }
    let args = &line[arg_start..];
    
    // Start capturing if redirecting
    if redirect_mode != RedirectMode::None {
        output_capture_start();
    }

    // Execute the command
    execute_command(cmd, args);
    
    // Handle redirection output
    if redirect_mode != RedirectMode::None {
        let output = output_capture_stop();
        
        if let Ok(filename) = core::str::from_utf8(redirect_file) {
            let filename = filename.trim();
            // Resolve path relative to CWD
            let resolved_path = resolve_path(filename);
            
            let mut fs_guard = FS_STATE.lock();
            let mut blk_guard = BLK_DEV.lock();
            if let (Some(fs), Some(dev)) = (fs_guard.as_mut(), blk_guard.as_mut()) {
                let final_data = if redirect_mode == RedirectMode::Append {
                    // Read existing file content and append
                    let mut combined = match fs.read_file(dev, &resolved_path) {
                        Some(existing) => existing,
                        None => Vec::new(),
                    };
                    combined.extend_from_slice(&output);
                    combined
                } else {
                    // Overwrite mode - just use new output
                    output
                };
                
                match fs.write_file(dev, &resolved_path, &final_data) {
                    Ok(()) => {
                        uart::write_line("");
                        uart::write_str("\x1b[1;32m✓\x1b[0m Output written to ");
                        uart::write_line(&resolved_path);
                    }
                    Err(e) => {
                        uart::write_line("");
                        uart::write_str("\x1b[1;31mError:\x1b[0m Failed to write to file: ");
                        uart::write_line(e);
                    }
                }
            } else {
                uart::write_line("");
                uart::write_line("\x1b[1;31mError:\x1b[0m Filesystem not available");
            }
        } else {
            uart::write_line("");
            uart::write_line("\x1b[1;31mError:\x1b[0m Invalid filename");
        }
    }
}

/// Execute a command (separated for cleaner redirection handling)
/// 
/// Commands are resolved in this order:
/// 1. Essential built-in commands (that require direct kernel access)
/// 2. Scripts: searched in root, then /usr/bin/ directory (PATH-like)
fn execute_command(cmd: &[u8], args: &[u8]) {
    let cmd_str = core::str::from_utf8(cmd).unwrap_or("");
    let args_str = core::str::from_utf8(args).unwrap_or("");
    
    // ═══════════════════════════════════════════════════════════════════════════
    // ESSENTIAL BUILT-IN COMMANDS
    // These require direct kernel access or cannot be implemented in scripts
    // ═══════════════════════════════════════════════════════════════════════════
    
    match cmd_str {
        // System control - requires direct hardware access
        "shutdown" | "poweroff" => { cmd_shutdown(); return; }
        "clear" => { for _ in 0..50 { out_line(""); } return; }
        
        // Directory navigation - requires shell state
        "cd" => { cmd_cd(args_str); return; }
        "pwd" => { out_line(&cwd_get()); return; }
        
        // Scripting engine control
        "node" => { cmd_node(args); return; }
        
        // Async network commands - require event loop integration
        "ping" => { cmd_ping(args); return; }
        "nslookup" => { cmd_nslookup(args); return; }
        
        // Low-level debugging commands
        "readsec" => { cmd_readsec(args); return; }
        "alloc" => { cmd_alloc(args); return; }
        "memtest" => { cmd_memtest(args); return; }
        
        // CPU benchmark
        "cpuTest" | "cputest" => { cmd_cputest(args); return; }
        
        // Help - try script first, fall back to built-in
        "help" => {
            // First try to run help script
            if let Some(script_bytes) = scripting::find_script("help") {
                run_script_bytes(&script_bytes, args_str);
                return;
            }
            // Fallback to built-in help
            cmd_help();
            return;
        }
        
        _ => {}
    }
    
    // ═══════════════════════════════════════════════════════════════════════════
    // SCRIPT RESOLUTION (PATH-like)
    // Search: 1) exact path  2) root directory  3) /usr/bin/ directory
    // ═══════════════════════════════════════════════════════════════════════════
    
    if let Some(script_bytes) = scripting::find_script(cmd_str) {
        run_script_bytes(&script_bytes, args_str);
        return;
    }
    
    // ═══════════════════════════════════════════════════════════════════════════
    // COMMAND NOT FOUND
    // ═══════════════════════════════════════════════════════════════════════════
    
    out_str("\x1b[1;31mCommand not found:\x1b[0m ");
    out_line(cmd_str);
    out_line("\x1b[0;90mTry 'help' for available commands, or check /usr/bin/ for scripts\x1b[0m");
}

/// Run a script from its bytes
fn run_script_bytes(bytes: &[u8], args: &str) {
    let script = unsafe { core::str::from_utf8_unchecked(bytes) };
    match scripting::execute_script(script, args) {
        Ok(output) => {
            if !output.is_empty() {
                out_str(&output);
            }
        }
        Err(e) => {
            out_str("\x1b[1;31mScript error:\x1b[0m ");
            out_line(&e);
        }
    }
}

/// Node scripting engine info and configuration
fn cmd_node(args: &[u8]) {
    let args_str = core::str::from_utf8(args).unwrap_or("").trim();
    
    if args_str.is_empty() || args_str == "info" {
        // Show scripting engine info
        scripting::print_info();
    } else if args_str.starts_with("log ") {
        // Set log level: node log <level>
        let level_str = args_str.strip_prefix("log ").unwrap_or("").trim();
        let level = match level_str {
            "off" | "OFF" => scripting::LogLevel::Off,
            "error" | "ERROR" => scripting::LogLevel::Error,
            "warn" | "WARN" => scripting::LogLevel::Warn,
            "info" | "INFO" => scripting::LogLevel::Info,
            "debug" | "DEBUG" => scripting::LogLevel::Debug,
            "trace" | "TRACE" => scripting::LogLevel::Trace,
            _ => {
                out_line("Usage: node log <level>");
                out_line("Levels: off, error, warn, info, debug, trace");
                return;
            }
        };
        scripting::set_log_level(level);
        out_str("\x1b[1;32m✓\x1b[0m Script log level set to: ");
        out_line(level_str);
    } else if args_str == "eval" || args_str.starts_with("eval ") {
        // Quick eval: node eval <expression>
        let expr = args_str.strip_prefix("eval").unwrap_or("").trim();
        if expr.is_empty() {
            out_line("Usage: node eval <expression>");
            out_line("Example: node eval 2 + 2 * 3");
            return;
        }
        // Use uncached execution for one-off REPL expressions
        match scripting::execute_script_uncached(expr, "") {
            Ok(output) => {
                if !output.is_empty() {
                    out_str(&output);
                }
            }
            Err(e) => {
                out_str("\x1b[1;31mError:\x1b[0m ");
                out_line(&e);
            }
        }
    } else if !args_str.is_empty() {
        // node <script> [args...] - run a script file
        let (script_name, script_args) = match args_str.split_once(' ') {
            Some((name, rest)) => (name, rest),
            None => (args_str, ""),
        };
        
        // Resolve the script path relative to CWD
        let resolved_path = if script_name.starts_with('/') {
            // Absolute path - use as-is
            alloc::string::String::from(script_name)
        } else {
            // Relative path (including ./, ../, or just "bin/cat")
            resolve_path(script_name)
        };
        
        // Read script content with lock held, then execute without lock
        let script_result = {
            let fs_guard = FS_STATE.lock();
            let mut blk_guard = BLK_DEV.lock();
            if let (Some(fs), Some(dev)) = (fs_guard.as_ref(), blk_guard.as_mut()) {
                fs.read_file(dev, &resolved_path)
            } else {
                out_line("\x1b[1;31mError:\x1b[0m Filesystem not available");
                return;
            }
        };
        
        match script_result {
            Some(script_bytes) => {
                if let Ok(script) = core::str::from_utf8(&script_bytes) {
                    match scripting::execute_script(script, script_args) {
                        Ok(output) => {
                            if !output.is_empty() {
                                out_str(&output);
                            }
                        }
                        Err(e) => {
                            out_str("\x1b[1;31mScript error:\x1b[0m ");
                            out_line(&e);
                        }
                    }
                } else {
                    out_line("\x1b[1;31mError:\x1b[0m Invalid UTF-8 in script file");
                }
            }
            None => {
                out_str("\x1b[1;31mError:\x1b[0m Script not found: ");
                out_line(&resolved_path);
            }
        }
    }
}

/// Help command - now a script, but we keep a fallback built-in
fn cmd_help() {
    out_line("\x1b[1;36m┌─────────────────────────────────────────────────────────────┐\x1b[0m");
    out_line("\x1b[1;36m│\x1b[0m                   \x1b[1;97mBAVY OS Commands\x1b[0m                        \x1b[1;36m│\x1b[0m");
    out_line("\x1b[1;36m├─────────────────────────────────────────────────────────────┤\x1b[0m");
    out_line("\x1b[1;36m│\x1b[0m  \x1b[1;33mBuilt-in:\x1b[0m                                                 \x1b[1;36m│\x1b[0m");
    out_line("\x1b[1;36m│\x1b[0m    cd <dir>        Change directory                         \x1b[1;36m│\x1b[0m");
    out_line("\x1b[1;36m│\x1b[0m    pwd             Print working directory                  \x1b[1;36m│\x1b[0m");
    out_line("\x1b[1;36m│\x1b[0m    clear           Clear the screen                         \x1b[1;36m│\x1b[0m");
    out_line("\x1b[1;36m│\x1b[0m    shutdown        Power off the system                     \x1b[1;36m│\x1b[0m");
    out_line("\x1b[1;36m│\x1b[0m    ping <host>     Ping host (Ctrl+C to stop)               \x1b[1;36m│\x1b[0m");
    out_line("\x1b[1;36m│\x1b[0m    nslookup <host> DNS lookup                               \x1b[1;36m│\x1b[0m");
    out_line("\x1b[1;36m│\x1b[0m    node [info]     Scripting engine info/control            \x1b[1;36m│\x1b[0m");
    out_line("\x1b[1;36m│\x1b[0m                                                             \x1b[1;36m│\x1b[0m");
    out_line("\x1b[1;36m│\x1b[0m  \x1b[1;33mUser Scripts:\x1b[0m  \x1b[0;90m(in /usr/bin/ - Rhai language)\x1b[0m            \x1b[1;36m│\x1b[0m");
    out_line("\x1b[1;36m│\x1b[0m    help, ls, cat, echo, cowsay, sysinfo, ip, memstats, ...  \x1b[1;36m│\x1b[0m");
    out_line("\x1b[1;36m│\x1b[0m                                                             \x1b[1;36m│\x1b[0m");
    out_line("\x1b[1;36m│\x1b[0m  \x1b[1;33mKernel API:\x1b[0m  \x1b[0;90m(available in scripts)\x1b[0m                      \x1b[1;36m│\x1b[0m");
    out_line("\x1b[1;36m│\x1b[0m    ls(), read_file(), write_file(), file_exists()           \x1b[1;36m│\x1b[0m");
    out_line("\x1b[1;36m│\x1b[0m    get_ip(), get_mac(), get_gateway(), net_available()      \x1b[1;36m│\x1b[0m");
    out_line("\x1b[1;36m│\x1b[0m    time_ms(), sleep(ms), kernel_version(), arch()           \x1b[1;36m│\x1b[0m");
    out_line("\x1b[1;36m│\x1b[0m    heap_total(), heap_used(), heap_free()                   \x1b[1;36m│\x1b[0m");
    out_line("\x1b[1;36m│\x1b[0m                                                             \x1b[1;36m│\x1b[0m");
    out_line("\x1b[1;36m│\x1b[0m  \x1b[1;33mRedirection:\x1b[0m  cmd > file | cmd >> file                    \x1b[1;36m│\x1b[0m");
    out_line("\x1b[1;36m│\x1b[0m                                                             \x1b[1;36m│\x1b[0m");
    out_line("\x1b[1;36m│\x1b[0m  \x1b[1;32mTip:\x1b[0m  \x1b[1;97mCtrl+C\x1b[0m cancel  |  \x1b[1;97m↑/↓\x1b[0m history  |  \x1b[1;97mnode info\x1b[0m API  \x1b[1;36m│\x1b[0m");
    out_line("\x1b[1;36m└─────────────────────────────────────────────────────────────┘\x1b[0m");
}

// Legacy cmd_ls and cmd_cat removed - now implemented as user-space scripts
// See mkfs/root/usr/bin/ls and mkfs/root/usr/bin/cat


fn cmd_alloc(args: &[u8]) {
    // Parse decimal size from args
    let n = parse_usize(args);
    if n > 0 {
        // Allocate and leak
        let mut v: Vec<u8> = Vec::with_capacity(n);
        v.resize(n, 0);
        core::mem::forget(v);
        uart::write_str("Allocated ");
        uart::write_u64(n as u64);
        uart::write_line(" bytes (leaked).");
    } else {
        uart::write_line("Usage: alloc <bytes>");
    }
}

fn cmd_readsec(args: &[u8]) {
    let sector = parse_usize(args) as u64;
    let mut blk_guard = BLK_DEV.lock();
    if let Some(ref mut blk) = *blk_guard {
        let mut buf = [0u8; 512];
        if blk.read_sector(sector, &mut buf).is_ok() {
            uart::write_line("Sector contents (first 64 bytes):");
            for i in 0..64 {
               uart::write_hex_byte(buf[i]);
               if (i+1) % 16 == 0 { uart::write_line(""); }
               else { uart::write_str(" "); }
            }
        } else {
            uart::write_line("Read failed.");
        }
    } else {
        uart::write_line("No block device.");
    }
}

fn cmd_memtest(args: &[u8]) {
    // Parse iteration count, default to 10
    let iterations = {
        let n = parse_usize(args);
        if n == 0 { 10 } else { n }
    };

    uart::write_str("Running ");
    uart::write_u64(iterations as u64);
    uart::write_line(" memory test iterations...");

    let (used_before, free_before) = allocator::heap_stats();
    uart::write_str("  Before: used=");
    uart::write_u64(used_before as u64);
    uart::write_str(" free=");
    uart::write_u64(free_before as u64);
    uart::write_line("");

    let mut success_count = 0usize;
    let mut fail_count = 0usize;

    for i in 0..iterations {
        // Allocate a Vec, fill it with a pattern, verify, then drop
        let size = 1024; // 1KB per iteration
        let pattern = ((i % 256) as u8).wrapping_add(0x42);

        let mut v: Vec<u8> = Vec::with_capacity(size);
        v.resize(size, pattern);

        // Verify contents
        let mut ok = true;
        for &byte in v.iter() {
            if byte != pattern {
                ok = false;
                break;
            }
        }

        if ok {
            success_count += 1;
        } else {
            fail_count += 1;
        }

        // v is dropped here, memory should be freed
    }

    let (used_after, free_after) = allocator::heap_stats();
    uart::write_str("  After:  used=");
    uart::write_u64(used_after as u64);
    uart::write_str(" free=");
    uart::write_u64(free_after as u64);
    uart::write_line("");

    uart::write_str("Results: ");
    uart::write_u64(success_count as u64);
    uart::write_str(" passed, ");
    uart::write_u64(fail_count as u64);
    uart::write_line(" failed.");

    // Check if memory was properly reclaimed
    if used_after <= used_before + 64 {
        // Allow small overhead for fragmentation
        uart::write_line("Memory deallocation: OK (memory reclaimed)");
    } else {
        uart::write_line("WARNING: Memory may not be properly reclaimed!");
        uart::write_str("  Leaked approximately ");
        uart::write_u64((used_after - used_before) as u64);
        uart::write_line(" bytes");
    }
}

/// CPU benchmark command - compares serial vs parallel prime counting
fn cmd_cputest(args: &[u8]) {
    // Parse the upper limit from args, default to 100000
    let limit = {
        let n = parse_usize(args);
        if n == 0 { 100_000 } else { n }
    };
    
    let num_harts = HARTS_ONLINE.load(Ordering::Relaxed);
    
    uart::write_line("");
    uart::write_line("\x1b[1;36m╔═══════════════════════════════════════════════════════════════════════╗\x1b[0m");
    uart::write_line("\x1b[1;36m║\x1b[0m                      \x1b[1;97mCPU BENCHMARK - Prime Counting\x1b[0m                  \x1b[1;36m║\x1b[0m");
    uart::write_line("\x1b[1;36m╚═══════════════════════════════════════════════════════════════════════╝\x1b[0m");
    uart::write_line("");
    
    uart::write_str("  \x1b[1;33mConfiguration:\x1b[0m");
    uart::write_line("");
    uart::write_str("    Range: 2 to ");
    uart::write_u64(limit as u64);
    uart::write_line("");
    uart::write_str("    Harts online: ");
    uart::write_u64(num_harts as u64);
    uart::write_line("");
    uart::write_line("");
    
    // ═══════════════════════════════════════════════════════════════════
    // SERIAL BENCHMARK (single hart)
    // ═══════════════════════════════════════════════════════════════════
    
    uart::write_line("  \x1b[1;33m[1/2] Serial Execution\x1b[0m (single hart)");
    uart::write_str("        Computing primes...");
    
    let serial_start = get_time_ms();
    let serial_count = count_primes_in_range(2, limit as u64);
    let serial_end = get_time_ms();
    let serial_time = serial_end - serial_start;
    
    uart::write_line(" done!");
    uart::write_str("        Result: \x1b[1;97m");
    uart::write_u64(serial_count);
    uart::write_str("\x1b[0m primes found in \x1b[1;97m");
    uart::write_u64(serial_time as u64);
    uart::write_line("\x1b[0m ms");
    uart::write_line("");
    
    // ═══════════════════════════════════════════════════════════════════
    // PARALLEL BENCHMARK (multiple harts)
    // ═══════════════════════════════════════════════════════════════════
    
    if num_harts > 1 {
        uart::write_str("  \x1b[1;33m[2/2] Parallel Execution\x1b[0m (");
        uart::write_u64(num_harts as u64);
        uart::write_line(" harts)");
        uart::write_str("        Computing primes...");
        
        let parallel_start = get_time_ms();
        
        // Start benchmark on secondary harts
        BENCHMARK.start(BenchmarkMode::PrimeCount, 2, limit as u64, num_harts);
        
        // Wake up secondary harts via IPI
        for hart in 1..num_harts {
            send_ipi(hart);
        }
        
        // Primary hart (0) does its share of work
        let (my_start, my_end) = BENCHMARK.get_work_range(0);
        let my_count = count_primes_in_range(my_start, my_end);
        BENCHMARK.report_result(0, my_count);
        
        // Wait for all harts to complete (with timeout)
        let timeout = get_time_ms() + 60000; // 60 second timeout
        while !BENCHMARK.all_completed() {
            if get_time_ms() > timeout {
                uart::write_line(" TIMEOUT!");
                uart::write_line("        \x1b[1;31mError:\x1b[0m Some harts did not complete in time");
                BENCHMARK.clear();
                return;
            }
            core::hint::spin_loop();
        }
        
        let parallel_end = get_time_ms();
        let parallel_time = parallel_end - parallel_start;
        let parallel_count = BENCHMARK.total_result();
        
        // Clear benchmark state
        BENCHMARK.clear();
        
        uart::write_line(" done!");
        uart::write_str("        Result: \x1b[1;97m");
        uart::write_u64(parallel_count);
        uart::write_str("\x1b[0m primes found in \x1b[1;97m");
        uart::write_u64(parallel_time as u64);
        uart::write_line("\x1b[0m ms");
        
        // Show work distribution
        uart::write_line("");
        uart::write_line("        \x1b[0;90mWork distribution:\x1b[0m");
        let chunk = (limit as u64 - 2) / num_harts as u64;
        for hart in 0..num_harts {
            let h_start = 2 + hart as u64 * chunk;
            let h_end = if hart == num_harts - 1 { limit as u64 } else { h_start + chunk };
            uart::write_str("          Hart ");
            uart::write_u64(hart as u64);
            uart::write_str(": [");
            uart::write_u64(h_start);
            uart::write_str(", ");
            uart::write_u64(h_end);
            uart::write_line(")");
        }
        uart::write_line("");
        
        // ═══════════════════════════════════════════════════════════════
        // RESULTS COMPARISON
        // ═══════════════════════════════════════════════════════════════
        
        uart::write_line("\x1b[1;36m────────────────────────────────────────────────────────────────────────\x1b[0m");
        uart::write_line("  \x1b[1;33mResults Summary:\x1b[0m");
        uart::write_line("");
        
        // Verify results match
        if serial_count == parallel_count {
            uart::write_line("    \x1b[1;32m✓\x1b[0m Results match (verified correctness)");
        } else {
            uart::write_line("    \x1b[1;31m✗\x1b[0m Results MISMATCH (bug detected!)");
            uart::write_str("      Serial: ");
            uart::write_u64(serial_count);
            uart::write_str(", Parallel: ");
            uart::write_u64(parallel_count);
            uart::write_line("");
        }
        uart::write_line("");
        
        // Calculate speedup
        if parallel_time > 0 {
            let speedup_x10 = (serial_time * 10) / parallel_time;
            let speedup_whole = speedup_x10 / 10;
            let speedup_frac = speedup_x10 % 10;
            
            uart::write_str("    Serial time:   \x1b[1;97m");
            uart::write_u64(serial_time as u64);
            uart::write_line(" ms\x1b[0m");
            uart::write_str("    Parallel time: \x1b[1;97m");
            uart::write_u64(parallel_time as u64);
            uart::write_line(" ms\x1b[0m");
            uart::write_str("    Speedup:       \x1b[1;32m");
            uart::write_u64(speedup_whole as u64);
            uart::write_str(".");
            uart::write_u64(speedup_frac as u64);
            uart::write_str("x\x1b[0m (with ");
            uart::write_u64(num_harts as u64);
            uart::write_line(" harts)");
            
            // Efficiency
            let efficiency = (speedup_x10 * 100) / (num_harts as i64 * 10);
            uart::write_str("    Efficiency:    \x1b[1;97m");
            uart::write_u64(efficiency as u64);
            uart::write_line("%\x1b[0m (speedup / num_harts × 100)");
        }
        uart::write_line("");
        
    } else {
        uart::write_line("  \x1b[1;33m[2/2] Parallel Execution\x1b[0m");
        uart::write_line("        \x1b[0;90mSkipped - only 1 hart online\x1b[0m");
        uart::write_line("");
        uart::write_line("\x1b[1;36m────────────────────────────────────────────────────────────────────────\x1b[0m");
        uart::write_line("  \x1b[1;33mResults Summary:\x1b[0m");
        uart::write_line("");
        uart::write_str("    Serial time: \x1b[1;97m");
        uart::write_u64(serial_time as u64);
        uart::write_line(" ms\x1b[0m");
        uart::write_str("    Primes found: \x1b[1;97m");
        uart::write_u64(serial_count);
        uart::write_line("\x1b[0m");
        uart::write_line("");
        uart::write_line("    \x1b[0;90mNote: Enable more harts to see parallel comparison\x1b[0m");
        uart::write_line("");
    }
    
    uart::write_line("\x1b[1;36m════════════════════════════════════════════════════════════════════════\x1b[0m");
    uart::write_line("");
}

// Legacy cmd_memstats and cmd_ip removed - now implemented as user-space scripts
// See mkfs/root/usr/bin/memstats and mkfs/root/usr/bin/ip

fn cmd_ping(args: &[u8]) {
    if args.is_empty() {
        uart::write_line("Usage: ping <ip|hostname>");
        uart::write_line("\x1b[0;90mExamples:\x1b[0m");
        uart::write_line("  ping 10.0.2.2");
        uart::write_line("  ping google.com");
        uart::write_line("\x1b[0;90mPress Ctrl+C to stop\x1b[0m");
        return;
    }
    
    // Trim any trailing whitespace
    let mut arg_len = args.len();
    while arg_len > 0 && (args[arg_len - 1] == b' ' || args[arg_len - 1] == b'\t') {
        arg_len -= 1;
    }
    let trimmed_args = &args[..arg_len];
    
    // Try to parse as IP address first
    let target = match net::parse_ipv4(trimmed_args) {
        Some(ip) => ip,
        None => {
            // Not an IP address - try to resolve as hostname
            uart::write_str("\x1b[0;90m[DNS]\x1b[0m Resolving ");
            uart::write_bytes(trimmed_args);
            uart::write_line("...");
            
            let resolve_result = {
                let mut net_guard = NET_STATE.lock();
                if let Some(ref mut state) = *net_guard {
                    dns::resolve(state, trimmed_args, net::DNS_SERVER, 5000, get_time_ms)
                } else {
                    uart::write_line("\x1b[1;31m✗\x1b[0m Network not initialized");
                    return;
                }
            };
            
            match resolve_result {
                Some(resolved_ip) => {
                    let mut ip_buf = [0u8; 16];
                    let ip_len = net::format_ipv4(resolved_ip, &mut ip_buf);
                    uart::write_str("\x1b[1;32m[DNS]\x1b[0m Resolved to \x1b[1;97m");
                    uart::write_bytes(&ip_buf[..ip_len]);
                    uart::write_line("\x1b[0m");
                    resolved_ip
                }
                None => {
                    uart::write_str("\x1b[1;31m[DNS]\x1b[0m Failed to resolve: ");
                    uart::write_bytes(trimmed_args);
                    uart::write_line("");
                    return;
                }
            }
        }
    };
    
    let timestamp = get_time_ms();
    
    let mut ip_buf = [0u8; 16];
    let ip_len = net::format_ipv4(target, &mut ip_buf);
    uart::write_str("PING ");
    uart::write_bytes(&ip_buf[..ip_len]);
    uart::write_line(" 56(84) bytes of data.");
    
    // Set up continuous ping state
    let mut ping_state = PingState::new(target, timestamp);
    ping_state.seq = 1;
    ping_state.sent_time = timestamp;
    ping_state.last_send_time = timestamp;
    ping_state.packets_sent = 1;
    ping_state.waiting = true;
    
    // Send the first ICMP echo request immediately
    let send_result = {
        let mut net_guard = NET_STATE.lock();
        if let Some(ref mut state) = *net_guard {
            state.send_ping(target, ping_state.seq, timestamp)
        } else {
            uart::write_line("\x1b[1;31m✗\x1b[0m Network not initialized");
            return;
        }
    };
    
    match send_result {
        Ok(()) => {
            *PING_STATE.lock() = Some(ping_state);
            *COMMAND_RUNNING.lock() = true;
        }
        Err(e) => {
            uart::write_str("ping: ");
            uart::write_line(e);
        }
    }
}

fn cmd_nslookup(args: &[u8]) {
    if args.is_empty() {
        uart::write_line("Usage: nslookup <hostname>");
        uart::write_line("\x1b[0;90mExample: nslookup google.com\x1b[0m");
        return;
    }
    
    // Trim any trailing whitespace from hostname
    let mut hostname_len = args.len();
    while hostname_len > 0 && (args[hostname_len - 1] == b' ' || args[hostname_len - 1] == b'\t') {
        hostname_len -= 1;
    }
    let hostname = &args[..hostname_len];
    
    uart::write_line("");
    uart::write_str("\x1b[1;33mServer:\x1b[0m  ");
    let mut ip_buf = [0u8; 16];
    let dns_len = net::format_ipv4(net::DNS_SERVER, &mut ip_buf);
    uart::write_bytes(&ip_buf[..dns_len]);
    uart::write_line("");
    uart::write_line("\x1b[1;33mPort:\x1b[0m    53");
    uart::write_line("");
    
    uart::write_str("\x1b[0;90mQuerying ");
    uart::write_bytes(hostname);
    uart::write_line("...\x1b[0m");
    
    // Perform DNS lookup with 5 second timeout
    let resolve_result = {
        let mut net_guard = NET_STATE.lock();
        if let Some(ref mut state) = *net_guard {
            dns::resolve(state, hostname, net::DNS_SERVER, 5000, get_time_ms)
        } else {
            uart::write_line("\x1b[1;31m✗\x1b[0m Network not initialized");
            return;
        }
    };
    
    match resolve_result {
        Some(addr) => {
            uart::write_line("");
            uart::write_str("\x1b[1;32mName:\x1b[0m    ");
            uart::write_bytes(hostname);
            uart::write_line("");
            let addr_len = net::format_ipv4(addr, &mut ip_buf);
            uart::write_str("\x1b[1;32mAddress:\x1b[0m \x1b[1;97m");
            uart::write_bytes(&ip_buf[..addr_len]);
            uart::write_line("\x1b[0m");
            uart::write_line("");
        }
        None => {
            uart::write_line("");
            uart::write_str("\x1b[1;31m*** Can't find ");
            uart::write_bytes(hostname);
            uart::write_line(": No response from server\x1b[0m");
            uart::write_line("");
        }
    }
}

// Legacy cmd_netstat removed - now implemented as user-space script
// See mkfs/root/usr/bin/netstat

/// Change directory command
fn cmd_cd(args: &str) {
    let path = args.trim();
    
    // Handle special cases
    if path.is_empty() || path == "~" {
        // Go to home directory (or root for now)
        cwd_set("/");
        return;
    }
    
    if path == "-" {
        // TODO: Previous directory (would need to track)
        out_line("cd: OLDPWD not set");
        return;
    }
    
    // Resolve the path
    let new_path = resolve_path(path);
    
    // Verify the path exists (has files under it)
    if path_exists(&new_path) {
        cwd_set(&new_path);
    } else {
        out_str("\x1b[1;31mcd:\x1b[0m ");
        out_str(path);
        out_line(": No such directory");
    }
}

/// Resolve a path relative to CWD
pub fn resolve_path(path: &str) -> alloc::string::String {
    use alloc::string::String;
    use alloc::vec::Vec;
    
    let mut result = String::new();
    
    // Start from root or CWD
    let cwd = cwd_get();
    let base: &str = if path.starts_with('/') {
        "/"
    } else {
        &cwd
    };
    
    // Combine base and path, then normalize
    let full = if path.starts_with('/') {
        String::from(path)
    } else if base == "/" {
        let mut s = String::from("/");
        s.push_str(path);
        s
    } else {
        let mut s = String::from(base);
        s.push('/');
        s.push_str(path);
        s
    };
    
    // Split and normalize (handle . and ..)
    let mut parts: Vec<&str> = Vec::new();
    for part in full.split('/') {
        match part {
            "" | "." => continue,
            ".." => { parts.pop(); }
            p => parts.push(p),
        }
    }
    
    // Rebuild path
    result.push('/');
    for (i, part) in parts.iter().enumerate() {
        if i > 0 { result.push('/'); }
        result.push_str(part);
    }
    
    if result.is_empty() {
        result.push('/');
    }
    
    result
}

/// Check if a path exists (has files under it or is a file)
fn path_exists(path: &str) -> bool {
    let fs_guard = FS_STATE.lock();
    let mut blk_guard = BLK_DEV.lock();
    if let (Some(fs), Some(dev)) = (fs_guard.as_ref(), blk_guard.as_mut()) {
        // Root always exists
        if path == "/" {
            return true;
        }
        
        let files = fs.list_dir(dev, "/");
        let path_with_slash = if path.ends_with('/') {
            alloc::string::String::from(path)
        } else {
            let mut s = alloc::string::String::from(path);
            s.push('/');
            s
        };
        
        for file in files {
            // Check if any file starts with this path (it's a directory)
            if file.name.starts_with(&path_with_slash) {
                return true;
            }
            // Or if it exactly matches (it's a file)
            if file.name == path {
                return true;
            }
        }
    }
    false
}

fn cmd_shutdown() {
    uart::write_line("");
    uart::write_line("\x1b[1;31m╔═══════════════════════════════════════════════════════════════════╗\x1b[0m");
    uart::write_line("\x1b[1;31m║\x1b[0m                                                                   \x1b[1;31m║\x1b[0m");
    uart::write_line("\x1b[1;31m║\x1b[0m                    \x1b[1;97mSystem Shutdown Initiated\x1b[0m                       \x1b[1;31m║\x1b[0m");
    uart::write_line("\x1b[1;31m║\x1b[0m                                                                   \x1b[1;31m║\x1b[0m");
    uart::write_line("\x1b[1;31m╚═══════════════════════════════════════════════════════════════════╝\x1b[0m");
    uart::write_line("");
    uart::write_line("    \x1b[0;90m[1/3]\x1b[0m Syncing filesystems...");
    uart::write_line("    \x1b[0;90m[2/3]\x1b[0m Stopping network services...");
    uart::write_line("    \x1b[0;90m[3/3]\x1b[0m Powering off CPU...");
    uart::write_line("");
    uart::write_line("    \x1b[1;32m✓ Goodbye!\x1b[0m");
    uart::write_line("");
    
    // Write to the test finisher address to signal the VM to stop
    // Value 0x5555 indicates successful exit (PASS)
    unsafe {
        core::ptr::write_volatile(TEST_FINISHER as *mut u32, 0x5555);
    }
    // Should not reach here, but loop just in case
    loop {}
}

fn parse_usize(args: &[u8]) -> usize {
    let mut n: usize = 0;
    let mut ok = false;
    for &b in args {
        if b >= b'0' && b <= b'9' {
            ok = true;
            let d = (b - b'0') as usize;
            n = n.saturating_mul(10).saturating_add(d);
        } else if b == b' ' || b == b'\t' {
            if ok {
                break;
            }
        } else {
            break;
        }
    }
    if ok { n } else { 0 }
}

fn eq_cmd(a: &[u8], b: &[u8]) -> bool {
    if a.len() != b.len() {
        return false;
    }
    let mut i = 0;
    while i < a.len() {
        if a[i] != b[i] {
            return false;
        }
        i += 1;
    }
    true
}
</file>

<file path="kernel/CHANGELOG.md">
## 0.1.7 (2025-12-02)

This was a version bump only for kernel to align it with other projects, there were no code changes.

## 0.1.6 (2025-12-02)

### 🩹 Fixes

- major refactor for wasm multi threading Signed-off-by: Javier Ribó <elribonazo@gmail.com> ([46a6c21](https://github.com/elribonazo/riscv-vm/commit/46a6c21))

### ❤️ Thank You

- Javier Ribó

## 0.1.5 (2025-12-02)

### 🩹 Fixes

- vm upgrade Signed-off-by: Javier Ribó <elribonazo@gmail.com> ([5415e15](https://github.com/elribonazo/riscv-vm/commit/5415e15))

### ❤️ Thank You

- Javier Ribó

## 0.1.4 (2025-12-01)

### 🩹 Fixes

- kernel Signed-off-by: Javier Ribó <elribonazo@gmail.com> ([7b6e854](https://github.com/elribonazo/riscv-vm/commit/7b6e854))

### ❤️ Thank You

- Javier Ribó

## 0.1.3 (2025-12-01)

### 🩹 Fixes

- harts beta WIP Signed-off-by: Javier Ribó <elribonazo@gmail.com> ([b64152c](https://github.com/elribonazo/riscv-vm/commit/b64152c))

### ❤️ Thank You

- Javier Ribó

## 0.1.2 (2025-11-30)

### 🩹 Fixes

- kernel update Signed-off-by: Javier Ribó <elribonazo@gmail.com> ([2554164](https://github.com/elribonazo/riscv-vm/commit/2554164))

### ❤️ Thank You

- Javier Ribó

## 0.1.1 (2025-11-30)

### 🩹 Fixes

- logging and printing to uart Signed-off-by: Javier Ribó <elribonazo@gmail.com> ([550fdcd](https://github.com/elribonazo/riscv-vm/commit/550fdcd))

### ❤️ Thank You

- Javier Ribó

## 0.1.0 (2025-11-29)

### 🚀 Features

- implement http with tls 1.2 and 1.3 over webTransport Signed-off-by: Javier Ribó <elribonazo@gmail.com> ([ae5ff04](https://github.com/elribonazo/riscv-vm/commit/ae5ff04))

### ❤️ Thank You

- Javier Ribó

## 0.0.17 (2025-11-29)

### 🩹 Fixes

- update kernel script Signed-off-by: Javier Ribó <elribonazo@gmail.com> ([094973f](https://github.com/elribonazo/riscv-vm/commit/094973f))

### ❤️ Thank You

- Javier Ribó

## 0.0.16 (2025-11-29)

### 🩹 Fixes

- improve VM scripting utf-8 Signed-off-by: Javier Ribó <elribonazo@gmail.com> ([99a872a](https://github.com/elribonazo/riscv-vm/commit/99a872a))

### ❤️ Thank You

- Javier Ribó

## 0.0.15 (2025-11-29)

### 🩹 Fixes

- improve kernel vm Signed-off-by: Javier Ribó <elribonazo@gmail.com> ([9c018e2](https://github.com/elribonazo/riscv-vm/commit/9c018e2))

### ❤️ Thank You

- Javier Ribó

## 0.0.14 (2025-11-29)

### 🩹 Fixes

- improve kernel Signed-off-by: Javier Ribó <elribonazo@gmail.com> ([bc1f903](https://github.com/elribonazo/riscv-vm/commit/bc1f903))

### ❤️ Thank You

- Javier Ribó

## 0.0.13 (2025-11-29)

### 🩹 Fixes

- completion Signed-off-by: Javier Ribó <elribonazo@gmail.com> ([aac807a](https://github.com/elribonazo/riscv-vm/commit/aac807a))

### ❤️ Thank You

- Javier Ribó

## 0.0.12 (2025-11-29)

### 🩹 Fixes

- generate scripts Signed-off-by: Javier Ribó <elribonazo@gmail.com> ([77d21a6](https://github.com/elribonazo/riscv-vm/commit/77d21a6))

### ❤️ Thank You

- Javier Ribó

## 0.0.11 (2025-11-29)

### 🩹 Fixes

- improve kernel and operating system Signed-off-by: Javier Ribó <elribonazo@gmail.com> ([fe4ec30](https://github.com/elribonazo/riscv-vm/commit/fe4ec30))

### ❤️ Thank You

- Javier Ribó

## 0.0.10 (2025-11-29)

### 🩹 Fixes

- kernel command improvements Signed-off-by: Javier Ribó <elribonazo@gmail.com> ([ef9ffee](https://github.com/elribonazo/riscv-vm/commit/ef9ffee))

### ❤️ Thank You

- Javier Ribó

## 0.0.9 (2025-11-29)

### 🩹 Fixes

- improve kernel Signed-off-by: Javier Ribó <elribonazo@gmail.com> ([373973a](https://github.com/elribonazo/riscv-vm/commit/373973a))

### ❤️ Thank You

- Javier Ribó

## 0.0.8 (2025-11-29)

### 🩹 Fixes

- update kernel Signed-off-by: Javier Ribó <elribonazo@gmail.com> ([9fc7f12](https://github.com/elribonazo/riscv-vm/commit/9fc7f12))
- kernel improvement for dhcp async wait times Signed-off-by: Javier Ribó <elribonazo@gmail.com> ([20dcac2](https://github.com/elribonazo/riscv-vm/commit/20dcac2))

### ❤️ Thank You

- Javier Ribó

## 0.0.7 (2025-11-29)

### 🩹 Fixes

- implement basic dhcp and interconnect nodes in p2p network Signed-off-by: Javier Ribó <elribonazo@gmail.com> ([7e9991c](https://github.com/elribonazo/riscv-vm/commit/7e9991c))

### ❤️ Thank You

- Javier Ribó

## 0.0.6 (2025-11-29)

This was a version bump only for kernel to align it with other projects, there were no code changes.

## 0.0.5 (2025-11-29)

This was a version bump only for kernel to align it with other projects, there were no code changes.

## 0.0.4 (2025-11-29)

### 🩹 Fixes

- kernel Signed-off-by: Javier Ribó <elribonazo@gmail.com> ([2b7e53a](https://github.com/elribonazo/riscv-vm/commit/2b7e53a))

### ❤️ Thank You

- Javier Ribó

## 0.0.3 (2025-11-29)

### 🩹 Fixes

- minimal filesystem Signed-off-by: Javier Ribó <elribonazo@gmail.com> ([8df2d70](https://github.com/elribonazo/riscv-vm/commit/8df2d70))

### ❤️ Thank You

- Javier Ribó

## 0.0.2 (2025-11-28)

### 🩹 Fixes

- pipelines Signed-off-by: Javier Ribó <elribonazo@gmail.com> ([34664a9](https://github.com/elribonazo/riscv-vm/commit/34664a9))
- versions Signed-off-by: Javier Ribó <elribonazo@gmail.com> ([a49158f](https://github.com/elribonazo/riscv-vm/commit/a49158f))
- improve kernel Signed-off-by: Javier Ribó <elribonazo@gmail.com> ([39a361a](https://github.com/elribonazo/riscv-vm/commit/39a361a))
- versions Signed-off-by: Javier Ribó <elribonazo@gmail.com> ([2b2a498](https://github.com/elribonazo/riscv-vm/commit/2b2a498))
- test ci Signed-off-by: Javier Ribó <elribonazo@gmail.com> ([7d15c50](https://github.com/elribonazo/riscv-vm/commit/7d15c50))
- refactor images and context Signed-off-by: Javier Ribó <elribonazo@gmail.com> ([7ec91b6](https://github.com/elribonazo/riscv-vm/commit/7ec91b6))
- networking improvement Signed-off-by: Javier Ribó <elribonazo@gmail.com> ([2929223](https://github.com/elribonazo/riscv-vm/commit/2929223))
- implement networking Signed-off-by: Javier Ribó <elribonazo@gmail.com> ([217fcdb](https://github.com/elribonazo/riscv-vm/commit/217fcdb))
- UI computer + github pages Signed-off-by: Javier Ribó <elribonazo@gmail.com> ([d8b1258](https://github.com/elribonazo/riscv-vm/commit/d8b1258))
- adding basic xv6 compatibility for the VM Signed-off-by: Javier Ribó <elribonazo@gmail.com> ([f8d49cc](https://github.com/elribonazo/riscv-vm/commit/f8d49cc))
- all Signed-off-by: Javier Ribó <elribonazo@gmail.com> ([a4a12d8](https://github.com/elribonazo/riscv-vm/commit/a4a12d8))

### ❤️ Thank You

- Javier Ribó
</file>

<file path="kernel/Cargo.toml">
[package]
name = "kernel"
version = "0.1.7"
edition = "2021"

[dependencies]
riscv = "0.10.1"
riscv-rt = "0.11.0"
panic-halt = "0.2.0"
linked_list_allocator = "0.10"

# Scripting engine for user-space commands
# Using full engine with StandardPackage for JavaScript-like scripting
[dependencies.rhai]
version = "1.21"
default-features = false
features = [
    "no_std",           # Required for bare-metal kernel
    "no_time",          # No system time available
    "f32_float",        # Use f32 instead of f64 for smaller binary (optional, can remove for f64)
]

[dependencies.smoltcp]
version = "0.11"
default-features = false
features = [
    "medium-ethernet",
    "proto-ipv4",
    "socket-icmp",
    "socket-tcp",
    "socket-udp",
]

# TLS support for HTTPS
[dependencies.embedded-tls]
version = "0.17"
default-features = false
features = ["alloc"]

[dependencies.embedded-io]
version = "0.6"

[dependencies.embedded-io-async]
version = "0.6"

[dependencies.rand_core]
version = "0.6"
default-features = false

# Crypto primitives for TLS (RustCrypto stack)
[dependencies.sha2]
version = "0.10"
default-features = false

[dependencies.hmac]
version = "0.12"
default-features = false

[dependencies.aes-gcm]
version = "0.10"
default-features = false
features = ["alloc", "aes"]

[dependencies.p256]
version = "0.13"
default-features = false
features = ["ecdh", "arithmetic"]

[dependencies.x25519-dalek]
version = "2"
default-features = false
features = ["static_secrets", "alloc"]

# Note: Release profile is defined at workspace root (Cargo.toml)
</file>

<file path="riscv-vm/CHANGELOG.md">
## 0.0.37 (2025-12-02)

### 🩹 Fixes

- improve hart performance on browsers and nodejs Signed-off-by: Javier Ribó <elribonazo@gmail.com> ([7111c0b](https://github.com/elribonazo/riscv-vm/commit/7111c0b))

### ❤️ Thank You

- Javier Ribó

## 0.0.36 (2025-12-02)

### 🩹 Fixes

- reset npm ignore files to include .node binaries Signed-off-by: Javier Ribó <elribonazo@gmail.com> ([d8df737](https://github.com/elribonazo/riscv-vm/commit/d8df737))

### ❤️ Thank You

- Javier Ribó

## 0.0.35 (2025-12-02)

### 🩹 Fixes

- remove unused dependency Signed-off-by: Javier Ribó <elribonazo@gmail.com> ([ce3f059](https://github.com/elribonazo/riscv-vm/commit/ce3f059))

### ❤️ Thank You

- Javier Ribó

## 0.0.34 (2025-12-02)

### 🩹 Fixes

- improve release Signed-off-by: Javier Ribó <elribonazo@gmail.com> ([a6b38a7](https://github.com/elribonazo/riscv-vm/commit/a6b38a7))

### ❤️ Thank You

- Javier Ribó

## 0.0.33 (2025-12-02)

### 🩹 Fixes

- workflow Signed-off-by: Javier Ribó <elribonazo@gmail.com> ([c2a3be8](https://github.com/elribonazo/riscv-vm/commit/c2a3be8))

### ❤️ Thank You

- Javier Ribó

## 0.0.32 (2025-12-02)

### 🩹 Fixes

- major refactor for wasm multi threading Signed-off-by: Javier Ribó <elribonazo@gmail.com> ([46a6c21](https://github.com/elribonazo/riscv-vm/commit/46a6c21))

### ❤️ Thank You

- Javier Ribó

## 0.0.31 (2025-12-02)

### 🩹 Fixes

- vm upgrade Signed-off-by: Javier Ribó <elribonazo@gmail.com> ([5415e15](https://github.com/elribonazo/riscv-vm/commit/5415e15))

### ❤️ Thank You

- Javier Ribó

## 0.0.30 (2025-12-01)

### 🩹 Fixes

- vm upgrade performance Signed-off-by: Javier Ribó <elribonazo@gmail.com> ([5ae83c9](https://github.com/elribonazo/riscv-vm/commit/5ae83c9))

### ❤️ Thank You

- Javier Ribó

## 0.0.29 (2025-12-01)

### 🩹 Fixes

- harts beta WIP Signed-off-by: Javier Ribó <elribonazo@gmail.com> ([b64152c](https://github.com/elribonazo/riscv-vm/commit/b64152c))

### ❤️ Thank You

- Javier Ribó

## 0.0.28 (2025-11-30)

### 🩹 Fixes

- logging and printing to uart Signed-off-by: Javier Ribó <elribonazo@gmail.com> ([550fdcd](https://github.com/elribonazo/riscv-vm/commit/550fdcd))

### ❤️ Thank You

- Javier Ribó

## 0.0.27 (2025-11-29)

### 🩹 Fixes

- vm Signed-off-by: Javier Ribó <elribonazo@gmail.com> ([a3e0238](https://github.com/elribonazo/riscv-vm/commit/a3e0238))

### ❤️ Thank You

- Javier Ribó

## 0.0.26 (2025-11-29)

### 🩹 Fixes

- upgrade VM performance Signed-off-by: Javier Ribó <elribonazo@gmail.com> ([c2027cd](https://github.com/elribonazo/riscv-vm/commit/c2027cd))

### ❤️ Thank You

- Javier Ribó

## 0.0.25 (2025-11-29)

### 🩹 Fixes

- vm output logs Signed-off-by: Javier Ribó <elribonazo@gmail.com> ([42303e5](https://github.com/elribonazo/riscv-vm/commit/42303e5))

### ❤️ Thank You

- Javier Ribó

## 0.0.24 (2025-11-29)

### 🩹 Fixes

- riscvm uart output Signed-off-by: Javier Ribó <elribonazo@gmail.com> ([d763284](https://github.com/elribonazo/riscv-vm/commit/d763284))

### ❤️ Thank You

- Javier Ribó

## 0.0.23 (2025-11-29)

### 🩹 Fixes

- improve VM scripting utf-8 Signed-off-by: Javier Ribó <elribonazo@gmail.com> ([99a872a](https://github.com/elribonazo/riscv-vm/commit/99a872a))

### ❤️ Thank You

- Javier Ribó

## 0.0.22 (2025-11-29)

### 🩹 Fixes

- code improvement Signed-off-by: Javier Ribó <elribonazo@gmail.com> ([17f09a1](https://github.com/elribonazo/riscv-vm/commit/17f09a1))

### ❤️ Thank You

- Javier Ribó

## 0.0.21 (2025-11-29)

### 🩹 Fixes

- improve kernel vm Signed-off-by: Javier Ribó <elribonazo@gmail.com> ([9c018e2](https://github.com/elribonazo/riscv-vm/commit/9c018e2))

### ❤️ Thank You

- Javier Ribó

## 0.0.20 (2025-11-29)

### 🩹 Fixes

- virtual machine halting and halt_code Signed-off-by: Javier Ribó <elribonazo@gmail.com> ([777304b](https://github.com/elribonazo/riscv-vm/commit/777304b))

### ❤️ Thank You

- Javier Ribó

## 0.0.19 (2025-11-29)

### 🩹 Fixes

- improve reconnection logic Signed-off-by: Javier Ribó <elribonazo@gmail.com> ([de67af8](https://github.com/elribonazo/riscv-vm/commit/de67af8))

### ❤️ Thank You

- Javier Ribó

## 0.0.18 (2025-11-29)

### 🩹 Fixes

- vm Signed-off-by: Javier Ribó <elribonazo@gmail.com> ([8656e59](https://github.com/elribonazo/riscv-vm/commit/8656e59))

### ❤️ Thank You

- Javier Ribó

## 0.0.17 (2025-11-29)

### 🩹 Fixes

- relay improvement + vm reconnect Signed-off-by: Javier Ribó <elribonazo@gmail.com> ([91300e7](https://github.com/elribonazo/riscv-vm/commit/91300e7))

### ❤️ Thank You

- Javier Ribó

## 0.0.16 (2025-11-29)

### 🩹 Fixes

- virtual network over webTransport relay server Signed-off-by: Javier Ribó <elribonazo@gmail.com> ([a9acb09](https://github.com/elribonazo/riscv-vm/commit/a9acb09))

### ❤️ Thank You

- Javier Ribó

## 0.0.15 (2025-11-29)

### 🩹 Fixes

- implement basic dhcp and interconnect nodes in p2p network Signed-off-by: Javier Ribó <elribonazo@gmail.com> ([7e9991c](https://github.com/elribonazo/riscv-vm/commit/7e9991c))

### ❤️ Thank You

- Javier Ribó

## 0.0.14 (2025-11-29)

### 🩹 Fixes

- fs Signed-off-by: Javier Ribó <elribonazo@gmail.com> ([3b3a6d4](https://github.com/elribonazo/riscv-vm/commit/3b3a6d4))

### ❤️ Thank You

- Javier Ribó

## 0.0.13 (2025-11-29)

This was a version bump only for riscv-vm to align it with other projects, there were no code changes.

## 0.0.12 (2025-11-29)

This was a version bump only for riscv-vm to align it with other projects, there were no code changes.

## 0.0.11 (2025-11-29)

### 🩹 Fixes

- minimal filesystem Signed-off-by: Javier Ribó <elribonazo@gmail.com> ([8df2d70](https://github.com/elribonazo/riscv-vm/commit/8df2d70))

### ❤️ Thank You

- Javier Ribó

## 0.0.10 (2025-11-28)

### 🩹 Fixes

- repository url Signed-off-by: Javier Ribó <elribonazo@gmail.com> ([06c681f](https://github.com/elribonazo/riscv-vm/commit/06c681f))

### ❤️ Thank You

- Javier Ribó

## 0.0.9 (2025-11-28)

### 🩹 Fixes

- vm texts Signed-off-by: Javier Ribó <elribonazo@gmail.com> ([6accc3e](https://github.com/elribonazo/riscv-vm/commit/6accc3e))

### ❤️ Thank You

- Javier Ribó

## 0.0.8 (2025-11-28)

### 🩹 Fixes

- improve riscv Signed-off-by: Javier Ribó <elribonazo@gmail.com> ([34b1767](https://github.com/elribonazo/riscv-vm/commit/34b1767))

### ❤️ Thank You

- Javier Ribó

## 0.0.7 (2025-11-28)

### 🩹 Fixes

- release package Signed-off-by: Javier Ribó <elribonazo@gmail.com> ([c56a0df](https://github.com/elribonazo/riscv-vm/commit/c56a0df))

### ❤️ Thank You

- Javier Ribó

## 0.0.6 (2025-11-28)

### 🩹 Fixes

- vm Bavy Signed-off-by: Javier Ribó <elribonazo@gmail.com> ([fbb9a43](https://github.com/elribonazo/riscv-vm/commit/fbb9a43))

### ❤️ Thank You

- Javier Ribó

## 0.0.5 (2025-11-28)

### 🩹 Fixes

- build release Signed-off-by: Javier Ribó <elribonazo@gmail.com> ([94ad7a1](https://github.com/elribonazo/riscv-vm/commit/94ad7a1))
- pipelines Signed-off-by: Javier Ribó <elribonazo@gmail.com> ([34664a9](https://github.com/elribonazo/riscv-vm/commit/34664a9))
- versions Signed-off-by: Javier Ribó <elribonazo@gmail.com> ([a49158f](https://github.com/elribonazo/riscv-vm/commit/a49158f))
- improve kernel Signed-off-by: Javier Ribó <elribonazo@gmail.com> ([39a361a](https://github.com/elribonazo/riscv-vm/commit/39a361a))
- release Signed-off-by: Javier Ribó <elribonazo@gmail.com> ([b37c638](https://github.com/elribonazo/riscv-vm/commit/b37c638))
- release version Signed-off-by: Javier Ribó <elribonazo@gmail.com> ([23f0ded](https://github.com/elribonazo/riscv-vm/commit/23f0ded))
- versions Signed-off-by: Javier Ribó <elribonazo@gmail.com> ([b715645](https://github.com/elribonazo/riscv-vm/commit/b715645))
- versions Signed-off-by: Javier Ribó <elribonazo@gmail.com> ([2b2a498](https://github.com/elribonazo/riscv-vm/commit/2b2a498))
- test ci Signed-off-by: Javier Ribó <elribonazo@gmail.com> ([7d15c50](https://github.com/elribonazo/riscv-vm/commit/7d15c50))
- general improvements Signed-off-by: Javier Ribó <elribonazo@gmail.com> ([3248357](https://github.com/elribonazo/riscv-vm/commit/3248357))
- refactor images and context Signed-off-by: Javier Ribó <elribonazo@gmail.com> ([7ec91b6](https://github.com/elribonazo/riscv-vm/commit/7ec91b6))
- relay service Signed-off-by: Javier Ribó <elribonazo@gmail.com> ([bc45c89](https://github.com/elribonazo/riscv-vm/commit/bc45c89))
- wip network Signed-off-by: Javier Ribó <elribonazo@gmail.com> ([bec5717](https://github.com/elribonazo/riscv-vm/commit/bec5717))
- networking improvement Signed-off-by: Javier Ribó <elribonazo@gmail.com> ([2929223](https://github.com/elribonazo/riscv-vm/commit/2929223))

### ❤️ Thank You

- Javier Ribó
</file>

<file path="riscv-vm/package.json">
{
  "name": "virtual-machine",
  "version": "0.0.37",
  "description": "RISC-V Virtual Machine with WASM and Node.js native support",
  "bin": "build/cli.js",
  "publishConfig": {
    "access": "public"
  },
  "main": "./build/index.js",
  "module": "./build/index.mjs",
  "types": "./build/index.d.ts",
  "exports": {
    ".": {
      "types": "./build/index.d.ts",
      "import": "./build/index.mjs",
      "require": "./build/index.js"
    },
    "./worker": {
      "types": "./build/worker.d.ts",
      "import": "./build/worker.mjs",
      "require": "./build/worker.js"
    },
    "./native": {
      "import": "./native/index.mjs",
      "require": "./native/index.js"
    }
  },
  "napi": {
    "name": "riscv-vm-native",
    "triples": {
      "defaults": false,
      "additional": [
        "x86_64-apple-darwin",
        "aarch64-apple-darwin",
        "x86_64-unknown-linux-gnu",
        "aarch64-unknown-linux-gnu",
        "x86_64-unknown-linux-musl",
        "aarch64-unknown-linux-musl",
        "x86_64-pc-windows-msvc"
      ]
    }
  },
  "files": [
    "build",
    "native"
  ],
  "scripts": {
    "build": "rm -rf build && sh build.sh",
    "build:native": "napi build --platform --release --features napi --cargo-cwd . --cargo-flags=\"--lib\" native",
    "build:native:debug": "napi build --platform --features napi --cargo-cwd . --cargo-flags=\"--lib\" native",
    "build:all": "npm run build && npm run build:native"
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/elribonazo/riscv-vm"
  },
  "author": "elribonazo@gmail.com",
  "license": "ISC",
  "dependencies": {
    "yargs": "^18.0.0"
  },
  "packageManager": "yarn@4.11.0+sha512.4e54aeace9141df2f0177c266b05ec50dc044638157dae128c471ba65994ac802122d7ab35bcd9e81641228b7dcf24867d28e750e0bcae8a05277d600008ad54",
  "devDependencies": {
    "@esbuild-plugins/node-resolve": "^0.2.2",
    "@napi-rs/cli": "^2.18.0",
    "@trust0/ridb-build": "^0.0.21",
    "@types/node": "^24.10.1",
    "tsup": "^8.4.0",
    "typescript": "^5.8.3"
  }
}
</file>

<file path="riscv-vm/Cargo.toml">
[package]
name = "riscv-vm"
version = "0.0.37"
edition = "2024"

[lib]
crate-type = ["cdylib", "rlib"]

[features]
default = []
# Enable Node.js native addon via napi-rs (for WebTransport in Node.js)
napi = ["napi-rs", "napi-derive"]

[dependencies]
log = "0.4"
thiserror = "1.0"
hex = "0.4"
env_logger = "0.10"
clap = { version = "4.4", features = ["derive"] }
libc = "0.2"
goblin = "0.8"
serde = { version = "1.0", features = ["derive"] }
bincode = "1.3"
sha2 = "0.10"
wasm-bindgen = "0.2"

# napi-rs bindings (optional, for Node.js native addon)
napi-rs = { package = "napi", version = "2", features = ["async", "tokio_rt"], optional = true }
napi-derive = { version = "2", optional = true }

[target.'cfg(not(target_arch = "wasm32"))'.dependencies]
reqwest = { version = "0.12", default-features = false, features = ["blocking", "rustls-tls"] }
tungstenite = "0.21"
# WebTransport for connecting to the relay
wtransport = { version = "0.6", features = ["dangerous-configuration"] }
tokio = { version = "1", features = ["full"] }
futures = "0.3"

# Unix-only dependencies (tun-tap doesn't support Windows)
[target.'cfg(all(not(target_arch = "wasm32"), unix))'.dependencies]
tun-tap = "0.1"

[target.'cfg(target_arch = "wasm32")'.dependencies]
console_error_panic_hook = "0.1"
web-sys = { version = "0.3", features = [
    "WebSocket", 
    "MessageEvent", 
    "BinaryType", 
    "ErrorEvent", 
    "CloseEvent",
    "WebTransport",
    "WebTransportOptions",
    "WebTransportHash",
    "WebTransportDatagramDuplexStream",
    "ReadableStream",
    "WritableStream",
    "ReadableStreamDefaultReader",
    "WritableStreamDefaultWriter",
    "console",
    "Window",
    "Navigator",
    "Worker",
    "WorkerOptions",
    "WorkerType"
] }
js-sys = "0.3"
wasm-bindgen-futures = "0.4"

[build-dependencies]
# napi-build is always included but only used when napi feature is enabled
napi-build = "2"

# Note: Release profile is defined at workspace root (Cargo.toml)
</file>

</files>
